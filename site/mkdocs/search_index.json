{
    "docs": [
        {
            "location": "/Preface/", 
            "text": "Attribution\n\n\nThis documentation is a compilation of the following sources:\n\n\nantirez/redis\n\n\nRedisLabs/RedisModulesSDK\n\n\nAll rights belong to the original authors\n. This material is provided for reference only.", 
            "title": "Preface"
        }, 
        {
            "location": "/Preface/#attribution", 
            "text": "This documentation is a compilation of the following sources:  antirez/redis  RedisLabs/RedisModulesSDK  All rights belong to the original authors . This material is provided for reference only.", 
            "title": "Attribution"
        }, 
        {
            "location": "/", 
            "text": "Redis Modules: an introduction to the API\n\n\nThe modules documentation is composed of the following files:\n\n\n\n\nINTRO.md\n (this file). An overview about Redis Modules system and API. It's a good idea to start your reading here.\n\n\nAPI.md\n is generated from module.c top comments of RedisMoule functions. It is a good reference in order to understand how each function works.\n\n\nTYPES.md\n covers the implementation of native data types into modules.\n\n\nBLOCK.md\n shows how to write blocking commands that will not reply immediately, but will block the client, without blocking the Redis server, and will provide a reply whenever will be possible.\n\n\n\n\nRedis modules make possible to extend Redis functionality using external\nmodules, implementing new Redis commands at a speed and with features\nsimilar to what can be done inside the core itself.\n\n\nRedis modules are dynamic libraries, that can be loaded into Redis at\nstartup or using the \nMODULE LOAD\n command. Redis exports a C API, in the\nform of a single C header file called \nredismodule.h\n. Modules are meant\nto be written in C, however it will be possible to use C++ or other languages\nthat have C binding functionalities.\n\n\nModules are designed in order to be loaded into different versions of Redis,\nso a given module does not need to be designed, or recompiled, in order to\nrun with a specific version of Redis. For this reason, the module will\nregister to the Redis core using a specific API version. The current API\nversion is \"1\".\n\n\nThis document is about an alpha version of Redis modules. API, functionalities\nand other details may change in the future.\n\n\nLoading modules\n\n\nIn order to test the module you are developing, you can load the module\nusing the following \nredis.conf\n configuration directive:\n\n\nloadmodule /path/to/mymodule.so\n\n\n\nIt is also possible to load a module at runtime using the following command:\n\n\nMODULE LOAD /path/to/mymodule.so\n\n\n\nIn order to list all loaded modules, use:\n\n\nMODULE LIST\n\n\n\nFinally, you can unload (and later reload if you wish) a module using the\nfollowing command:\n\n\nMODULE UNLOAD mymodule\n\n\n\nNote that \nmymodule\n above is not the filename without the \n.so\n suffix, but\ninstead, the name the module used to register itself into the Redis core.\nThe name can be obtained using \nMODULE LIST\n. However it is good practice\nthat the filename of the dynamic library is the same as the name the module\nuses to register itself into the Redis core.\n\n\nThe simplest module you can write\n\n\nIn order to show the different parts of a module, here we'll show a very\nsimple module that implements a command that outputs a random number.\n\n\n#include \"redismodule.h\"\n#include \nstdlib.h\n\n\nint HelloworldRand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    RedisModule_ReplyWithLongLong(ctx,rand());\n    return REDISMODULE_OK;\n}\n\nint RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    if (RedisModule_Init(ctx,\"helloworld\",1,REDISMODULE_APIVER_1)\n        == REDISMODULE_ERR) return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\"helloworld.rand\",\n        HelloworldRand_RedisCommand) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    return REDISMODULE_OK;\n}\n\n\n\nThe example module has two functions. One implements a command called\nHELLOWORLD.RAND. This function is specific of that module. However the\nother function called \nRedisModule_OnLoad()\n must be present in each\nRedis module. It is the entry point for the module to be initialized,\nregister its commands, and potentially other private data structures\nit uses.\n\n\nNote that it is a good idea for modules to call commands with the\nname of the module followed by a dot, and finally the command name,\nlike in the case of \nHELLOWORLD.RAND\n. This way it is less likely to\nhave collisions.\n\n\nNote that if different modules have colliding commands, they'll not be\nable to work in Redis at the same time, since the function\n\nRedisModule_CreateCommand\n will fail in one of the modules, so the module\nloading will abort returning an error condition.\n\n\nModule initialization\n\n\nThe above example shows the usage of the function \nRedisModule_Init()\n.\nIt should be the first function called by the module \nOnLoad\n function.\nThe following is the function prototype:\n\n\nint RedisModule_Init(RedisModuleCtx *ctx, const char *modulename,\n                     int module_version, int api_version);\n\n\n\nThe \nInit\n function announces the Redis core that the module has a given\nname, its version (that is reported by \nMODULE LIST\n), and that is willing\nto use a specific version of the API.\n\n\nIf the API version is wrong, the name is already taken, or there are other\nsimilar errors, the function will return \nREDISMODULE_ERR\n, and the module\n\nOnLoad\n function should return ASAP with an error.\n\n\nBefore the \nInit\n function is called, no other API function can be called,\notherwise the module will segfault and the Redis instance will crash.\n\n\nThe second function called, \nRedisModule_CreateCommand\n, is used in order\nto register commands into the Redis core. The following is the prototype:\n\n\nint RedisModule_CreateCommand(RedisModuleCtx *ctx, const char *cmdname,\n                              RedisModuleCmdFunc cmdfunc);\n\n\n\nAs you can see, most Redis modules API calls all take as first argument\nthe \ncontext\n of the module, so that they have a reference to the module\ncalling it, to the command and client executing a given command, and so forth.\n\n\nTo create a new command, the above function needs the context, the command\nname, and the function pointer of the function implementing the command,\nwhich must have the following prototype:\n\n\nint mycommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc);\n\n\n\nThe command function arguments are just the context, that will be passed\nto all the other API calls, the command argument vector, and total number\nof arguments, as passed by the user.\n\n\nAs you can see, the arguments are provided as pointers to a specific data\ntype, the \nRedisModuleString\n. This is an opaque data type you have API\nfunctions to access and use, direct access to its fields is never needed.\n\n\nZooming into the example command implementation, we can find another call:\n\n\nint RedisModule_ReplyWithLongLong(RedisModuleCtx *ctx, long long integer);\n\n\n\nThis function returns an integer to the client that invoked the command,\nexactly like other Redis commands do, like for example \nINCR\n or \nSCARD\n.\n\n\nSetup and dependencies of a Redis module\n\n\nRedis modules don't depend on Redis or some other library, nor they\nneed to be compiled with a specific \nredismodule.h\n file. In order\nto create a new module, just copy a recent version of \nredismodule.h\n\nin your source tree, link all the libraries you want, and create\na dynamic library having the \nRedisModule_OnLoad()\n function symbol\nexported.\n\n\nThe module will be able to load into different versions of Redis.\n\n\nPassing configuration parameters to Redis modules\n\n\nWhen the module is loaded with the \nMODULE LOAD\n command, or using the\n\nloadmodule\n directive in the \nredis.conf\n file, the user is able to pass\nconfiguration parameters to the module by adding arguments after the module\nfile name:\n\n\nloadmodule mymodule.so foo bar 1234\n\n\n\nIn the above example the strings \nfoo\n, \nbar\n and \n123\n will be passed\nto the module \nOnLoad()\n function in the \nargv\n argument as an array\nof RedisModuleString pointers. The number of arguments passed is into \nargc\n.\n\n\nThe way you can access those strings will be explained in the rest of this\ndocument. Normally the module will store the module configuration parameters\nin some \nstatic\n global variable that can be accessed module wide, so that\nthe configuration can change the behavior of different commands.\n\n\nWorking with RedisModuleString objects\n\n\nThe command argument vector \nargv\n passed to module commands, and the\nreturn value of other module APIs functions, are of type \nRedisModuleString\n.\n\n\nUsually you directly pass module strings to other API calls, however sometimes\nyou may need to directly access the string object.\n\n\nThere are a few functions in order to work with string objects:\n\n\nconst char *RedisModule_StringPtrLen(RedisModuleString *string, size_t *len);\n\n\n\nThe above function accesses a string by returning its pointer and setting its\nlength in \nlen\n.\nYou should never write to a string object pointer, as you can see from the\n\nconst\n pointer qualifier.\n\n\nHowever, if you want, you can create new string objects using the following\nAPI:\n\n\nRedisModuleString *RedisModule_CreateString(RedisModuleCtx *ctx, const char *ptr, size_t len);\n\n\n\nThe string returned by the above command must be freed using a corresponding\ncall to \nRedisModule_FreeString()\n:\n\n\nvoid RedisModule_FreeString(RedisModuleString *str);\n\n\n\nHowever if you want to avoid having to free strings, the automatic memory\nmanagement, covered later in this document, can be a good alternative, by\ndoing it for you.\n\n\nNote that the strings provided via the argument vector \nargv\n never need\nto be freed. You only need to free new strings you create, or new strings\nreturned by other APIs, where it is specified that the returned string must\nbe freed.\n\n\nCreating strings from numbers or parsing strings as numbers\n\n\nCreating a new string from an integer is a very common operation, so there\nis a function to do this:\n\n\nRedisModuleString *mystr = RedisModule_CreateStringFromLongLong(ctx,10);\n\n\n\nSimilarly in order to parse a string as a number:\n\n\nlong long myval;\nif (RedisModule_StringToLongLong(ctx,argv[1],\nmyval) == REDISMODULE_OK) {\n    /* Do something with 'myval' */\n}\n\n\n\nAccessing Redis keys from modules\n\n\nMost Redis modules, in order to be useful, have to interact with the Redis\ndata space (this is not always true, for example an ID generator may\nnever touch Redis keys). Redis modules have two different APIs in order to\naccess the Redis data space, one is a low level API that provides very\nfast access and a set of functions to manipulate Redis data structures.\nThe other API is more high level, and allows to call Redis commands and\nfetch the result, similarly to how Lua scripts access Redis.\n\n\nThe high level API is also useful in order to access Redis functionalities\nthat are not available as APIs.\n\n\nIn general modules developers should prefer the low level API, because commands\nimplemented using the low level API run at a speed comparable to the speed\nof native Redis commands. However there are definitely use cases for the\nhigher level API. For example often the bottleneck could be processing the\ndata and not accessing it.\n\n\nAlso note that sometimes using the low level API is not harder compared to\nthe higher level one.\n\n\nCalling Redis commands\n\n\nThe high level API to access Redis is the sum of the \nRedisModule_Call()\n\nfunction, together with the functions needed in order to access the\nreply object returned by \nCall()\n.\n\n\nRedisModule_Call\n uses a special calling convention, with a format specifier\nthat is used to specify what kind of objects you are passing as arguments\nto the function.\n\n\nRedis commands are invoked just using a command name and a list of arguments.\nHowever when calling commands, the arguments may originate from different\nkind of strings: null-terminated C strings, RedisModuleString objects as\nreceived from the \nargv\n parameter in the command implementation, binary\nsafe C buffers with a pointer and a length, and so forth.\n\n\nFor example if I want to call \nINCRBY\n using a first argument (the key)\na string received in the argument vector \nargv\n, which is an array\nof RedisModuleString object pointers, and a C string representing the\nnumber \"10\" as second argument (the increment), I'll use the following\nfunction call:\n\n\nRedisModuleCallReply *reply;\nreply = RedisModule_Call(ctx,\"INCR\",\"sc\",argv[1],\"10\");\n\n\n\nThe first argument is the context, and the second is always a null terminated\nC string with the command name. The third argument is the format specifier\nwhere each character corresponds to the type of the arguments that will follow.\nIn the above case \n\"sc\"\n means a RedisModuleString object, and a null\nterminated C string. The other arguments are just the two arguments as\nspecified. In fact \nargv[1]\n is a RedisModuleString and \n\"10\"\n is a null\nterminated C string.\n\n\nThis is the full list of format specifiers:\n\n\n\n\nc\n -- Null terminated C string pointer.\n\n\nb\n -- C buffer, two arguments needed: C string pointer and \nsize_t\n length.\n\n\ns\n -- RedisModuleString as received in \nargv\n or by other Redis module APIs returning a RedisModuleString object.\n\n\nl\n -- Long long integer.\n\n\nv\n -- Array of RedisModuleString objects.\n\n\n!\n -- This modifier just tells the function to replicate the command to slaves and AOF. It is ignored from the point of view of arguments parsing.\n\n\n\n\nThe function returns a \nRedisModuleCallReply\n object on success, on\nerror NULL is returned.\n\n\nNULL is returned when the command name is invalid, the format specifier uses\ncharacters that are not recognized, or when the command is called with the\nwrong number of arguments. In the above cases the \nerrno\n var is set to \nEINVAL\n. NULL is also returned when, in an instance with Cluster enabled, the target\nkeys are about non local hash slots. In this case \nerrno\n is set to \nEPERM\n.\n\n\nWorking with RedisModuleCallReply objects.\n\n\nRedisModuleCall\n returns reply objects that can be accessed using the\n\nRedisModule_CallReply*\n family of functions.\n\n\nIn order to obtain the type or reply (corresponding to one of the data types\nsupported by the Redis protocol), the function \nRedisModule_CallReplyType()\n\nis used:\n\n\nreply = RedisModule_Call(ctx,\"INCR\",\"sc\",argv[1],\"10\");\nif (RedisModule_CallReplyType(reply) == REDISMODULE_REPLY_INTEGER) {\n    long long myval = RedisModule_CallReplyInteger(reply);\n    /* Do something with myval. */\n}\n\n\n\nValid reply types are:\n\n\n\n\nREDISMODULE_REPLY_STRING\n Bulk string or status replies.\n\n\nREDISMODULE_REPLY_ERROR\n Errors.\n\n\nREDISMODULE_REPLY_INTEGER\n Signed 64 bit integers.\n\n\nREDISMODULE_REPLY_ARRAY\n Array of replies.\n\n\nREDISMODULE_REPLY_NULL\n NULL reply.\n\n\n\n\nStrings, errors and arrays have an associated length. For strings and errors\nthe length corresponds to the length of the string. For arrays the length\nis the number of elements. To obtain the reply length the following function\nis used:\n\n\nsize_t reply_len = RedisModule_CallReplyLength(reply);\n\n\n\nIn order to obtain the value of an integer reply, the following function is used, as already shown in the example above:\n\n\nlong long reply_integer_val = RedisModule_CallReplyInteger(reply);\n\n\n\nCalled with a reply object of the wrong type, the above function always\nreturns \nLLONG_MIN\n.\n\n\nSub elements of array replies are accessed this way:\n\n\nRedisModuleCallReply *subreply;\nsubreply = RedisModule_CallReplyArrayElement(reply,idx);\n\n\n\nThe above function returns NULL if you try to access out of range elements.\n\n\nStrings and errors (which are like strings but with a different type) can\nbe accessed using in the following way, making sure to never write to\nthe resulting pointer (that is returned as as \nconst\n pointer so that\nmisusing must be pretty explicit):\n\n\nsize_t len;\nchar *ptr = RedisModule_CallReplyStringPtr(reply,\nlen);\n\n\n\nIf the reply type is not a string or an error, NULL is returned.\n\n\nRedisCallReply objects are not the same as module string objects\n(RedisModuleString types). However sometimes you may need to pass replies\nof type string or integer, to API functions expecting a module string.\n\n\nWhen this is the case, you may want to evaluate if using the low level\nAPI could be a simpler way to implement your command, or you can use\nthe following function in order to create a new string object from a\ncall reply of type string, error or integer:\n\n\nRedisModuleString *mystr = RedisModule_CreateStringFromCallReply(myreply);\n\n\n\nIf the reply is not of the right type, NULL is returned.\nThe returned string object should be released with \nRedisModule_FreeString()\n\nas usually, or by enabling automatic memory management (see corresponding\nsection).\n\n\nReleasing call reply objects\n\n\nReply objects must be freed using \nRedisModule_FreeCallReply\n. For arrays,\nyou need to free only the top level reply, not the nested replies.\nCurrently the module implementation provides a protection in order to avoid\ncrashing if you free a nested reply object for error, however this feature\nis not guaranteed to be here forever, so should not be considered part\nof the API.\n\n\nIf you use automatic memory management (explained later in this document)\nyou don't need to free replies (but you still could if you wish to release\nmemory ASAP).\n\n\nReturning values from Redis commands\n\n\nLike normal Redis commands, new commands implemented via modules must be\nable to return values to the caller. The API exports a set of functions for\nthis goal, in order to return the usual types of the Redis protocol, and\narrays of such types as elemented. Also errors can be returned with any\nerror string and code (the error code is the initial uppercase letters in\nthe error message, like the \"BUSY\" string in the \"BUSY the sever is busy\" error\nmessage).\n\n\nAll the functions to send a reply to the client are called\n\nRedisModule_ReplyWith\nsomething\n.\n\n\nTo return an error, use:\n\n\nRedisModule_ReplyWithError(RedisModuleCtx *ctx, const char *err);\n\n\n\nThere is a predefined error string for key of wrong type errors:\n\n\nREDISMODULE_ERRORMSG_WRONGTYPE\n\n\n\nExample usage:\n\n\nRedisModule_ReplyWithError(ctx,\"ERR invalid arguments\");\n\n\n\nWe already saw how to reply with a long long in the examples above:\n\n\nRedisModule_ReplyWithLongLong(ctx,12345);\n\n\n\nTo reply with a simple string, that can't contain binary values or newlines,\n(so it's suitable to send small words, like \"OK\") we use:\n\n\nRedisModule_ReplyWithSimpleString(ctx,\"OK\");\n\n\n\nIt's possible to reply with \"bulk strings\" that are binary safe, using\ntwo different functions:\n\n\nint RedisModule_ReplyWithStringBuffer(RedisModuleCtx *ctx, const char *buf, size_t len);\n\nint RedisModule_ReplyWithString(RedisModuleCtx *ctx, RedisModuleString *str);\n\n\n\nThe first function gets a C pointer and length. The second a RedisMoudleString\nobject. Use one or the other depending on the source type you have at hand.\n\n\nIn order to reply with an array, you just need to use a function to emit the\narray length, followed by as many calls to the above functions as the number\nof elements of the array are:\n\n\nRedisModule_ReplyWithArray(ctx,2);\nRedisModule_ReplyWithStringBuffer(ctx,\"age\",3);\nRedisModule_ReplyWithLongLong(ctx,22);\n\n\n\nTo return nested arrays is easy, your nested array element just uses another\ncall to \nRedisModule_ReplyWithArray()\n followed by the calls to emit the\nsub array elements.\n\n\nReturning arrays with dynamic length\n\n\nSometimes it is not possible to know beforehand the number of items of\nan array. As an example, think of a Redis module implementing a FACTOR\ncommand that given a number outputs the prime factors. Instead of\nfactorializing the number, storing the prime factors into an array, and\nlater produce the command reply, a better solution is to start an array\nreply where the length is not known, and set it later. This is accomplished\nwith a special argument to \nRedisModule_ReplyWithArray()\n:\n\n\nRedisModule_ReplyWithArray(ctx, REDISMODULE_POSTPONED_ARRAY_LEN);\n\n\n\nThe above call starts an array reply so we can use other \nReplyWith\n calls\nin order to produce the array items. Finally in order to set the length\nse use the following call:\n\n\nRedisModule_ReplySetArrayLength(ctx, number_of_items);\n\n\n\nIn the case of the FACTOR command, this translates to some code similar\nto this:\n\n\nRedisModule_ReplyWithArray(ctx, REDISMODULE_POSTPONED_ARRAY_LEN);\nnumber_of_factors = 0;\nwhile(still_factors) {\n    RedisModule_ReplyWithLongLong(ctx, some_factor);\n    number_of_factors++;\n}\nRedisModule_ReplySetArrayLength(ctx, number_of_factors);\n\n\n\nAnother common use case for this feature is iterating over the arrays of\nsome collection and only returning the ones passing some kind of filtering.\n\n\nIt is possible to have multiple nested arrays with postponed reply.\nEach call to \nSetArray()\n will set the length of the latest corresponding\ncall to \nReplyWithArray()\n:\n\n\nRedisModule_ReplyWithArray(ctx, REDISMODULE_POSTPONED_ARRAY_LEN);\n... generate 100 elements ...\nRedisModule_ReplyWithArray(ctx, REDISMODULE_POSTPONED_ARRAY_LEN);\n... generate 10 elements ...\nRedisModule_ReplySetArrayLength(ctx, 10);\nRedisModule_ReplySetArrayLength(ctx, 100);\n\n\n\nThis creates a 100 items array having as last element a 10 items array.\n\n\nArity and type checks\n\n\nOften commands need to check that the number of arguments and type of the key\nis correct. In order to report a wrong arity, there is a specific function\ncalled \nRedisModule_WrongArity()\n. The usage is trivial:\n\n\nif (argc != 2) return RedisModule_WrongArity(ctx);\n\n\n\nChecking for the wrong type involves opening the key and checking the type:\n\n\nRedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],\n    REDISMODULE_READ|REDISMODULE_WRITE);\n\nint keytype = RedisModule_KeyType(key);\nif (keytype != REDISMODULE_KEYTYPE_STRING \n\n    keytype != REDISMODULE_KEYTYPE_EMPTY)\n{\n    RedisModule_CloseKey(key);\n    return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);\n}\n\n\n\nNote that you often want to proceed with a command both if the key\nis of the expected type, or if it's empty.\n\n\nLow level access to keys\n\n\nLow level access to keys allow to perform operations on value objects associated\nto keys directly, with a speed similar to what Redis uses internally to\nimplement the built-in commands.\n\n\nOnce a key is opened, a key pointer is returned that will be used with all the\nother low level API calls in order to perform operations on the key or its\nassociated value.\n\n\nBecause the API is meant to be very fast, it cannot do too many run-time\nchecks, so the user must be aware of certain rules to follow:\n\n\n\n\nOpening the same key multiple times where at least one instance is opened for writing, is undefined and may lead to crashes.\n\n\nWhile a key is open, it should only be accessed via the low level key API. For example opening a key, then calling DEL on the same key using the \nRedisModule_Call()\n API will result into a crash. However it is safe to open a key, perform some operation with the low level API, closing it, then using other APIs to manage the same key, and later opening it again to do some more work.\n\n\n\n\nIn order to open a key the \nRedisModule_OpenKey\n function is used. It returns\na key pointer, that we'll use with all the next calls to access and modify\nthe value:\n\n\nRedisModuleKey *key;\nkey = RedisModule_OpenKey(ctx,argv[1],REDISMODULE_READ);\n\n\n\nThe second argument is the key name, that must be a \nRedisModuleString\n object.\nThe third argument is the mode: \nREDISMODULE_READ\n or \nREDISMODULE_WRITE\n.\nIt is possible to use \n|\n to bitwise OR the two modes to open the key in\nboth modes. Currently a key opened for writing can also be accessed for reading\nbut this is to be considered an implementation detail. The right mode should\nbe used in sane modules.\n\n\nYou can open non exisitng keys for writing, since the keys will be created\nwhen an attempt to write to the key is performed. However when opening keys\njust for reading, \nRedisModule_OpenKey\n will return NULL if the key does not\nexist.\n\n\nOnce you are done using a key, you can close it with:\n\n\nRedisModule_CloseKey(key);\n\n\n\nNote that if automatic memory management is enabled, you are not forced to\nclose keys. When the module function returns, Redis will take care to close\nall the keys which are still open.\n\n\nGetting the key type\n\n\nIn order to obtain the value of a key, use the \nRedisModule_KeyType()\n function:\n\n\nint keytype = RedisModule_KeyType(key);\n\n\n\nIt returns one of the following values:\n\n\nREDISMODULE_KEYTYPE_EMPTY\nREDISMODULE_KEYTYPE_STRING\nREDISMODULE_KEYTYPE_LIST\nREDISMODULE_KEYTYPE_HASH\nREDISMODULE_KEYTYPE_SET\nREDISMODULE_KEYTYPE_ZSET\n\n\n\nThe above are just the usual Redis key types, with the addition of an empty\ntype, that signals the key pointer is associated with an empty key that\ndoes not yet exists.\n\n\nCreating new keys\n\n\nTo create a new key, open it for writing and then write to it using one\nof the key writing functions. Example:\n\n\nRedisModuleKey *key;\nkey = RedisModule_OpenKey(ctx,argv[1],REDISMODULE_READ);\nif (RedisModule_KeyType(key) == REDISMODULE_KEYTYPE_EMPTY) {\n    RedisModule_StringSet(key,argv[2]);\n}\n\n\n\nDeleting keys\n\n\nJust use:\n\n\nRedisModule_DeleteKey(key);\n\n\n\nThe function returns \nREDISMODULE_ERR\n if the key is not open for writing.\nNote that after a key gets deleted, it is setup in order to be targeted\nby new key commands. For example \nRedisModule_KeyType()\n will return it is\nan empty key, and writing to it will create a new key, possibly of another\ntype (depending on the API used).\n\n\nManaging key expires (TTLs)\n\n\nTo control key expires two functions are provided, that are able to set,\nmodify, get, and unset the time to live associated with a key.\n\n\nOne function is used in order to query the current expire of an open key:\n\n\nmstime_t RedisModule_GetExpire(RedisModuleKey *key);\n\n\n\nThe function returns the time to live of the key in milliseconds, or\n\nREDISMODULE_NO_EXPIRE\n as a special value to signal the key has no associated\nexpire or does not exist at all (you can differentiate the two cases checking\nif the key type is \nREDISMODULE_KEYTYPE_EMPTY\n).\n\n\nIn order to change the expire of a key the following function is used instead:\n\n\nint RedisModule_SetExpire(RedisModuleKey *key, mstime_t expire);\n\n\n\nWhen called on a non existing key, \nREDISMODULE_ERR\n is returned, because\nthe function can only associate expires to existing open keys (non existing\nopen keys are only useful in order to create new values with data type\nspecific write operations).\n\n\nAgain the \nexpire\n time is specified in milliseconds. If the key has currently\nno expire, a new expire is set. If the key already have an expire, it is\nreplaced with the new value.\n\n\nIf the key has an expire, and the special value \nREDISMODULE_NO_EXPIRE\n is\nused as a new expire, the expire is removed, similarly to the Redis\n\nPERSIST\n command. In case the key was already persistent, no operation is\nperformed.\n\n\nObtaining the length of values\n\n\nThere is a single function in order to retrieve the length of the value\nassociated to an open key. The returned length is value-specific, and is\nthe string length for strings, and the number of elements for the aggregated\ndata types (how many elements there is in a list, set, sorted set, hash).\n\n\nsize_t len = RedisModule_ValueLength(key);\n\n\n\nIf the key does not exist, 0 is returned by the function:\n\n\nString type API\n\n\nSetting a new string value, like the Redis \nSET\n command does, is performed\nusing:\n\n\nint RedisModule_StringSet(RedisModuleKey *key, RedisModuleString *str);\n\n\n\nThe function works exactly like the Redis \nSET\n command itself, that is, if\nthere is a prior value (of any type) it will be deleted.\n\n\nAccessing existing string values is performed using DMA (direct memory\naccess) for speed. The API will return a pointer and a length, so that's\npossible to access and, if needed, modify the string directly.\n\n\nsize_t len, j;\nchar *myptr = RedisModule_StringDMA(key,\nlen,REDISMODULE_WRITE);\nfor (j = 0; j \n len; j++) myptr[j] = 'A';\n\n\n\nIn the above example we write directly on the string. Note that if you want\nto write, you must be sure to ask for \nWRITE\n mode.\n\n\nDMA pointers are only valid if no other operations are performed with the key\nbefore using the pointer, after the DMA call.\n\n\nSometimes when we want to manipulate strings directly, we need to change\ntheir size as well. For this scope, the \nRedisModule_StringTruncate\n function\nis used. Example:\n\n\nRedisModule_StringTruncate(mykey,1024);\n\n\n\nThe function truncates, or enlarges the string as needed, padding it with\nzero bytes if the previos length is smaller than the new length we request.\nIf the string does not exist since \nkey\n is associated to an open empty key,\na string value is created and associated to the key.\n\n\nNote that every time \nStringTruncate()\n is called, we need to re-obtain\nthe DMA pointer again, since the old may be invalid.\n\n\nList type API\n\n\nIt's possible to push and pop values from list values:\n\n\nint RedisModule_ListPush(RedisModuleKey *key, int where, RedisModuleString *ele);\nRedisModuleString *RedisModule_ListPop(RedisModuleKey *key, int where);\n\n\n\nIn both the APIs the \nwhere\n argument specifies if to push or pop from tail\nor head, using the following macros:\n\n\nREDISMODULE_LIST_HEAD\nREDISMODULE_LIST_TAIL\n\n\n\nElements returned by \nRedisModule_ListPop()\n are like strings craeted with\n\nRedisModule_CreateString()\n, they must be released with\n\nRedisModule_FreeString()\n or by enabling automatic memory management.\n\n\nSet type API\n\n\nWork in progress.\n\n\nSorted set type API\n\n\nDocumentation missing, please refer to the top comments inside \nmodule.c\n\nfor the following functions:\n\n\n\n\nRedisModule_ZsetAdd\n\n\nRedisModule_ZsetIncrby\n\n\nRedisModule_ZsetScore\n\n\nRedisModule_ZsetRem\n\n\n\n\nAnd for the sorted set iterator:\n\n\n\n\nRedisModule_ZsetRangeStop\n\n\nRedisModule_ZsetFirstInScoreRange\n\n\nRedisModule_ZsetLastInScoreRange\n\n\nRedisModule_ZsetFirstInLexRange\n\n\nRedisModule_ZsetLastInLexRange\n\n\nRedisModule_ZsetRangeCurrentElement\n\n\nRedisModule_ZsetRangeNext\n\n\nRedisModule_ZsetRangePrev\n\n\nRedisModule_ZsetRangeEndReached\n\n\n\n\nHash type API\n\n\nDocumentation missing, please refer to the top comments inside \nmodule.c\n\nfor the following functions:\n\n\n\n\nRedisModule_HashSet\n\n\nRedisModule_HashGet\n\n\n\n\nIterating aggregated values\n\n\nWork in progress.\n\n\nReplicating commands\n\n\nIf you want to use module commands exactly like normal Redis commands, in the\ncontext of replicated Redis instances, or using the AOF file for persistence,\nit is important for module commands to handle their replication in a consistent\nway.\n\n\nWhen using the higher level APIs to invoke commands, replication happens\nautomatically if you use the \"!\" modifier in the format string of\n\nRedisModule_Call()\n as in the following example:\n\n\nreply = RedisModule_Call(ctx,\"INCR\",\"!sc\",argv[1],\"10\");\n\n\n\nAs you can see the format specifier is \n\"!sc\"\n. The bang is not parsed as a\nformat specifier, but it internally flags the command as \"must replicate\".\n\n\nIf you use the above programming style, there are no problems.\nHowever sometimes things are more complex than that, and you use the low level\nAPI. In this case, if there are no side effects in the command execution, and\nit consistently always performs the same work, what is possible to do is to\nreplicate the command verbatim as the user executed it. To do that, you just\nneed to call the following function:\n\n\nRedisModule_ReplicateVerbatim(ctx);\n\n\n\nWhen you use the above API, you should not use any other replication function\nsince they are not guaranteed to mix well.\n\n\nHowever this is not the only option. It's also possible to exactly tell\nRedis what commands to replicate as the effect of the command execution, using\nan API similar to \nRedisModule_Call()\n but that instead of calling the command\nsends it to the AOF / slaves stream. Example:\n\n\nRedisModule_Replicate(ctx,\"INCRBY\",\"cl\",\"foo\",my_increment);\n\n\n\nIt's possible to call \nRedisModule_Replicate\n multiple times, and each\nwill emit a command. All the sequence emitted is wrapped between a\n\nMULTI/EXEC\n transaction, so that the AOF and replication effects are the\nsame as executing a single command.\n\n\nNote that \nCall()\n replication and \nReplicate()\n replication have a rule,\nin case you want to mix both forms of replication (not necessarily a good\nidea if there are simpler approaches). Commands replicated with \nCall()\n\nare always the first emitted in the final \nMULTI/EXEC\n block, while all\nthe commands emitted with \nReplicate()\n will follow.\n\n\nAutomatic memory management\n\n\nNormally when writing programs in the C language, programmers need to manage\nmemory manually. This is why the Redis modules API has functions to release\nstrings, close open keys, free replies, and so forth.\n\n\nHowever given that commands are executed in a contained environment and\nwith a set of strict APIs, Redis is able to provide automatic memory management\nto modules, at the cost of some performance (most of the time, a very low\ncost).\n\n\nWhen automatic memory management is enabled:\n\n\n\n\nYou don't need to close open keys.\n\n\nYou don't need to free replies.\n\n\nYou don't need to free RedisModuleString objects.\n\n\n\n\nHowever you can still do it, if you want. For example, automatic memory\nmanagement may be active, but inside a loop allocating a lot of strings,\nyou may still want to free strings no longer used.\n\n\nIn order to enable automatic memory management, just call the following\nfunction at the start of the command implementation:\n\n\nRedisModule_AutoMemory(ctx);\n\n\n\nAutomatic memory management is usually the way to go, however experienced\nC programmers may not use it in order to gain some speed and memory usage\nbenefit.\n\n\nAllocating memory into modules\n\n\nNormal C programs use \nmalloc()\n and \nfree()\n in order to allocate and\nrelease memory dynamically. While in Redis modules the use of malloc is\nnot technically forbidden, it is a lot better to use the Redis Modules\nspecific functions, that are exact replacements for \nmalloc\n, \nfree\n,\n\nrealloc\n and \nstrdup\n. These functions are:\n\n\nvoid *RedisModule_Alloc(size_t bytes);\nvoid* RedisModule_Realloc(void *ptr, size_t bytes);\nvoid RedisModule_Free(void *ptr);\nvoid RedisModule_Calloc(size_t nmemb, size_t size);\nchar *RedisModule_Strdup(const char *str);\n\n\n\nThey work exactly like their \nlibc\n equivalent calls, however they use\nthe same allocator Redis uses, and the memory allocated using these\nfunctions is reported by the \nINFO\n command in the memory section, is\naccounted when enforcing the \nmaxmemory\n policy, and in general is\na first citizen of the Redis executable. On the contrar, the method\nallocated inside modules with libc \nmalloc()\n is transparent to Redis.\n\n\nAnother reason to use the modules functions in order to allocate memory\nis that, when creating native data types inside modules, the RDB loading\nfunctions can return deserialized strings (from the RDB file) directly\nas \nRedisModule_Alloc()\n allocations, so they can be used directly to\npopulate data structures after loading, instead of having to copy them\nto the data structure.\n\n\nPool allocator\n\n\nSometimes in commands implementations, it is required to perform many\nsmall allocations that will be not retained at the end of the command\nexecution, but are just functional to execute the command itself.\n\n\nThis work can be more easily accomplished using the Redis pool allocator:\n\n\nvoid *RedisModule_PoolAlloc(RedisModuleCtx *ctx, size_t bytes);\n\n\n\nIt works similarly to \nmalloc()\n, and returns memory aligned to the\nnext power of two of greater or equal to \nbytes\n (for a maximum alignment\nof 8 bytes). However it allocates memory in blocks, so it the overhead\nof the allocations is small, and more important, the memory allocated\nis automatically released when the command returns.\n\n\nSo in general short living allocations are a good candidates for the pool\nallocator.\n\n\nWriting commands compatible with Redis Cluster\n\n\nDocumentation missing, please check the following functions inside \nmodule.c\n:\n\n\nRedisModule_IsKeysPositionRequest(ctx);\nRedisModule_KeyAtPos(ctx,pos);", 
            "title": "Intro"
        }, 
        {
            "location": "/#redis-modules-an-introduction-to-the-api", 
            "text": "The modules documentation is composed of the following files:   INTRO.md  (this file). An overview about Redis Modules system and API. It's a good idea to start your reading here.  API.md  is generated from module.c top comments of RedisMoule functions. It is a good reference in order to understand how each function works.  TYPES.md  covers the implementation of native data types into modules.  BLOCK.md  shows how to write blocking commands that will not reply immediately, but will block the client, without blocking the Redis server, and will provide a reply whenever will be possible.   Redis modules make possible to extend Redis functionality using external\nmodules, implementing new Redis commands at a speed and with features\nsimilar to what can be done inside the core itself.  Redis modules are dynamic libraries, that can be loaded into Redis at\nstartup or using the  MODULE LOAD  command. Redis exports a C API, in the\nform of a single C header file called  redismodule.h . Modules are meant\nto be written in C, however it will be possible to use C++ or other languages\nthat have C binding functionalities.  Modules are designed in order to be loaded into different versions of Redis,\nso a given module does not need to be designed, or recompiled, in order to\nrun with a specific version of Redis. For this reason, the module will\nregister to the Redis core using a specific API version. The current API\nversion is \"1\".  This document is about an alpha version of Redis modules. API, functionalities\nand other details may change in the future.", 
            "title": "Redis Modules: an introduction to the API"
        }, 
        {
            "location": "/#loading-modules", 
            "text": "In order to test the module you are developing, you can load the module\nusing the following  redis.conf  configuration directive:  loadmodule /path/to/mymodule.so  It is also possible to load a module at runtime using the following command:  MODULE LOAD /path/to/mymodule.so  In order to list all loaded modules, use:  MODULE LIST  Finally, you can unload (and later reload if you wish) a module using the\nfollowing command:  MODULE UNLOAD mymodule  Note that  mymodule  above is not the filename without the  .so  suffix, but\ninstead, the name the module used to register itself into the Redis core.\nThe name can be obtained using  MODULE LIST . However it is good practice\nthat the filename of the dynamic library is the same as the name the module\nuses to register itself into the Redis core.", 
            "title": "Loading modules"
        }, 
        {
            "location": "/#the-simplest-module-you-can-write", 
            "text": "In order to show the different parts of a module, here we'll show a very\nsimple module that implements a command that outputs a random number.  #include \"redismodule.h\"\n#include  stdlib.h \n\nint HelloworldRand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    RedisModule_ReplyWithLongLong(ctx,rand());\n    return REDISMODULE_OK;\n}\n\nint RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    if (RedisModule_Init(ctx,\"helloworld\",1,REDISMODULE_APIVER_1)\n        == REDISMODULE_ERR) return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\"helloworld.rand\",\n        HelloworldRand_RedisCommand) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    return REDISMODULE_OK;\n}  The example module has two functions. One implements a command called\nHELLOWORLD.RAND. This function is specific of that module. However the\nother function called  RedisModule_OnLoad()  must be present in each\nRedis module. It is the entry point for the module to be initialized,\nregister its commands, and potentially other private data structures\nit uses.  Note that it is a good idea for modules to call commands with the\nname of the module followed by a dot, and finally the command name,\nlike in the case of  HELLOWORLD.RAND . This way it is less likely to\nhave collisions.  Note that if different modules have colliding commands, they'll not be\nable to work in Redis at the same time, since the function RedisModule_CreateCommand  will fail in one of the modules, so the module\nloading will abort returning an error condition.", 
            "title": "The simplest module you can write"
        }, 
        {
            "location": "/#module-initialization", 
            "text": "The above example shows the usage of the function  RedisModule_Init() .\nIt should be the first function called by the module  OnLoad  function.\nThe following is the function prototype:  int RedisModule_Init(RedisModuleCtx *ctx, const char *modulename,\n                     int module_version, int api_version);  The  Init  function announces the Redis core that the module has a given\nname, its version (that is reported by  MODULE LIST ), and that is willing\nto use a specific version of the API.  If the API version is wrong, the name is already taken, or there are other\nsimilar errors, the function will return  REDISMODULE_ERR , and the module OnLoad  function should return ASAP with an error.  Before the  Init  function is called, no other API function can be called,\notherwise the module will segfault and the Redis instance will crash.  The second function called,  RedisModule_CreateCommand , is used in order\nto register commands into the Redis core. The following is the prototype:  int RedisModule_CreateCommand(RedisModuleCtx *ctx, const char *cmdname,\n                              RedisModuleCmdFunc cmdfunc);  As you can see, most Redis modules API calls all take as first argument\nthe  context  of the module, so that they have a reference to the module\ncalling it, to the command and client executing a given command, and so forth.  To create a new command, the above function needs the context, the command\nname, and the function pointer of the function implementing the command,\nwhich must have the following prototype:  int mycommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc);  The command function arguments are just the context, that will be passed\nto all the other API calls, the command argument vector, and total number\nof arguments, as passed by the user.  As you can see, the arguments are provided as pointers to a specific data\ntype, the  RedisModuleString . This is an opaque data type you have API\nfunctions to access and use, direct access to its fields is never needed.  Zooming into the example command implementation, we can find another call:  int RedisModule_ReplyWithLongLong(RedisModuleCtx *ctx, long long integer);  This function returns an integer to the client that invoked the command,\nexactly like other Redis commands do, like for example  INCR  or  SCARD .", 
            "title": "Module initialization"
        }, 
        {
            "location": "/#setup-and-dependencies-of-a-redis-module", 
            "text": "Redis modules don't depend on Redis or some other library, nor they\nneed to be compiled with a specific  redismodule.h  file. In order\nto create a new module, just copy a recent version of  redismodule.h \nin your source tree, link all the libraries you want, and create\na dynamic library having the  RedisModule_OnLoad()  function symbol\nexported.  The module will be able to load into different versions of Redis.", 
            "title": "Setup and dependencies of a Redis module"
        }, 
        {
            "location": "/#passing-configuration-parameters-to-redis-modules", 
            "text": "When the module is loaded with the  MODULE LOAD  command, or using the loadmodule  directive in the  redis.conf  file, the user is able to pass\nconfiguration parameters to the module by adding arguments after the module\nfile name:  loadmodule mymodule.so foo bar 1234  In the above example the strings  foo ,  bar  and  123  will be passed\nto the module  OnLoad()  function in the  argv  argument as an array\nof RedisModuleString pointers. The number of arguments passed is into  argc .  The way you can access those strings will be explained in the rest of this\ndocument. Normally the module will store the module configuration parameters\nin some  static  global variable that can be accessed module wide, so that\nthe configuration can change the behavior of different commands.", 
            "title": "Passing configuration parameters to Redis modules"
        }, 
        {
            "location": "/#working-with-redismodulestring-objects", 
            "text": "The command argument vector  argv  passed to module commands, and the\nreturn value of other module APIs functions, are of type  RedisModuleString .  Usually you directly pass module strings to other API calls, however sometimes\nyou may need to directly access the string object.  There are a few functions in order to work with string objects:  const char *RedisModule_StringPtrLen(RedisModuleString *string, size_t *len);  The above function accesses a string by returning its pointer and setting its\nlength in  len .\nYou should never write to a string object pointer, as you can see from the const  pointer qualifier.  However, if you want, you can create new string objects using the following\nAPI:  RedisModuleString *RedisModule_CreateString(RedisModuleCtx *ctx, const char *ptr, size_t len);  The string returned by the above command must be freed using a corresponding\ncall to  RedisModule_FreeString() :  void RedisModule_FreeString(RedisModuleString *str);  However if you want to avoid having to free strings, the automatic memory\nmanagement, covered later in this document, can be a good alternative, by\ndoing it for you.  Note that the strings provided via the argument vector  argv  never need\nto be freed. You only need to free new strings you create, or new strings\nreturned by other APIs, where it is specified that the returned string must\nbe freed.", 
            "title": "Working with RedisModuleString objects"
        }, 
        {
            "location": "/#creating-strings-from-numbers-or-parsing-strings-as-numbers", 
            "text": "Creating a new string from an integer is a very common operation, so there\nis a function to do this:  RedisModuleString *mystr = RedisModule_CreateStringFromLongLong(ctx,10);  Similarly in order to parse a string as a number:  long long myval;\nif (RedisModule_StringToLongLong(ctx,argv[1], myval) == REDISMODULE_OK) {\n    /* Do something with 'myval' */\n}", 
            "title": "Creating strings from numbers or parsing strings as numbers"
        }, 
        {
            "location": "/#accessing-redis-keys-from-modules", 
            "text": "Most Redis modules, in order to be useful, have to interact with the Redis\ndata space (this is not always true, for example an ID generator may\nnever touch Redis keys). Redis modules have two different APIs in order to\naccess the Redis data space, one is a low level API that provides very\nfast access and a set of functions to manipulate Redis data structures.\nThe other API is more high level, and allows to call Redis commands and\nfetch the result, similarly to how Lua scripts access Redis.  The high level API is also useful in order to access Redis functionalities\nthat are not available as APIs.  In general modules developers should prefer the low level API, because commands\nimplemented using the low level API run at a speed comparable to the speed\nof native Redis commands. However there are definitely use cases for the\nhigher level API. For example often the bottleneck could be processing the\ndata and not accessing it.  Also note that sometimes using the low level API is not harder compared to\nthe higher level one.", 
            "title": "Accessing Redis keys from modules"
        }, 
        {
            "location": "/#calling-redis-commands", 
            "text": "The high level API to access Redis is the sum of the  RedisModule_Call() \nfunction, together with the functions needed in order to access the\nreply object returned by  Call() .  RedisModule_Call  uses a special calling convention, with a format specifier\nthat is used to specify what kind of objects you are passing as arguments\nto the function.  Redis commands are invoked just using a command name and a list of arguments.\nHowever when calling commands, the arguments may originate from different\nkind of strings: null-terminated C strings, RedisModuleString objects as\nreceived from the  argv  parameter in the command implementation, binary\nsafe C buffers with a pointer and a length, and so forth.  For example if I want to call  INCRBY  using a first argument (the key)\na string received in the argument vector  argv , which is an array\nof RedisModuleString object pointers, and a C string representing the\nnumber \"10\" as second argument (the increment), I'll use the following\nfunction call:  RedisModuleCallReply *reply;\nreply = RedisModule_Call(ctx,\"INCR\",\"sc\",argv[1],\"10\");  The first argument is the context, and the second is always a null terminated\nC string with the command name. The third argument is the format specifier\nwhere each character corresponds to the type of the arguments that will follow.\nIn the above case  \"sc\"  means a RedisModuleString object, and a null\nterminated C string. The other arguments are just the two arguments as\nspecified. In fact  argv[1]  is a RedisModuleString and  \"10\"  is a null\nterminated C string.  This is the full list of format specifiers:   c  -- Null terminated C string pointer.  b  -- C buffer, two arguments needed: C string pointer and  size_t  length.  s  -- RedisModuleString as received in  argv  or by other Redis module APIs returning a RedisModuleString object.  l  -- Long long integer.  v  -- Array of RedisModuleString objects.  !  -- This modifier just tells the function to replicate the command to slaves and AOF. It is ignored from the point of view of arguments parsing.   The function returns a  RedisModuleCallReply  object on success, on\nerror NULL is returned.  NULL is returned when the command name is invalid, the format specifier uses\ncharacters that are not recognized, or when the command is called with the\nwrong number of arguments. In the above cases the  errno  var is set to  EINVAL . NULL is also returned when, in an instance with Cluster enabled, the target\nkeys are about non local hash slots. In this case  errno  is set to  EPERM .", 
            "title": "Calling Redis commands"
        }, 
        {
            "location": "/#working-with-redismodulecallreply-objects", 
            "text": "RedisModuleCall  returns reply objects that can be accessed using the RedisModule_CallReply*  family of functions.  In order to obtain the type or reply (corresponding to one of the data types\nsupported by the Redis protocol), the function  RedisModule_CallReplyType() \nis used:  reply = RedisModule_Call(ctx,\"INCR\",\"sc\",argv[1],\"10\");\nif (RedisModule_CallReplyType(reply) == REDISMODULE_REPLY_INTEGER) {\n    long long myval = RedisModule_CallReplyInteger(reply);\n    /* Do something with myval. */\n}  Valid reply types are:   REDISMODULE_REPLY_STRING  Bulk string or status replies.  REDISMODULE_REPLY_ERROR  Errors.  REDISMODULE_REPLY_INTEGER  Signed 64 bit integers.  REDISMODULE_REPLY_ARRAY  Array of replies.  REDISMODULE_REPLY_NULL  NULL reply.   Strings, errors and arrays have an associated length. For strings and errors\nthe length corresponds to the length of the string. For arrays the length\nis the number of elements. To obtain the reply length the following function\nis used:  size_t reply_len = RedisModule_CallReplyLength(reply);  In order to obtain the value of an integer reply, the following function is used, as already shown in the example above:  long long reply_integer_val = RedisModule_CallReplyInteger(reply);  Called with a reply object of the wrong type, the above function always\nreturns  LLONG_MIN .  Sub elements of array replies are accessed this way:  RedisModuleCallReply *subreply;\nsubreply = RedisModule_CallReplyArrayElement(reply,idx);  The above function returns NULL if you try to access out of range elements.  Strings and errors (which are like strings but with a different type) can\nbe accessed using in the following way, making sure to never write to\nthe resulting pointer (that is returned as as  const  pointer so that\nmisusing must be pretty explicit):  size_t len;\nchar *ptr = RedisModule_CallReplyStringPtr(reply, len);  If the reply type is not a string or an error, NULL is returned.  RedisCallReply objects are not the same as module string objects\n(RedisModuleString types). However sometimes you may need to pass replies\nof type string or integer, to API functions expecting a module string.  When this is the case, you may want to evaluate if using the low level\nAPI could be a simpler way to implement your command, or you can use\nthe following function in order to create a new string object from a\ncall reply of type string, error or integer:  RedisModuleString *mystr = RedisModule_CreateStringFromCallReply(myreply);  If the reply is not of the right type, NULL is returned.\nThe returned string object should be released with  RedisModule_FreeString() \nas usually, or by enabling automatic memory management (see corresponding\nsection).", 
            "title": "Working with RedisModuleCallReply objects."
        }, 
        {
            "location": "/#releasing-call-reply-objects", 
            "text": "Reply objects must be freed using  RedisModule_FreeCallReply . For arrays,\nyou need to free only the top level reply, not the nested replies.\nCurrently the module implementation provides a protection in order to avoid\ncrashing if you free a nested reply object for error, however this feature\nis not guaranteed to be here forever, so should not be considered part\nof the API.  If you use automatic memory management (explained later in this document)\nyou don't need to free replies (but you still could if you wish to release\nmemory ASAP).", 
            "title": "Releasing call reply objects"
        }, 
        {
            "location": "/#returning-values-from-redis-commands", 
            "text": "Like normal Redis commands, new commands implemented via modules must be\nable to return values to the caller. The API exports a set of functions for\nthis goal, in order to return the usual types of the Redis protocol, and\narrays of such types as elemented. Also errors can be returned with any\nerror string and code (the error code is the initial uppercase letters in\nthe error message, like the \"BUSY\" string in the \"BUSY the sever is busy\" error\nmessage).  All the functions to send a reply to the client are called RedisModule_ReplyWith something .  To return an error, use:  RedisModule_ReplyWithError(RedisModuleCtx *ctx, const char *err);  There is a predefined error string for key of wrong type errors:  REDISMODULE_ERRORMSG_WRONGTYPE  Example usage:  RedisModule_ReplyWithError(ctx,\"ERR invalid arguments\");  We already saw how to reply with a long long in the examples above:  RedisModule_ReplyWithLongLong(ctx,12345);  To reply with a simple string, that can't contain binary values or newlines,\n(so it's suitable to send small words, like \"OK\") we use:  RedisModule_ReplyWithSimpleString(ctx,\"OK\");  It's possible to reply with \"bulk strings\" that are binary safe, using\ntwo different functions:  int RedisModule_ReplyWithStringBuffer(RedisModuleCtx *ctx, const char *buf, size_t len);\n\nint RedisModule_ReplyWithString(RedisModuleCtx *ctx, RedisModuleString *str);  The first function gets a C pointer and length. The second a RedisMoudleString\nobject. Use one or the other depending on the source type you have at hand.  In order to reply with an array, you just need to use a function to emit the\narray length, followed by as many calls to the above functions as the number\nof elements of the array are:  RedisModule_ReplyWithArray(ctx,2);\nRedisModule_ReplyWithStringBuffer(ctx,\"age\",3);\nRedisModule_ReplyWithLongLong(ctx,22);  To return nested arrays is easy, your nested array element just uses another\ncall to  RedisModule_ReplyWithArray()  followed by the calls to emit the\nsub array elements.", 
            "title": "Returning values from Redis commands"
        }, 
        {
            "location": "/#returning-arrays-with-dynamic-length", 
            "text": "Sometimes it is not possible to know beforehand the number of items of\nan array. As an example, think of a Redis module implementing a FACTOR\ncommand that given a number outputs the prime factors. Instead of\nfactorializing the number, storing the prime factors into an array, and\nlater produce the command reply, a better solution is to start an array\nreply where the length is not known, and set it later. This is accomplished\nwith a special argument to  RedisModule_ReplyWithArray() :  RedisModule_ReplyWithArray(ctx, REDISMODULE_POSTPONED_ARRAY_LEN);  The above call starts an array reply so we can use other  ReplyWith  calls\nin order to produce the array items. Finally in order to set the length\nse use the following call:  RedisModule_ReplySetArrayLength(ctx, number_of_items);  In the case of the FACTOR command, this translates to some code similar\nto this:  RedisModule_ReplyWithArray(ctx, REDISMODULE_POSTPONED_ARRAY_LEN);\nnumber_of_factors = 0;\nwhile(still_factors) {\n    RedisModule_ReplyWithLongLong(ctx, some_factor);\n    number_of_factors++;\n}\nRedisModule_ReplySetArrayLength(ctx, number_of_factors);  Another common use case for this feature is iterating over the arrays of\nsome collection and only returning the ones passing some kind of filtering.  It is possible to have multiple nested arrays with postponed reply.\nEach call to  SetArray()  will set the length of the latest corresponding\ncall to  ReplyWithArray() :  RedisModule_ReplyWithArray(ctx, REDISMODULE_POSTPONED_ARRAY_LEN);\n... generate 100 elements ...\nRedisModule_ReplyWithArray(ctx, REDISMODULE_POSTPONED_ARRAY_LEN);\n... generate 10 elements ...\nRedisModule_ReplySetArrayLength(ctx, 10);\nRedisModule_ReplySetArrayLength(ctx, 100);  This creates a 100 items array having as last element a 10 items array.", 
            "title": "Returning arrays with dynamic length"
        }, 
        {
            "location": "/#arity-and-type-checks", 
            "text": "Often commands need to check that the number of arguments and type of the key\nis correct. In order to report a wrong arity, there is a specific function\ncalled  RedisModule_WrongArity() . The usage is trivial:  if (argc != 2) return RedisModule_WrongArity(ctx);  Checking for the wrong type involves opening the key and checking the type:  RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],\n    REDISMODULE_READ|REDISMODULE_WRITE);\n\nint keytype = RedisModule_KeyType(key);\nif (keytype != REDISMODULE_KEYTYPE_STRING  \n    keytype != REDISMODULE_KEYTYPE_EMPTY)\n{\n    RedisModule_CloseKey(key);\n    return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);\n}  Note that you often want to proceed with a command both if the key\nis of the expected type, or if it's empty.", 
            "title": "Arity and type checks"
        }, 
        {
            "location": "/#low-level-access-to-keys", 
            "text": "Low level access to keys allow to perform operations on value objects associated\nto keys directly, with a speed similar to what Redis uses internally to\nimplement the built-in commands.  Once a key is opened, a key pointer is returned that will be used with all the\nother low level API calls in order to perform operations on the key or its\nassociated value.  Because the API is meant to be very fast, it cannot do too many run-time\nchecks, so the user must be aware of certain rules to follow:   Opening the same key multiple times where at least one instance is opened for writing, is undefined and may lead to crashes.  While a key is open, it should only be accessed via the low level key API. For example opening a key, then calling DEL on the same key using the  RedisModule_Call()  API will result into a crash. However it is safe to open a key, perform some operation with the low level API, closing it, then using other APIs to manage the same key, and later opening it again to do some more work.   In order to open a key the  RedisModule_OpenKey  function is used. It returns\na key pointer, that we'll use with all the next calls to access and modify\nthe value:  RedisModuleKey *key;\nkey = RedisModule_OpenKey(ctx,argv[1],REDISMODULE_READ);  The second argument is the key name, that must be a  RedisModuleString  object.\nThe third argument is the mode:  REDISMODULE_READ  or  REDISMODULE_WRITE .\nIt is possible to use  |  to bitwise OR the two modes to open the key in\nboth modes. Currently a key opened for writing can also be accessed for reading\nbut this is to be considered an implementation detail. The right mode should\nbe used in sane modules.  You can open non exisitng keys for writing, since the keys will be created\nwhen an attempt to write to the key is performed. However when opening keys\njust for reading,  RedisModule_OpenKey  will return NULL if the key does not\nexist.  Once you are done using a key, you can close it with:  RedisModule_CloseKey(key);  Note that if automatic memory management is enabled, you are not forced to\nclose keys. When the module function returns, Redis will take care to close\nall the keys which are still open.", 
            "title": "Low level access to keys"
        }, 
        {
            "location": "/#getting-the-key-type", 
            "text": "In order to obtain the value of a key, use the  RedisModule_KeyType()  function:  int keytype = RedisModule_KeyType(key);  It returns one of the following values:  REDISMODULE_KEYTYPE_EMPTY\nREDISMODULE_KEYTYPE_STRING\nREDISMODULE_KEYTYPE_LIST\nREDISMODULE_KEYTYPE_HASH\nREDISMODULE_KEYTYPE_SET\nREDISMODULE_KEYTYPE_ZSET  The above are just the usual Redis key types, with the addition of an empty\ntype, that signals the key pointer is associated with an empty key that\ndoes not yet exists.", 
            "title": "Getting the key type"
        }, 
        {
            "location": "/#creating-new-keys", 
            "text": "To create a new key, open it for writing and then write to it using one\nof the key writing functions. Example:  RedisModuleKey *key;\nkey = RedisModule_OpenKey(ctx,argv[1],REDISMODULE_READ);\nif (RedisModule_KeyType(key) == REDISMODULE_KEYTYPE_EMPTY) {\n    RedisModule_StringSet(key,argv[2]);\n}", 
            "title": "Creating new keys"
        }, 
        {
            "location": "/#deleting-keys", 
            "text": "Just use:  RedisModule_DeleteKey(key);  The function returns  REDISMODULE_ERR  if the key is not open for writing.\nNote that after a key gets deleted, it is setup in order to be targeted\nby new key commands. For example  RedisModule_KeyType()  will return it is\nan empty key, and writing to it will create a new key, possibly of another\ntype (depending on the API used).", 
            "title": "Deleting keys"
        }, 
        {
            "location": "/#managing-key-expires-ttls", 
            "text": "To control key expires two functions are provided, that are able to set,\nmodify, get, and unset the time to live associated with a key.  One function is used in order to query the current expire of an open key:  mstime_t RedisModule_GetExpire(RedisModuleKey *key);  The function returns the time to live of the key in milliseconds, or REDISMODULE_NO_EXPIRE  as a special value to signal the key has no associated\nexpire or does not exist at all (you can differentiate the two cases checking\nif the key type is  REDISMODULE_KEYTYPE_EMPTY ).  In order to change the expire of a key the following function is used instead:  int RedisModule_SetExpire(RedisModuleKey *key, mstime_t expire);  When called on a non existing key,  REDISMODULE_ERR  is returned, because\nthe function can only associate expires to existing open keys (non existing\nopen keys are only useful in order to create new values with data type\nspecific write operations).  Again the  expire  time is specified in milliseconds. If the key has currently\nno expire, a new expire is set. If the key already have an expire, it is\nreplaced with the new value.  If the key has an expire, and the special value  REDISMODULE_NO_EXPIRE  is\nused as a new expire, the expire is removed, similarly to the Redis PERSIST  command. In case the key was already persistent, no operation is\nperformed.", 
            "title": "Managing key expires (TTLs)"
        }, 
        {
            "location": "/#obtaining-the-length-of-values", 
            "text": "There is a single function in order to retrieve the length of the value\nassociated to an open key. The returned length is value-specific, and is\nthe string length for strings, and the number of elements for the aggregated\ndata types (how many elements there is in a list, set, sorted set, hash).  size_t len = RedisModule_ValueLength(key);  If the key does not exist, 0 is returned by the function:", 
            "title": "Obtaining the length of values"
        }, 
        {
            "location": "/#string-type-api", 
            "text": "Setting a new string value, like the Redis  SET  command does, is performed\nusing:  int RedisModule_StringSet(RedisModuleKey *key, RedisModuleString *str);  The function works exactly like the Redis  SET  command itself, that is, if\nthere is a prior value (of any type) it will be deleted.  Accessing existing string values is performed using DMA (direct memory\naccess) for speed. The API will return a pointer and a length, so that's\npossible to access and, if needed, modify the string directly.  size_t len, j;\nchar *myptr = RedisModule_StringDMA(key, len,REDISMODULE_WRITE);\nfor (j = 0; j   len; j++) myptr[j] = 'A';  In the above example we write directly on the string. Note that if you want\nto write, you must be sure to ask for  WRITE  mode.  DMA pointers are only valid if no other operations are performed with the key\nbefore using the pointer, after the DMA call.  Sometimes when we want to manipulate strings directly, we need to change\ntheir size as well. For this scope, the  RedisModule_StringTruncate  function\nis used. Example:  RedisModule_StringTruncate(mykey,1024);  The function truncates, or enlarges the string as needed, padding it with\nzero bytes if the previos length is smaller than the new length we request.\nIf the string does not exist since  key  is associated to an open empty key,\na string value is created and associated to the key.  Note that every time  StringTruncate()  is called, we need to re-obtain\nthe DMA pointer again, since the old may be invalid.", 
            "title": "String type API"
        }, 
        {
            "location": "/#list-type-api", 
            "text": "It's possible to push and pop values from list values:  int RedisModule_ListPush(RedisModuleKey *key, int where, RedisModuleString *ele);\nRedisModuleString *RedisModule_ListPop(RedisModuleKey *key, int where);  In both the APIs the  where  argument specifies if to push or pop from tail\nor head, using the following macros:  REDISMODULE_LIST_HEAD\nREDISMODULE_LIST_TAIL  Elements returned by  RedisModule_ListPop()  are like strings craeted with RedisModule_CreateString() , they must be released with RedisModule_FreeString()  or by enabling automatic memory management.", 
            "title": "List type API"
        }, 
        {
            "location": "/#set-type-api", 
            "text": "Work in progress.", 
            "title": "Set type API"
        }, 
        {
            "location": "/#sorted-set-type-api", 
            "text": "Documentation missing, please refer to the top comments inside  module.c \nfor the following functions:   RedisModule_ZsetAdd  RedisModule_ZsetIncrby  RedisModule_ZsetScore  RedisModule_ZsetRem   And for the sorted set iterator:   RedisModule_ZsetRangeStop  RedisModule_ZsetFirstInScoreRange  RedisModule_ZsetLastInScoreRange  RedisModule_ZsetFirstInLexRange  RedisModule_ZsetLastInLexRange  RedisModule_ZsetRangeCurrentElement  RedisModule_ZsetRangeNext  RedisModule_ZsetRangePrev  RedisModule_ZsetRangeEndReached", 
            "title": "Sorted set type API"
        }, 
        {
            "location": "/#hash-type-api", 
            "text": "Documentation missing, please refer to the top comments inside  module.c \nfor the following functions:   RedisModule_HashSet  RedisModule_HashGet", 
            "title": "Hash type API"
        }, 
        {
            "location": "/#iterating-aggregated-values", 
            "text": "Work in progress.", 
            "title": "Iterating aggregated values"
        }, 
        {
            "location": "/#replicating-commands", 
            "text": "If you want to use module commands exactly like normal Redis commands, in the\ncontext of replicated Redis instances, or using the AOF file for persistence,\nit is important for module commands to handle their replication in a consistent\nway.  When using the higher level APIs to invoke commands, replication happens\nautomatically if you use the \"!\" modifier in the format string of RedisModule_Call()  as in the following example:  reply = RedisModule_Call(ctx,\"INCR\",\"!sc\",argv[1],\"10\");  As you can see the format specifier is  \"!sc\" . The bang is not parsed as a\nformat specifier, but it internally flags the command as \"must replicate\".  If you use the above programming style, there are no problems.\nHowever sometimes things are more complex than that, and you use the low level\nAPI. In this case, if there are no side effects in the command execution, and\nit consistently always performs the same work, what is possible to do is to\nreplicate the command verbatim as the user executed it. To do that, you just\nneed to call the following function:  RedisModule_ReplicateVerbatim(ctx);  When you use the above API, you should not use any other replication function\nsince they are not guaranteed to mix well.  However this is not the only option. It's also possible to exactly tell\nRedis what commands to replicate as the effect of the command execution, using\nan API similar to  RedisModule_Call()  but that instead of calling the command\nsends it to the AOF / slaves stream. Example:  RedisModule_Replicate(ctx,\"INCRBY\",\"cl\",\"foo\",my_increment);  It's possible to call  RedisModule_Replicate  multiple times, and each\nwill emit a command. All the sequence emitted is wrapped between a MULTI/EXEC  transaction, so that the AOF and replication effects are the\nsame as executing a single command.  Note that  Call()  replication and  Replicate()  replication have a rule,\nin case you want to mix both forms of replication (not necessarily a good\nidea if there are simpler approaches). Commands replicated with  Call() \nare always the first emitted in the final  MULTI/EXEC  block, while all\nthe commands emitted with  Replicate()  will follow.", 
            "title": "Replicating commands"
        }, 
        {
            "location": "/#automatic-memory-management", 
            "text": "Normally when writing programs in the C language, programmers need to manage\nmemory manually. This is why the Redis modules API has functions to release\nstrings, close open keys, free replies, and so forth.  However given that commands are executed in a contained environment and\nwith a set of strict APIs, Redis is able to provide automatic memory management\nto modules, at the cost of some performance (most of the time, a very low\ncost).  When automatic memory management is enabled:   You don't need to close open keys.  You don't need to free replies.  You don't need to free RedisModuleString objects.   However you can still do it, if you want. For example, automatic memory\nmanagement may be active, but inside a loop allocating a lot of strings,\nyou may still want to free strings no longer used.  In order to enable automatic memory management, just call the following\nfunction at the start of the command implementation:  RedisModule_AutoMemory(ctx);  Automatic memory management is usually the way to go, however experienced\nC programmers may not use it in order to gain some speed and memory usage\nbenefit.", 
            "title": "Automatic memory management"
        }, 
        {
            "location": "/#allocating-memory-into-modules", 
            "text": "Normal C programs use  malloc()  and  free()  in order to allocate and\nrelease memory dynamically. While in Redis modules the use of malloc is\nnot technically forbidden, it is a lot better to use the Redis Modules\nspecific functions, that are exact replacements for  malloc ,  free , realloc  and  strdup . These functions are:  void *RedisModule_Alloc(size_t bytes);\nvoid* RedisModule_Realloc(void *ptr, size_t bytes);\nvoid RedisModule_Free(void *ptr);\nvoid RedisModule_Calloc(size_t nmemb, size_t size);\nchar *RedisModule_Strdup(const char *str);  They work exactly like their  libc  equivalent calls, however they use\nthe same allocator Redis uses, and the memory allocated using these\nfunctions is reported by the  INFO  command in the memory section, is\naccounted when enforcing the  maxmemory  policy, and in general is\na first citizen of the Redis executable. On the contrar, the method\nallocated inside modules with libc  malloc()  is transparent to Redis.  Another reason to use the modules functions in order to allocate memory\nis that, when creating native data types inside modules, the RDB loading\nfunctions can return deserialized strings (from the RDB file) directly\nas  RedisModule_Alloc()  allocations, so they can be used directly to\npopulate data structures after loading, instead of having to copy them\nto the data structure.", 
            "title": "Allocating memory into modules"
        }, 
        {
            "location": "/#pool-allocator", 
            "text": "Sometimes in commands implementations, it is required to perform many\nsmall allocations that will be not retained at the end of the command\nexecution, but are just functional to execute the command itself.  This work can be more easily accomplished using the Redis pool allocator:  void *RedisModule_PoolAlloc(RedisModuleCtx *ctx, size_t bytes);  It works similarly to  malloc() , and returns memory aligned to the\nnext power of two of greater or equal to  bytes  (for a maximum alignment\nof 8 bytes). However it allocates memory in blocks, so it the overhead\nof the allocations is small, and more important, the memory allocated\nis automatically released when the command returns.  So in general short living allocations are a good candidates for the pool\nallocator.", 
            "title": "Pool allocator"
        }, 
        {
            "location": "/#writing-commands-compatible-with-redis-cluster", 
            "text": "Documentation missing, please check the following functions inside  module.c :  RedisModule_IsKeysPositionRequest(ctx);\nRedisModule_KeyAtPos(ctx,pos);", 
            "title": "Writing commands compatible with Redis Cluster"
        }, 
        {
            "location": "/API/", 
            "text": "Modules API reference\n\n\nRM_Alloc\n\n\nvoid *RM_Alloc(size_t bytes);\n\n\n\nUse like malloc(). Memory allocated with this function is reported in\nRedis INFO memory, used for keys eviction according to maxmemory settings\nand in general is taken into account as memory allocated by Redis.\nYou should avoid to use malloc().\n\n\nRM_Realloc\n\n\nvoid* RM_Realloc(void *ptr, size_t bytes);\n\n\n\nUse like realloc() for memory obtained with \nRedisModule_Alloc()\n.\n\n\nRM_Free\n\n\nvoid RM_Free(void *ptr);\n\n\n\nUse like free() for memory obtained by \nRedisModule_Alloc()\n and\n\nRedisModule_Realloc()\n. However you should never try to free with\n\nRedisModule_Free()\n memory allocated with malloc() inside your module.\n\n\nRM_Strdup\n\n\nchar *RM_Strdup(const char *str);\n\n\n\nLike strdup() but returns memory allocated with \nRedisModule_Alloc()\n.\n\n\nRM_PoolAlloc\n\n\nvoid *RM_PoolAlloc(RedisModuleCtx *ctx, size_t bytes);\n\n\n\nReturn heap allocated memory that will be freed automatically when the\nmodule callback function returns. Mostly suitable for small allocations\nthat are short living and must be released when the callback returns\nanyway. The returned memory is aligned to the architecture word size\nif at least word size bytes are requested, otherwise it is just\naligned to the next power of two, so for example a 3 bytes request is\n4 bytes aligned while a 2 bytes request is 2 bytes aligned.\n\n\nThere is no realloc style function since when this is needed to use the\npool allocator is not a good idea.\n\n\nThe function returns NULL if \nbytes\n is 0.\n\n\nRM_GetApi\n\n\nint RM_GetApi(const char *funcname, void **targetPtrPtr);\n\n\n\nLookup the requested module API and store the function pointer into the\ntarget pointer. The function returns \nREDISMODULE_ERR\n if there is no such\nnamed API, otherwise \nREDISMODULE_OK\n.\n\n\nThis function is not meant to be used by modules developer, it is only\nused implicitly by including redismodule.h.\n\n\nRM_IsKeysPositionRequest\n\n\nint RM_IsKeysPositionRequest(RedisModuleCtx *ctx);\n\n\n\nReturn non-zero if a module command, that was declared with the\nflag \"getkeys-api\", is called in a special way to get the keys positions\nand not to get executed. Otherwise zero is returned.\n\n\nRM_KeyAtPos\n\n\nvoid RM_KeyAtPos(RedisModuleCtx *ctx, int pos);\n\n\n\nWhen a module command is called in order to obtain the position of\nkeys, since it was flagged as \"getkeys-api\" during the registration,\nthe command implementation checks for this special call using the\n\nRedisModule_IsKeysPositionRequest()\n API and uses this function in\norder to report keys, like in the following example:\n\n\nif (\nRedisModule_IsKeysPositionRequest(ctx))\n {\n     \nRedisModule_KeyAtPos(ctx\n,1);\n     \nRedisModule_KeyAtPos(ctx\n,2);\n }\n\n\nNote: in the example below the get keys API would not be needed since\n keys are at fixed positions. This interface is only used for commands\n with a more complex structure.\n\n\nRM_CreateCommand\n\n\nint RM_CreateCommand(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep);\n\n\n\nRegister a new command in the Redis server, that will be handled by\ncalling the function pointer 'func' using the RedisModule calling\nconvention. The function returns \nREDISMODULE_ERR\n if the specified command\nname is already busy or a set of invalid flags were passed, otherwise\n\nREDISMODULE_OK\n is returned and the new command is registered.\n\n\nThis function must be called during the initialization of the module\ninside the \nRedisModule_OnLoad()\n function. Calling this function outside\nof the initialization function is not defined.\n\n\nThe command function type is the following:\n\n\n int MyCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc);\n\n\n\nAnd is supposed to always return \nREDISMODULE_OK\n.\n\n\nThe set of flags 'strflags' specify the behavior of the command, and should\nbe passed as a C string compoesd of space separated words, like for\nexample \"write deny-oom\". The set of flags are:\n\n\n\n\n\"write\"\n:     The command may modify the data set (it may also read\n                   from it).\n\n\n\"readonly\"\n:  The command returns data from keys but never writes.\n\n\n\"admin\"\n:     The command is an administrative command (may change\n                   replication or perform similar tasks).\n\n\n\"deny-oom\"\n:  The command may use additional memory and should be\n                   denied during out of memory conditions.\n\n\n\"deny-script\"\n:   Don't allow this command in Lua scripts.\n\n\n\"allow-loading\"\n: Allow this command while the server is loading data.\n                       Only commands not interacting with the data set\n                       should be allowed to run in this mode. If not sure\n                       don't use this flag.\n\n\n\"pubsub\"\n:    The command publishes things on Pub/Sub channels.\n\n\n\"random\"\n:    The command may have different outputs even starting\n                   from the same input arguments and key values.\n\n\n\"allow-stale\"\n: The command is allowed to run on slaves that don't\n                     serve stale data. Don't use if you don't know what\n                     this means.\n\n\n\"no-monitor\"\n: Don't propoagate the command on monitor. Use this if\n                    the command has sensible data among the arguments.\n\n\n\"fast\"\n:      The command time complexity is not greater\n                   than O(log(N)) where N is the size of the collection or\n                   anything else representing the normal scalability\n                   issue with the command.\n\n\n\"getkeys-api\"\n: The command implements the interface to return\n                     the arguments that are keys. Used when start/stop/step\n                     is not enough because of the command syntax.\n\n\n\"no-cluster\"\n: The command should not register in Redis Cluster\n                    since is not designed to work with it because, for\n                    example, is unable to report the position of the\n                    keys, programmatically creates key names, or any\n                    other reason.\n\n\n\n\nRM_SetModuleAttribs\n\n\nvoid RM_SetModuleAttribs(RedisModuleCtx *ctx, const char *name, int ver, int apiver);\n\n\n\nCalled by \nRM_Init()\n to setup the \nctx-\nmodule\n structure.\n\n\nThis is an internal function, Redis modules developers don't need\nto use it.\n\n\nRM_AutoMemory\n\n\nvoid RM_AutoMemory(RedisModuleCtx *ctx);\n\n\n\nEnable automatic memory management. See API.md for more information.\n\n\nThe function must be called as the first function of a command implementation\nthat wants to use automatic memory.\n\n\nRM_CreateString\n\n\nRedisModuleString *RM_CreateString(RedisModuleCtx *ctx, const char *ptr, size_t len);\n\n\n\nCreate a new module string object. The returned string must be freed\nwith \nRedisModule_FreeString()\n, unless automatic memory is enabled.\n\n\nThe string is created by copying the \nlen\n bytes starting\nat \nptr\n. No reference is retained to the passed buffer.\n\n\nRM_CreateStringFromLongLong\n\n\nRedisModuleString *RM_CreateStringFromLongLong(RedisModuleCtx *ctx, long long ll);\n\n\n\nLike \nRedisModule_CreatString()\n, but creates a string starting from a long long\ninteger instead of taking a buffer and its length.\n\n\nThe returned string must be released with \nRedisModule_FreeString()\n or by\nenabling automatic memory management.\n\n\nRM_CreateStringFromString\n\n\nRedisModuleString *RM_CreateStringFromString(RedisModuleCtx *ctx, const RedisModuleString *str);\n\n\n\nLike \nRedisModule_CreatString()\n, but creates a string starting from an existing\nRedisModuleString.\n\n\nThe returned string must be released with \nRedisModule_FreeString()\n or by\nenabling automatic memory management.\n\n\nRM_FreeString\n\n\nvoid RM_FreeString(RedisModuleCtx *ctx, RedisModuleString *str);\n\n\n\nFree a module string object obtained with one of the Redis modules API calls\nthat return new string objects.\n\n\nIt is possible to call this function even when automatic memory management\nis enabled. In that case the string will be released ASAP and removed\nfrom the pool of string to release at the end.\n\n\nRM_StringPtrLen\n\n\nconst char *RM_StringPtrLen(RedisModuleString *str, size_t *len);\n\n\n\nGiven a string module object, this function returns the string pointer\nand length of the string. The returned pointer and length should only\nbe used for read only accesses and never modified.\n\n\nRM_StringToLongLong\n\n\nint RM_StringToLongLong(RedisModuleString *str, long long *ll);\n\n\n\nConvert the string into a long long integer, storing it at \n*ll\n.\nReturns \nREDISMODULE_OK\n on success. If the string can't be parsed\nas a valid, strict long long (no spaces before/after), \nREDISMODULE_ERR\n\nis returned.\n\n\nRM_StringToDouble\n\n\nint RM_StringToDouble(RedisModuleString *str, double *d);\n\n\n\nConvert the string into a double, storing it at \n*d\n.\nReturns \nREDISMODULE_OK\n on success or \nREDISMODULE_ERR\n if the string is\nnot a valid string representation of a double value.\n\n\nRM_WrongArity\n\n\nint RM_WrongArity(RedisModuleCtx *ctx);\n\n\n\nSend an error about the number of arguments given to the command,\nciting the command name in the error message.\n\n\nExample:\n\n\nif (argc != 3) return \nRedisModule_WrongArity(ctx)\n;\n\n\nRM_ReplyWithLongLong\n\n\nint RM_ReplyWithLongLong(RedisModuleCtx *ctx, long long ll);\n\n\n\nSend an integer reply to the client, with the specified long long value.\nThe function always returns \nREDISMODULE_OK\n.\n\n\nRM_ReplyWithError\n\n\nint RM_ReplyWithError(RedisModuleCtx *ctx, const char *err);\n\n\n\nReply with the error 'err'.\n\n\nNote that 'err' must contain all the error, including\nthe initial error code. The function only provides the initial \"-\", so\nthe usage is, for example:\n\n\nRM_ReplyWithError(ctx\n,\"ERR Wrong Type\");\n\n\nand not just:\n\n\nRM_ReplyWithError(ctx\n,\"Wrong Type\");\n\n\nThe function always returns \nREDISMODULE_OK\n.\n\n\nRM_ReplyWithSimpleString\n\n\nint RM_ReplyWithSimpleString(RedisModuleCtx *ctx, const char *msg);\n\n\n\nReply with a simple string (+... \\r\\n in RESP protocol). This replies\nare suitable only when sending a small non-binary string with small\noverhead, like \"OK\" or similar replies.\n\n\nThe function always returns \nREDISMODULE_OK\n.\n\n\nRM_ReplyWithArray\n\n\nint RM_ReplyWithArray(RedisModuleCtx *ctx, long len);\n\n\n\nReply with an array type of 'len' elements. However 'len' other calls\nto \nReplyWith*\n style functions must follow in order to emit the elements\nof the array.\n\n\nWhen producing arrays with a number of element that is not known beforehand\nthe function can be called with the special count\n\nREDISMODULE_POSTPONED_ARRAY_LEN\n, and the actual number of elements can be\nlater set with \nRedisModule_ReplySetArrayLength()\n (which will set the\nlatest \"open\" count if there are multiple ones).\n\n\nThe function always returns \nREDISMODULE_OK\n.\n\n\nRM_ReplySetArrayLength\n\n\nvoid RM_ReplySetArrayLength(RedisModuleCtx *ctx, long len);\n\n\n\nWhen \nRedisModule_ReplyWithArray()\n is used with the argument\n\nREDISMODULE_POSTPONED_ARRAY_LEN\n, because we don't know beforehand the number\nof items we are going to output as elements of the array, this function\nwill take care to set the array length.\n\n\nSince it is possible to have multiple array replies pending with unknown\nlength, this function guarantees to always set the latest array length\nthat was created in a postponed way.\n\n\nFor example in order to output an array like [1,[10,20,30]] we\ncould write:\n\n\nRedisModule_ReplyWithArray(ctx\n,\nREDISMODULE_POSTPONED_ARRAY_LEN\n);\n \nRedisModule_ReplyWithLongLong(ctx\n,1);\n \nRedisModule_ReplyWithArray(ctx\n,\nREDISMODULE_POSTPONED_ARRAY_LEN\n);\n \nRedisModule_ReplyWithLongLong(ctx\n,10);\n \nRedisModule_ReplyWithLongLong(ctx\n,20);\n \nRedisModule_ReplyWithLongLong(ctx\n,30);\n \nRedisModule_ReplySetArrayLength(ctx\n,3); // Set len of 10,20,30 array.\n \nRedisModule_ReplySetArrayLength(ctx\n,2); // Set len of top array\n\n\nNote that in the above example there is no reason to postpone the array\nlength, since we produce a fixed number of elements, but in the practice\nthe code may use an interator or other ways of creating the output so\nthat is not easy to calculate in advance the number of elements.\n\n\nRM_ReplyWithStringBuffer\n\n\nint RM_ReplyWithStringBuffer(RedisModuleCtx *ctx, const char *buf, size_t len);\n\n\n\nReply with a bulk string, taking in input a C buffer pointer and length.\n\n\nThe function always returns \nREDISMODULE_OK\n.\n\n\nRM_ReplyWithString\n\n\nint RM_ReplyWithString(RedisModuleCtx *ctx, RedisModuleString *str);\n\n\n\nReply with a bulk string, taking in input a RedisModuleString object.\n\n\nThe function always returns \nREDISMODULE_OK\n.\n\n\nRM_ReplyWithNull\n\n\nint RM_ReplyWithNull(RedisModuleCtx *ctx);\n\n\n\nReply to the client with a NULL. In the RESP protocol a NULL is encoded\nas the string \"$-1\\r\\n\".\n\n\nThe function always returns \nREDISMODULE_OK\n.\n\n\nRM_ReplyWithCallReply\n\n\nint RM_ReplyWithCallReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply);\n\n\n\nReply exactly what a Redis command returned us with \nRedisModule_Call()\n.\nThis function is useful when we use \nRedisModule_Call()\n in order to\nexecute some command, as we want to reply to the client exactly the\nsame reply we obtained by the command.\n\n\nThe function always returns \nREDISMODULE_OK\n.\n\n\nRM_ReplyWithDouble\n\n\nint RM_ReplyWithDouble(RedisModuleCtx *ctx, double d);\n\n\n\nSend a string reply obtained converting the double 'd' into a bulk string.\nThis function is basically equivalent to converting a double into\na string into a C buffer, and then calling the function\n\nRedisModule_ReplyWithStringBuffer()\n with the buffer and length.\n\n\nThe function always returns \nREDISMODULE_OK\n.\n\n\nRM_Replicate\n\n\nint RM_Replicate(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...);\n\n\n\nReplicate the specified command and arguments to slaves and AOF, as effect\nof execution of the calling command implementation.\n\n\nThe replicated commands are always wrapped into the MULTI/EXEC that\ncontains all the commands replicated in a given module command\nexecution. However the commands replicated with \nRedisModule_Call()\n\nare the first items, the ones replicated with \nRedisModule_Replicate()\n\nwill all follow before the EXEC.\n\n\nModules should try to use one interface or the other.\n\n\nThis command follows exactly the same interface of \nRedisModule_Call()\n,\nso a set of format specifiers must be passed, followed by arguments\nmatching the provided format specifiers.\n\n\nPlease refer to \nRedisModule_Call()\n for more information.\n\n\nThe command returns \nREDISMODULE_ERR\n if the format specifiers are invalid\nor the command name does not belong to a known command.\n\n\nRM_ReplicateVerbatim\n\n\nint RM_ReplicateVerbatim(RedisModuleCtx *ctx);\n\n\n\nThis function will replicate the command exactly as it was invoked\nby the client. Note that this function will not wrap the command into\na MULTI/EXEC stanza, so it should not be mixed with other replication\ncommands.\n\n\nBasically this form of replication is useful when you want to propagate\nthe command to the slaves and AOF file exactly as it was called, since\nthe command can just be re-executed to deterministically re-create the\nnew state starting from the old one.\n\n\nThe function always returns \nREDISMODULE_OK\n.\n\n\nRM_GetClientId\n\n\nunsigned long long RM_GetClientId(RedisModuleCtx *ctx);\n\n\n\nReturn the ID of the current client calling the currently active module\ncommand. The returned ID has a few guarantees:\n\n\n\n\nThe ID is different for each different client, so if the same client\n   executes a module command multiple times, it can be recognized as\n   having the same ID, otherwise the ID will be different.\n\n\nThe ID increases monotonically. Clients connecting to the server later\n   are guaranteed to get IDs greater than any past ID previously seen.\n\n\n\n\nValid IDs are from 1 to 2^64-1. If 0 is returned it means there is no way\nto fetch the ID in the context the function was currently called.\n\n\nRM_GetSelectedDb\n\n\nint RM_GetSelectedDb(RedisModuleCtx *ctx);\n\n\n\nReturn the currently selected DB.\n\n\nRM_SelectDb\n\n\nint RM_SelectDb(RedisModuleCtx *ctx, int newid);\n\n\n\nChange the currently selected DB. Returns an error if the id\nis out of range.\n\n\nNote that the client will retain the currently selected DB even after\nthe Redis command implemented by the module calling this function\nreturns.\n\n\nIf the module command wishes to change something in a different DB and\nreturns back to the original one, it should call \nRedisModule_GetSelectedDb()\n\nbefore in order to restore the old DB number before returning.\n\n\nRM_OpenKey\n\n\nvoid *RM_OpenKey(RedisModuleCtx *ctx, robj *keyname, int mode);\n\n\n\nReturn an handle representing a Redis key, so that it is possible\nto call other APIs with the key handle as argument to perform\noperations on the key.\n\n\nThe return value is the handle repesenting the key, that must be\nclosed with \nRM_CloseKey()\n.\n\n\nIf the key does not exist and WRITE mode is requested, the handle\nis still returned, since it is possible to perform operations on\na yet not existing key (that will be created, for example, after\na list push operation). If the mode is just READ instead, and the\nkey does not exist, NULL is returned. However it is still safe to\ncall \nRedisModule_CloseKey()\n and \nRedisModule_KeyType()\n on a NULL\nvalue.\n\n\nRM_CloseKey\n\n\nvoid RM_CloseKey(RedisModuleKey *key);\n\n\n\nClose a key handle.\n\n\nRM_KeyType\n\n\nint RM_KeyType(RedisModuleKey *key);\n\n\n\nReturn the type of the key. If the key pointer is NULL then\n\nREDISMODULE_KEYTYPE_EMPTY\n is returned.\n\n\nRM_ValueLength\n\n\nsize_t RM_ValueLength(RedisModuleKey *key);\n\n\n\nReturn the length of the value associated with the key.\nFor strings this is the length of the string. For all the other types\nis the number of elements (just counting keys for hashes).\n\n\nIf the key pointer is NULL or the key is empty, zero is returned.\n\n\nRM_DeleteKey\n\n\nint RM_DeleteKey(RedisModuleKey *key);\n\n\n\nIf the key is open for writing, remove it, and setup the key to\naccept new writes as an empty key (that will be created on demand).\nOn success \nREDISMODULE_OK\n is returned. If the key is not open for\nwriting \nREDISMODULE_ERR\n is returned.\n\n\nRM_GetExpire\n\n\nmstime_t RM_GetExpire(RedisModuleKey *key);\n\n\n\nReturn the key expire value, as milliseconds of remaining TTL.\nIf no TTL is associated with the key or if the key is empty,\n\nREDISMODULE_NO_EXPIRE\n is returned.\n\n\nRM_SetExpire\n\n\nint RM_SetExpire(RedisModuleKey *key, mstime_t expire);\n\n\n\nSet a new expire for the key. If the special expire\n\nREDISMODULE_NO_EXPIRE\n is set, the expire is cancelled if there was\none (the same as the PERSIST command).\n\n\nNote that the expire must be provided as a positive integer representing\nthe number of milliseconds of TTL the key should have.\n\n\nThe function returns \nREDISMODULE_OK\n on success or \nREDISMODULE_ERR\n if\nthe key was not open for writing or is an empty key.\n\n\nRM_StringSet\n\n\nint RM_StringSet(RedisModuleKey *key, RedisModuleString *str);\n\n\n\nIf the key is open for writing, set the specified string 'str' as the\nvalue of the key, deleting the old value if any.\nOn success \nREDISMODULE_OK\n is returned. If the key is not open for\nwriting or there is an active iterator, \nREDISMODULE_ERR\n is returned.\n\n\nRM_StringDMA\n\n\nchar *RM_StringDMA(RedisModuleKey *key, size_t *len, int mode);\n\n\n\nPrepare the key associated string value for DMA access, and returns\na pointer and size (by reference), that the user can use to read or\nmodify the string in-place accessing it directly via pointer.\n\n\nThe 'mode' is composed by bitwise OR-ing the following flags:\n\n\nREDISMODULE_READ\n -- Read access\n\nREDISMODULE_WRITE\n -- Write access\n\n\nIf the DMA is not requested for writing, the pointer returned should\nonly be accessed in a read-only fashion.\n\n\nOn error (wrong type) NULL is returned.\n\n\nDMA access rules:\n\n\n\n\n\n\nNo other key writing function should be called since the moment\nthe pointer is obtained, for all the time we want to use DMA access\nto read or modify the string.\n\n\n\n\n\n\nEach time \nRM_StringTruncate()\n is called, to continue with the DMA\naccess, \nRM_StringDMA()\n should be called again to re-obtain\na new pointer and length.\n\n\n\n\n\n\nIf the returned pointer is not NULL, but the length is zero, no\nbyte can be touched (the string is empty, or the key itself is empty)\nso a \nRM_StringTruncate()\n call should be used if there is to enlarge\nthe string, and later call StringDMA() again to get the pointer.\n\n\n\n\n\n\nRM_StringTruncate\n\n\nint RM_StringTruncate(RedisModuleKey *key, size_t newlen);\n\n\n\nIf the string is open for writing and is of string type, resize it, padding\nwith zero bytes if the new length is greater than the old one.\n\n\nAfter this call, \nRM_StringDMA()\n must be called again to continue\nDMA access with the new pointer.\n\n\nThe function returns \nREDISMODULE_OK\n on success, and \nREDISMODULE_ERR\n on\nerror, that is, the key is not open for writing, is not a string\nor resizing for more than 512 MB is requested.\n\n\nIf the key is empty, a string key is created with the new string value\nunless the new length value requested is zero.\n\n\nRM_ListPush\n\n\nint RM_ListPush(RedisModuleKey *key, int where, RedisModuleString *ele);\n\n\n\nPush an element into a list, on head or tail depending on 'where' argumnet.\nIf the key pointer is about an empty key opened for writing, the key\nis created. On error (key opened for read-only operations or of the wrong\ntype) \nREDISMODULE_ERR\n is returned, otherwise \nREDISMODULE_OK\n is returned.\n\n\nRM_ListPop\n\n\nRedisModuleString *RM_ListPop(RedisModuleKey *key, int where);\n\n\n\nPop an element from the list, and returns it as a module string object\nthat the user should be free with \nRM_FreeString()\n or by enabling\nautomatic memory. 'where' specifies if the element should be popped from\nhead or tail. The command returns NULL if:\n1) The list is empty.\n2) The key was not open for writing.\n3) The key is not a list.\n\n\nRM_ZsetAddFlagsToCoreFlags\n\n\nint RM_ZsetAddFlagsToCoreFlags(int flags);\n\n\n\nConversion from/to public flags of the Modules API and our private flags,\nso that we have everything decoupled.\n\n\nRM_ZsetAddFlagsFromCoreFlags\n\n\nint RM_ZsetAddFlagsFromCoreFlags(int flags);\n\n\n\nSee previous function comment.\n\n\nRM_ZsetAdd\n\n\nint RM_ZsetAdd(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr);\n\n\n\nAdd a new element into a sorted set, with the specified 'score'.\nIf the element already exists, the score is updated.\n\n\nA new sorted set is created at value if the key is an empty open key\nsetup for writing.\n\n\nAdditional flags can be passed to the function via a pointer, the flags\nare both used to receive input and to communicate state when the function\nreturns. 'flagsptr' can be NULL if no special flags are used.\n\n\nThe input flags are:\n\n\nREDISMODULE_ZADD_XX\n: Element must already exist. Do nothing otherwise.\n\nREDISMODULE_ZADD_NX\n: Element must not exist. Do nothing otherwise.\n\n\nThe output flags are:\n\n\nREDISMODULE_ZADD_ADDED\n: The new element was added to the sorted set.\n\nREDISMODULE_ZADD_UPDATED\n: The score of the element was updated.\n\nREDISMODULE_ZADD_NOP\n: No operation was performed because XX or NX flags.\n\n\nOn success the function returns \nREDISMODULE_OK\n. On the following errors\n\nREDISMODULE_ERR\n is returned:\n\n\n\n\nThe key was not opened for writing.\n\n\nThe key is of the wrong type.\n\n\n'score' double value is not a number (NaN).\n\n\n\n\nRM_ZsetIncrby\n\n\nint RM_ZsetIncrby(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr, double *newscore);\n\n\n\nThis function works exactly like \nRM_ZsetAdd()\n, but instead of setting\na new score, the score of the existing element is incremented, or if the\nelement does not already exist, it is added assuming the old score was\nzero.\n\n\nThe input and output flags, and the return value, have the same exact\nmeaning, with the only difference that this function will return\n\nREDISMODULE_ERR\n even when 'score' is a valid double number, but adding it\nto the existing score resuts into a NaN (not a number) condition.\n\n\nThis function has an additional field 'newscore', if not NULL is filled\nwith the new score of the element after the increment, if no error\nis returned.\n\n\nRM_ZsetRem\n\n\nint RM_ZsetRem(RedisModuleKey *key, RedisModuleString *ele, int *deleted);\n\n\n\nRemove the specified element from the sorted set.\nThe function returns \nREDISMODULE_OK\n on success, and \nREDISMODULE_ERR\n\non one of the following conditions:\n\n\n\n\nThe key was not opened for writing.\n\n\nThe key is of the wrong type.\n\n\n\n\nThe return value does NOT indicate the fact the element was really\nremoved (since it existed) or not, just if the function was executed\nwith success.\n\n\nIn order to know if the element was removed, the additional argument\n'deleted' must be passed, that populates the integer by reference\nsetting it to 1 or 0 depending on the outcome of the operation.\nThe 'deleted' argument can be NULL if the caller is not interested\nto know if the element was really removed.\n\n\nEmpty keys will be handled correctly by doing nothing.\n\n\nRM_ZsetScore\n\n\nint RM_ZsetScore(RedisModuleKey *key, RedisModuleString *ele, double *score);\n\n\n\nOn success retrieve the double score associated at the sorted set element\n'ele' and returns \nREDISMODULE_OK\n. Otherwise \nREDISMODULE_ERR\n is returned\nto signal one of the following conditions:\n\n\n\n\nThere is no such element 'ele' in the sorted set.\n\n\nThe key is not a sorted set.\n\n\nThe key is an open empty key.\n\n\n\n\nRM_ZsetRangeStop\n\n\nvoid RM_ZsetRangeStop(RedisModuleKey *key);\n\n\n\nStop a sorted set iteration.\n\n\nRM_ZsetRangeEndReached\n\n\nint RM_ZsetRangeEndReached(RedisModuleKey *key);\n\n\n\nReturn the \"End of range\" flag value to signal the end of the iteration.\n\n\nRM_ZsetFirstInScoreRange\n\n\nint RM_ZsetFirstInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex);\n\n\n\nSetup a sorted set iterator seeking the first element in the specified\nrange. Returns \nREDISMODULE_OK\n if the iterator was correctly initialized\notherwise \nREDISMODULE_ERR\n is returned in the following conditions:\n\n\n\n\nThe value stored at key is not a sorted set or the key is empty.\n\n\n\n\nThe range is specified according to the two double values 'min' and 'max'.\nBoth can be infinite using the following two macros:\n\n\nREDISMODULE_POSITIVE_INFINITE\n for positive infinite value\n\nREDISMODULE_NEGATIVE_INFINITE\n for negative infinite value\n\n\n'minex' and 'maxex' parameters, if true, respectively setup a range\nwhere the min and max value are exclusive (not included) instead of\ninclusive.\n\n\nRM_ZsetLastInScoreRange\n\n\nint RM_ZsetLastInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex);\n\n\n\nExactly like \nRedisModule_ZsetFirstInScoreRange()\n but the last element of\nthe range is selected for the start of the iteration instead.\n\n\nRM_ZsetFirstInLexRange\n\n\nint RM_ZsetFirstInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max);\n\n\n\nSetup a sorted set iterator seeking the first element in the specified\nlexicographical range. Returns \nREDISMODULE_OK\n if the iterator was correctly\ninitialized otherwise \nREDISMODULE_ERR\n is returned in the\nfollowing conditions:\n\n\n\n\nThe value stored at key is not a sorted set or the key is empty.\n\n\nThe lexicographical range 'min' and 'max' format is invalid.\n\n\n\n\n'min' and 'max' should be provided as two RedisModuleString objects\nin the same format as the parameters passed to the ZRANGEBYLEX command.\nThe function does not take ownership of the objects, so they can be released\nASAP after the iterator is setup.\n\n\nRM_ZsetLastInLexRange\n\n\nint RM_ZsetLastInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max);\n\n\n\nExactly like \nRedisModule_ZsetFirstInLexRange()\n but the last element of\nthe range is selected for the start of the iteration instead.\n\n\nRM_ZsetRangeCurrentElement\n\n\nRedisModuleString *RM_ZsetRangeCurrentElement(RedisModuleKey *key, double *score);\n\n\n\nReturn the current sorted set element of an active sorted set iterator\nor NULL if the range specified in the iterator does not include any\nelement.\n\n\nRM_ZsetRangeNext\n\n\nint RM_ZsetRangeNext(RedisModuleKey *key);\n\n\n\nGo to the next element of the sorted set iterator. Returns 1 if there was\na next element, 0 if we are already at the latest element or the range\ndoes not include any item at all.\n\n\nRM_ZsetRangePrev\n\n\nint RM_ZsetRangePrev(RedisModuleKey *key);\n\n\n\nGo to the previous element of the sorted set iterator. Returns 1 if there was\na previous element, 0 if we are already at the first element or the range\ndoes not include any item at all.\n\n\nRM_HashSet\n\n\nint RM_HashSet(RedisModuleKey *key, int flags, ...);\n\n\n\nSet the field of the specified hash field to the specified value.\nIf the key is an empty key open for writing, it is created with an empty\nhash value, in order to set the specified field.\n\n\nThe function is variadic and the user must specify pairs of field\nnames and values, both as RedisModuleString pointers (unless the\nCFIELD option is set, see later).\n\n\nExample to set the hash argv[1] to the value argv[2]:\n\n\nRedisModule_HashSet(key\n,\nREDISMODULE_HASH_NONE\n,argv[1],argv[2],NULL);\n\n\nThe function can also be used in order to delete fields (if they exist)\nby setting them to the specified value of \nREDISMODULE_HASH_DELETE\n:\n\n\nRedisModule_HashSet(key\n,\nREDISMODULE_HASH_NONE\n,argv[1],\n                     \nREDISMODULE_HASH_DELETE\n,NULL);\n\n\nThe behavior of the command changes with the specified flags, that can be\nset to \nREDISMODULE_HASH_NONE\n if no special behavior is needed.\n\n\nREDISMODULE_HASH_NX\n: The operation is performed only if the field was not\n                    already existing in the hash.\n\nREDISMODULE_HASH_XX\n: The operation is performed only if the field was\n                    already existing, so that a new value could be\n                    associated to an existing filed, but no new fields\n                    are created.\n\nREDISMODULE_HASH_CFIELDS\n: The field names passed are null terminated C\n                         strings instead of RedisModuleString objects.\n\n\nUnless NX is specified, the command overwrites the old field value with\nthe new one.\n\n\nWhen using \nREDISMODULE_HASH_CFIELDS\n, field names are reported using\nnormal C strings, so for example to delete the field \"foo\" the following\ncode can be used:\n\n\nRedisModule_HashSet(key\n,\nREDISMODULE_HASH_CFIELDS\n,\"foo\",\n                     \nREDISMODULE_HASH_DELETE\n,NULL);\n\n\nReturn value:\n\n\nThe number of fields updated (that may be less than the number of fields\nspecified because of the XX or NX options).\n\n\nIn the following case the return value is always zero:\n\n\n\n\nThe key was not open for writing.\n\n\nThe key was associated with a non Hash value.\n\n\n\n\nRM_HashGet\n\n\nint RM_HashGet(RedisModuleKey *key, int flags, ...);\n\n\n\nGet fields from an hash value. This function is called using a variable\nnumber of arguments, alternating a field name (as a StringRedisModule\npointer) with a pointer to a StringRedisModule pointer, that is set to the\nvalue of the field if the field exist, or NULL if the field did not exist.\nAt the end of the field/value-ptr pairs, NULL must be specified as last\nargument to signal the end of the arguments in the variadic function.\n\n\nThis is an example usage:\n\n\n RedisModuleString *first, *second;\n `RedisModule_HashGet(mykey`,`REDISMODULE_HASH_NONE`,argv[1],\nfirst,\n                 argv[2],\nsecond,NULL);\n\n\n\nAs with \nRedisModule_HashSet()\n the behavior of the command can be specified\npassing flags different than \nREDISMODULE_HASH_NONE\n:\n\n\nREDISMODULE_HASH_CFIELD\n: field names as null terminated C strings.\n\n\nREDISMODULE_HASH_EXISTS\n: instead of setting the value of the field\nexpecting a RedisModuleString pointer to pointer, the function just\nreports if the field esists or not and expects an integer pointer\nas the second element of each pair.\n\n\nExample of \nREDISMODULE_HASH_CFIELD\n:\n\n\n RedisModuleString *username, *hashedpass;\n `RedisModule_HashGet(mykey`,\"username\",\nusername,\"hp\",\nhashedpass, NULL);\n\n\n\nExample of \nREDISMODULE_HASH_EXISTS\n:\n\n\n int exists;\n `RedisModule_HashGet(mykey`,argv[1],\nexists,NULL);\n\n\n\nThe function returns \nREDISMODULE_OK\n on success and \nREDISMODULE_ERR\n if\nthe key is not an hash value.\n\n\nMemory management:\n\n\nThe returned RedisModuleString objects should be released with\n\nRedisModule_FreeString()\n, or by enabling automatic memory management.\n\n\nRM_FreeCallReply_Rec\n\n\nvoid RM_FreeCallReply_Rec(RedisModuleCallReply *reply, int freenested);\n\n\n\nFree a Call reply and all the nested replies it contains if it's an\narray.\n\n\nRM_FreeCallReply\n\n\nvoid RM_FreeCallReply(RedisModuleCallReply *reply);\n\n\n\nWrapper for the recursive free reply function. This is needed in order\nto have the first level function to return on nested replies, but only\nif called by the module API.\n\n\nRM_CallReplyType\n\n\nint RM_CallReplyType(RedisModuleCallReply *reply);\n\n\n\nReturn the reply type.\n\n\nRM_CallReplyLength\n\n\nsize_t RM_CallReplyLength(RedisModuleCallReply *reply);\n\n\n\nReturn the reply type length, where applicable.\n\n\nRM_CallReplyArrayElement\n\n\nRedisModuleCallReply *RM_CallReplyArrayElement(RedisModuleCallReply *reply, size_t idx);\n\n\n\nReturn the 'idx'-th nested call reply element of an array reply, or NULL\nif the reply type is wrong or the index is out of range.\n\n\nRM_CallReplyInteger\n\n\nlong long RM_CallReplyInteger(RedisModuleCallReply *reply);\n\n\n\nReturn the long long of an integer reply.\n\n\nRM_CallReplyStringPtr\n\n\nconst char *RM_CallReplyStringPtr(RedisModuleCallReply *reply, size_t *len);\n\n\n\nReturn the pointer and length of a string or error reply.\n\n\nRM_CreateStringFromCallReply\n\n\nRedisModuleString *RM_CreateStringFromCallReply(RedisModuleCallReply *reply);\n\n\n\nReturn a new string object from a call reply of type string, error or\ninteger. Otherwise (wrong reply type) return NULL.\n\n\nRM_Call\n\n\nRedisModuleCallReply *RM_Call(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...);\n\n\n\nExported API to call any Redis command from modules.\nOn success a RedisModuleCallReply object is returned, otherwise\nNULL is returned and errno is set to the following values:\n\n\nEINVAL: command non existing, wrong arity, wrong format specifier.\nEPERM:  operation in Cluster instance with key in non local slot.\n\n\nRM_CallReplyProto\n\n\nconst char *RM_CallReplyProto(RedisModuleCallReply *reply, size_t *len);\n\n\n\nReturn a pointer, and a length, to the protocol returned by the command\nthat returned the reply object.\n\n\nRM_CreateDataType\n\n\nmoduleType *RM_CreateDataType(RedisModuleCtx *ctx, const char *name, int encver, moduleTypeLoadFunc rdb_load, moduleTypeSaveFunc rdb_save, moduleTypeRewriteFunc aof_rewrite, moduleTypeDigestFunc digest, moduleTypeFreeFunc free);\n\n\n\nRegister a new data type exported by the module. The parameters are the\nfollowing. Please for in depth documentation check the modules API\ndocumentation, especially the INTRO.md file.\n\n\n\n\nname\n: A 9 characters data type name that MUST be unique in the Redis\n  Modules ecosystem. Be creative... and there will be no collisions. Use\n  the charset A-Z a-z 9-0, plus the two \"-_\" characters. A good\n  idea is to use, for example \ntypename\n-\nvendor\n. For example\n  \"tree-AntZ\" may mean \"Tree data structure by @antirez\". To use both\n  lower case and upper case letters helps in order to prevent collisions.\n\n\nencver\n: Encoding version, which is, the version of the serialization\n  that a module used in order to persist data. As long as the \"name\"\n  matches, the RDB loading will be dispatched to the type callbacks\n  whatever 'encver' is used, however the module can understand if\n  the encoding it must load are of an older version of the module.\n  For example the module \"tree-AntZ\" initially used encver=0. Later\n  after an upgrade, it started to serialize data in a different format\n  and to register the type with encver=1. However this module may\n  still load old data produced by an older version if the rdb_load\n  callback is able to check the encver value and act accordingly.\n  The encver must be a positive value between 0 and 1023.\n\n\nrdb_load\n: A callback function pointer that loads data from RDB files.\n\n\nrdb_save\n: A callback function pointer that saves data to RDB files.\n\n\naof_rewrite\n: A callback function pointer that rewrites data as commands.\n\n\ndigest\n: A callback function pointer that is used for \nDEBUG DIGEST\n.\n\n\nfree\n: A callback function pointer that can free a type value.\n\n\n\n\nNote: the module name \"AAAAAAAAA\" is reserved and produces an error, it\nhappens to be pretty lame as well.\n\n\nIf there is already a module registering a type with the same name,\nand if the module name or encver is invalid, NULL is returned.\nOtherwise the new type is registered into Redis, and a reference of\ntype RedisModuleType is returned: the caller of the function should store\nthis reference into a gobal variable to make future use of it in the\nmodules type API, since a single module may register multiple types.\nExample code fragment:\n\n\n static RedisModuleType *BalancedTreeType;\n\n int `RedisModule_OnLoad(RedisModuleCtx` *ctx) {\n     // some code here ...\n     BalancedTreeType = `RM_CreateDataType(`...);\n }\n\n\n\nRM_ModuleTypeSetValue\n\n\nint RM_ModuleTypeSetValue(RedisModuleKey *key, moduleType *mt, void *value);\n\n\n\nIf the key is open for writing, set the specified module type object\nas the value of the key, deleting the old value if any.\nOn success \nREDISMODULE_OK\n is returned. If the key is not open for\nwriting or there is an active iterator, \nREDISMODULE_ERR\n is returned.\n\n\nRM_ModuleTypeGetType\n\n\nmoduleType *RM_ModuleTypeGetType(RedisModuleKey *key);\n\n\n\nAssuming \nRedisModule_KeyType()\n returned \nREDISMODULE_KEYTYPE_MODULE\n on\nthe key, returns the moduel type pointer of the value stored at key.\n\n\nIf the key is NULL, is not associated with a module type, or is empty,\nthen NULL is returned instead.\n\n\nRM_ModuleTypeGetValue\n\n\nvoid *RM_ModuleTypeGetValue(RedisModuleKey *key);\n\n\n\nAssuming \nRedisModule_KeyType()\n returned \nREDISMODULE_KEYTYPE_MODULE\n on\nthe key, returns the module type low-level value stored at key, as\nit was set by the user via \nRedisModule_ModuleTypeSet()\n.\n\n\nIf the key is NULL, is not associated with a module type, or is empty,\nthen NULL is returned instead.\n\n\nRM_SaveUnsigned\n\n\nvoid RM_SaveUnsigned(RedisModuleIO *io, uint64_t value);\n\n\n\nSave an unsigned 64 bit value into the RDB file. This function should only\nbe called in the context of the rdb_save method of modules implementing new\ndata types.\n\n\nRM_LoadUnsigned\n\n\nuint64_t RM_LoadUnsigned(RedisModuleIO *io);\n\n\n\nLoad an unsigned 64 bit value from the RDB file. This function should only\nbe called in the context of the rdb_load method of modules implementing\nnew data types.\n\n\nRM_SaveSigned\n\n\nvoid RM_SaveSigned(RedisModuleIO *io, int64_t value);\n\n\n\nLike \nRedisModule_SaveUnsigned()\n but for signed 64 bit values.\n\n\nRM_LoadSigned\n\n\nint64_t RM_LoadSigned(RedisModuleIO *io);\n\n\n\nLike \nRedisModule_LoadUnsigned()\n but for signed 64 bit values.\n\n\nRM_SaveString\n\n\nvoid RM_SaveString(RedisModuleIO *io, RedisModuleString *s);\n\n\n\nIn the context of the rdb_save method of a module type, saves a\nstring into the RDB file taking as input a RedisModuleString.\n\n\nThe string can be later loaded with \nRedisModule_LoadString()\n or\nother Load family functions expecting a serialized string inside\nthe RDB file.\n\n\nRM_SaveStringBuffer\n\n\nvoid RM_SaveStringBuffer(RedisModuleIO *io, const char *str, size_t len);\n\n\n\nLike \nRedisModule_SaveString()\n but takes a raw C pointer and length\nas input.\n\n\nRM_LoadString\n\n\nRedisModuleString *RM_LoadString(RedisModuleIO *io);\n\n\n\nIn the context of the rdb_load method of a module data type, loads a string\nfrom the RDB file, that was previously saved with \nRedisModule_SaveString()\n\nfunctions family.\n\n\nThe returned string is a newly allocated RedisModuleString object, and\nthe user should at some point free it with a call to \nRedisModule_FreeString()\n.\n\n\nIf the data structure does not store strings as RedisModuleString objects,\nthe similar function \nRedisModule_LoadStringBuffer()\n could be used instead.\n\n\nRM_LoadStringBuffer\n\n\nchar *RM_LoadStringBuffer(RedisModuleIO *io, size_t *lenptr);\n\n\n\nLike \nRedisModule_LoadString()\n but returns an heap allocated string that\nwas allocated with \nRedisModule_Alloc()\n, and can be resized or freed with\n\nRedisModule_Realloc()\n or \nRedisModule_Free()\n.\n\n\nThe size of the string is stored at '*lenptr' if not NULL.\nThe returned string is not automatically NULL termianted, it is loaded\nexactly as it was stored inisde the RDB file.\n\n\nRM_SaveDouble\n\n\nvoid RM_SaveDouble(RedisModuleIO *io, double value);\n\n\n\nIn the context of the rdb_save method of a module data type, saves a double\nvalue to the RDB file. The double can be a valid number, a NaN or infinity.\nIt is possible to load back the value with \nRedisModule_LoadDouble()\n.\n\n\nRM_LoadDouble\n\n\ndouble RM_LoadDouble(RedisModuleIO *io);\n\n\n\nIn the context of the rdb_save method of a module data type, loads back the\ndouble value saved by \nRedisModule_SaveDouble()\n.\n\n\nRM_EmitAOF\n\n\nvoid RM_EmitAOF(RedisModuleIO *io, const char *cmdname, const char *fmt, ...);\n\n\n\nEmits a command into the AOF during the AOF rewriting process. This function\nis only called in the context of the aof_rewrite method of data types exported\nby a module. The command works exactly like \nRedisModule_Call()\n in the way\nthe parameters are passed, but it does not return anything as the error\nhandling is performed by Redis itself.\n\n\nRM_Log\n\n\nvoid RM_Log(RedisModuleCtx *ctx, const char *levelstr, const char *fmt, ...);\n\n\n\nProduces a log message to the standard Redis log, the format accepts\nprintf-alike specifiers, while level is a string describing the log\nlevel to use when emitting the log, and must be one of the following:\n\n\n\n\n\"debug\"\n\n\n\"verbose\"\n\n\n\"notice\"\n\n\n\"warning\"\n\n\n\n\nIf the specified log level is invalid, verbose is used by default.\nThere is a fixed limit to the length of the log line this function is able\nto emit, this limti is not specified but is guaranteed to be more than\na few lines of text.", 
            "title": "API"
        }, 
        {
            "location": "/API/#modules-api-reference", 
            "text": "", 
            "title": "Modules API reference"
        }, 
        {
            "location": "/API/#rm_alloc", 
            "text": "void *RM_Alloc(size_t bytes);  Use like malloc(). Memory allocated with this function is reported in\nRedis INFO memory, used for keys eviction according to maxmemory settings\nand in general is taken into account as memory allocated by Redis.\nYou should avoid to use malloc().", 
            "title": "RM_Alloc"
        }, 
        {
            "location": "/API/#rm_realloc", 
            "text": "void* RM_Realloc(void *ptr, size_t bytes);  Use like realloc() for memory obtained with  RedisModule_Alloc() .", 
            "title": "RM_Realloc"
        }, 
        {
            "location": "/API/#rm_free", 
            "text": "void RM_Free(void *ptr);  Use like free() for memory obtained by  RedisModule_Alloc()  and RedisModule_Realloc() . However you should never try to free with RedisModule_Free()  memory allocated with malloc() inside your module.", 
            "title": "RM_Free"
        }, 
        {
            "location": "/API/#rm_strdup", 
            "text": "char *RM_Strdup(const char *str);  Like strdup() but returns memory allocated with  RedisModule_Alloc() .", 
            "title": "RM_Strdup"
        }, 
        {
            "location": "/API/#rm_poolalloc", 
            "text": "void *RM_PoolAlloc(RedisModuleCtx *ctx, size_t bytes);  Return heap allocated memory that will be freed automatically when the\nmodule callback function returns. Mostly suitable for small allocations\nthat are short living and must be released when the callback returns\nanyway. The returned memory is aligned to the architecture word size\nif at least word size bytes are requested, otherwise it is just\naligned to the next power of two, so for example a 3 bytes request is\n4 bytes aligned while a 2 bytes request is 2 bytes aligned.  There is no realloc style function since when this is needed to use the\npool allocator is not a good idea.  The function returns NULL if  bytes  is 0.", 
            "title": "RM_PoolAlloc"
        }, 
        {
            "location": "/API/#rm_getapi", 
            "text": "int RM_GetApi(const char *funcname, void **targetPtrPtr);  Lookup the requested module API and store the function pointer into the\ntarget pointer. The function returns  REDISMODULE_ERR  if there is no such\nnamed API, otherwise  REDISMODULE_OK .  This function is not meant to be used by modules developer, it is only\nused implicitly by including redismodule.h.", 
            "title": "RM_GetApi"
        }, 
        {
            "location": "/API/#rm_iskeyspositionrequest", 
            "text": "int RM_IsKeysPositionRequest(RedisModuleCtx *ctx);  Return non-zero if a module command, that was declared with the\nflag \"getkeys-api\", is called in a special way to get the keys positions\nand not to get executed. Otherwise zero is returned.", 
            "title": "RM_IsKeysPositionRequest"
        }, 
        {
            "location": "/API/#rm_keyatpos", 
            "text": "void RM_KeyAtPos(RedisModuleCtx *ctx, int pos);  When a module command is called in order to obtain the position of\nkeys, since it was flagged as \"getkeys-api\" during the registration,\nthe command implementation checks for this special call using the RedisModule_IsKeysPositionRequest()  API and uses this function in\norder to report keys, like in the following example:  if ( RedisModule_IsKeysPositionRequest(ctx))  {\n      RedisModule_KeyAtPos(ctx ,1);\n      RedisModule_KeyAtPos(ctx ,2);\n }  Note: in the example below the get keys API would not be needed since\n keys are at fixed positions. This interface is only used for commands\n with a more complex structure.", 
            "title": "RM_KeyAtPos"
        }, 
        {
            "location": "/API/#rm_createcommand", 
            "text": "int RM_CreateCommand(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep);  Register a new command in the Redis server, that will be handled by\ncalling the function pointer 'func' using the RedisModule calling\nconvention. The function returns  REDISMODULE_ERR  if the specified command\nname is already busy or a set of invalid flags were passed, otherwise REDISMODULE_OK  is returned and the new command is registered.  This function must be called during the initialization of the module\ninside the  RedisModule_OnLoad()  function. Calling this function outside\nof the initialization function is not defined.  The command function type is the following:   int MyCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc);  And is supposed to always return  REDISMODULE_OK .  The set of flags 'strflags' specify the behavior of the command, and should\nbe passed as a C string compoesd of space separated words, like for\nexample \"write deny-oom\". The set of flags are:   \"write\" :     The command may modify the data set (it may also read\n                   from it).  \"readonly\" :  The command returns data from keys but never writes.  \"admin\" :     The command is an administrative command (may change\n                   replication or perform similar tasks).  \"deny-oom\" :  The command may use additional memory and should be\n                   denied during out of memory conditions.  \"deny-script\" :   Don't allow this command in Lua scripts.  \"allow-loading\" : Allow this command while the server is loading data.\n                       Only commands not interacting with the data set\n                       should be allowed to run in this mode. If not sure\n                       don't use this flag.  \"pubsub\" :    The command publishes things on Pub/Sub channels.  \"random\" :    The command may have different outputs even starting\n                   from the same input arguments and key values.  \"allow-stale\" : The command is allowed to run on slaves that don't\n                     serve stale data. Don't use if you don't know what\n                     this means.  \"no-monitor\" : Don't propoagate the command on monitor. Use this if\n                    the command has sensible data among the arguments.  \"fast\" :      The command time complexity is not greater\n                   than O(log(N)) where N is the size of the collection or\n                   anything else representing the normal scalability\n                   issue with the command.  \"getkeys-api\" : The command implements the interface to return\n                     the arguments that are keys. Used when start/stop/step\n                     is not enough because of the command syntax.  \"no-cluster\" : The command should not register in Redis Cluster\n                    since is not designed to work with it because, for\n                    example, is unable to report the position of the\n                    keys, programmatically creates key names, or any\n                    other reason.", 
            "title": "RM_CreateCommand"
        }, 
        {
            "location": "/API/#rm_setmoduleattribs", 
            "text": "void RM_SetModuleAttribs(RedisModuleCtx *ctx, const char *name, int ver, int apiver);  Called by  RM_Init()  to setup the  ctx- module  structure.  This is an internal function, Redis modules developers don't need\nto use it.", 
            "title": "RM_SetModuleAttribs"
        }, 
        {
            "location": "/API/#rm_automemory", 
            "text": "void RM_AutoMemory(RedisModuleCtx *ctx);  Enable automatic memory management. See API.md for more information.  The function must be called as the first function of a command implementation\nthat wants to use automatic memory.", 
            "title": "RM_AutoMemory"
        }, 
        {
            "location": "/API/#rm_createstring", 
            "text": "RedisModuleString *RM_CreateString(RedisModuleCtx *ctx, const char *ptr, size_t len);  Create a new module string object. The returned string must be freed\nwith  RedisModule_FreeString() , unless automatic memory is enabled.  The string is created by copying the  len  bytes starting\nat  ptr . No reference is retained to the passed buffer.", 
            "title": "RM_CreateString"
        }, 
        {
            "location": "/API/#rm_createstringfromlonglong", 
            "text": "RedisModuleString *RM_CreateStringFromLongLong(RedisModuleCtx *ctx, long long ll);  Like  RedisModule_CreatString() , but creates a string starting from a long long\ninteger instead of taking a buffer and its length.  The returned string must be released with  RedisModule_FreeString()  or by\nenabling automatic memory management.", 
            "title": "RM_CreateStringFromLongLong"
        }, 
        {
            "location": "/API/#rm_createstringfromstring", 
            "text": "RedisModuleString *RM_CreateStringFromString(RedisModuleCtx *ctx, const RedisModuleString *str);  Like  RedisModule_CreatString() , but creates a string starting from an existing\nRedisModuleString.  The returned string must be released with  RedisModule_FreeString()  or by\nenabling automatic memory management.", 
            "title": "RM_CreateStringFromString"
        }, 
        {
            "location": "/API/#rm_freestring", 
            "text": "void RM_FreeString(RedisModuleCtx *ctx, RedisModuleString *str);  Free a module string object obtained with one of the Redis modules API calls\nthat return new string objects.  It is possible to call this function even when automatic memory management\nis enabled. In that case the string will be released ASAP and removed\nfrom the pool of string to release at the end.", 
            "title": "RM_FreeString"
        }, 
        {
            "location": "/API/#rm_stringptrlen", 
            "text": "const char *RM_StringPtrLen(RedisModuleString *str, size_t *len);  Given a string module object, this function returns the string pointer\nand length of the string. The returned pointer and length should only\nbe used for read only accesses and never modified.", 
            "title": "RM_StringPtrLen"
        }, 
        {
            "location": "/API/#rm_stringtolonglong", 
            "text": "int RM_StringToLongLong(RedisModuleString *str, long long *ll);  Convert the string into a long long integer, storing it at  *ll .\nReturns  REDISMODULE_OK  on success. If the string can't be parsed\nas a valid, strict long long (no spaces before/after),  REDISMODULE_ERR \nis returned.", 
            "title": "RM_StringToLongLong"
        }, 
        {
            "location": "/API/#rm_stringtodouble", 
            "text": "int RM_StringToDouble(RedisModuleString *str, double *d);  Convert the string into a double, storing it at  *d .\nReturns  REDISMODULE_OK  on success or  REDISMODULE_ERR  if the string is\nnot a valid string representation of a double value.", 
            "title": "RM_StringToDouble"
        }, 
        {
            "location": "/API/#rm_wrongarity", 
            "text": "int RM_WrongArity(RedisModuleCtx *ctx);  Send an error about the number of arguments given to the command,\nciting the command name in the error message.  Example:  if (argc != 3) return  RedisModule_WrongArity(ctx) ;", 
            "title": "RM_WrongArity"
        }, 
        {
            "location": "/API/#rm_replywithlonglong", 
            "text": "int RM_ReplyWithLongLong(RedisModuleCtx *ctx, long long ll);  Send an integer reply to the client, with the specified long long value.\nThe function always returns  REDISMODULE_OK .", 
            "title": "RM_ReplyWithLongLong"
        }, 
        {
            "location": "/API/#rm_replywitherror", 
            "text": "int RM_ReplyWithError(RedisModuleCtx *ctx, const char *err);  Reply with the error 'err'.  Note that 'err' must contain all the error, including\nthe initial error code. The function only provides the initial \"-\", so\nthe usage is, for example:  RM_ReplyWithError(ctx ,\"ERR Wrong Type\");  and not just:  RM_ReplyWithError(ctx ,\"Wrong Type\");  The function always returns  REDISMODULE_OK .", 
            "title": "RM_ReplyWithError"
        }, 
        {
            "location": "/API/#rm_replywithsimplestring", 
            "text": "int RM_ReplyWithSimpleString(RedisModuleCtx *ctx, const char *msg);  Reply with a simple string (+... \\r\\n in RESP protocol). This replies\nare suitable only when sending a small non-binary string with small\noverhead, like \"OK\" or similar replies.  The function always returns  REDISMODULE_OK .", 
            "title": "RM_ReplyWithSimpleString"
        }, 
        {
            "location": "/API/#rm_replywitharray", 
            "text": "int RM_ReplyWithArray(RedisModuleCtx *ctx, long len);  Reply with an array type of 'len' elements. However 'len' other calls\nto  ReplyWith*  style functions must follow in order to emit the elements\nof the array.  When producing arrays with a number of element that is not known beforehand\nthe function can be called with the special count REDISMODULE_POSTPONED_ARRAY_LEN , and the actual number of elements can be\nlater set with  RedisModule_ReplySetArrayLength()  (which will set the\nlatest \"open\" count if there are multiple ones).  The function always returns  REDISMODULE_OK .", 
            "title": "RM_ReplyWithArray"
        }, 
        {
            "location": "/API/#rm_replysetarraylength", 
            "text": "void RM_ReplySetArrayLength(RedisModuleCtx *ctx, long len);  When  RedisModule_ReplyWithArray()  is used with the argument REDISMODULE_POSTPONED_ARRAY_LEN , because we don't know beforehand the number\nof items we are going to output as elements of the array, this function\nwill take care to set the array length.  Since it is possible to have multiple array replies pending with unknown\nlength, this function guarantees to always set the latest array length\nthat was created in a postponed way.  For example in order to output an array like [1,[10,20,30]] we\ncould write:  RedisModule_ReplyWithArray(ctx , REDISMODULE_POSTPONED_ARRAY_LEN );\n  RedisModule_ReplyWithLongLong(ctx ,1);\n  RedisModule_ReplyWithArray(ctx , REDISMODULE_POSTPONED_ARRAY_LEN );\n  RedisModule_ReplyWithLongLong(ctx ,10);\n  RedisModule_ReplyWithLongLong(ctx ,20);\n  RedisModule_ReplyWithLongLong(ctx ,30);\n  RedisModule_ReplySetArrayLength(ctx ,3); // Set len of 10,20,30 array.\n  RedisModule_ReplySetArrayLength(ctx ,2); // Set len of top array  Note that in the above example there is no reason to postpone the array\nlength, since we produce a fixed number of elements, but in the practice\nthe code may use an interator or other ways of creating the output so\nthat is not easy to calculate in advance the number of elements.", 
            "title": "RM_ReplySetArrayLength"
        }, 
        {
            "location": "/API/#rm_replywithstringbuffer", 
            "text": "int RM_ReplyWithStringBuffer(RedisModuleCtx *ctx, const char *buf, size_t len);  Reply with a bulk string, taking in input a C buffer pointer and length.  The function always returns  REDISMODULE_OK .", 
            "title": "RM_ReplyWithStringBuffer"
        }, 
        {
            "location": "/API/#rm_replywithstring", 
            "text": "int RM_ReplyWithString(RedisModuleCtx *ctx, RedisModuleString *str);  Reply with a bulk string, taking in input a RedisModuleString object.  The function always returns  REDISMODULE_OK .", 
            "title": "RM_ReplyWithString"
        }, 
        {
            "location": "/API/#rm_replywithnull", 
            "text": "int RM_ReplyWithNull(RedisModuleCtx *ctx);  Reply to the client with a NULL. In the RESP protocol a NULL is encoded\nas the string \"$-1\\r\\n\".  The function always returns  REDISMODULE_OK .", 
            "title": "RM_ReplyWithNull"
        }, 
        {
            "location": "/API/#rm_replywithcallreply", 
            "text": "int RM_ReplyWithCallReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply);  Reply exactly what a Redis command returned us with  RedisModule_Call() .\nThis function is useful when we use  RedisModule_Call()  in order to\nexecute some command, as we want to reply to the client exactly the\nsame reply we obtained by the command.  The function always returns  REDISMODULE_OK .", 
            "title": "RM_ReplyWithCallReply"
        }, 
        {
            "location": "/API/#rm_replywithdouble", 
            "text": "int RM_ReplyWithDouble(RedisModuleCtx *ctx, double d);  Send a string reply obtained converting the double 'd' into a bulk string.\nThis function is basically equivalent to converting a double into\na string into a C buffer, and then calling the function RedisModule_ReplyWithStringBuffer()  with the buffer and length.  The function always returns  REDISMODULE_OK .", 
            "title": "RM_ReplyWithDouble"
        }, 
        {
            "location": "/API/#rm_replicate", 
            "text": "int RM_Replicate(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...);  Replicate the specified command and arguments to slaves and AOF, as effect\nof execution of the calling command implementation.  The replicated commands are always wrapped into the MULTI/EXEC that\ncontains all the commands replicated in a given module command\nexecution. However the commands replicated with  RedisModule_Call() \nare the first items, the ones replicated with  RedisModule_Replicate() \nwill all follow before the EXEC.  Modules should try to use one interface or the other.  This command follows exactly the same interface of  RedisModule_Call() ,\nso a set of format specifiers must be passed, followed by arguments\nmatching the provided format specifiers.  Please refer to  RedisModule_Call()  for more information.  The command returns  REDISMODULE_ERR  if the format specifiers are invalid\nor the command name does not belong to a known command.", 
            "title": "RM_Replicate"
        }, 
        {
            "location": "/API/#rm_replicateverbatim", 
            "text": "int RM_ReplicateVerbatim(RedisModuleCtx *ctx);  This function will replicate the command exactly as it was invoked\nby the client. Note that this function will not wrap the command into\na MULTI/EXEC stanza, so it should not be mixed with other replication\ncommands.  Basically this form of replication is useful when you want to propagate\nthe command to the slaves and AOF file exactly as it was called, since\nthe command can just be re-executed to deterministically re-create the\nnew state starting from the old one.  The function always returns  REDISMODULE_OK .", 
            "title": "RM_ReplicateVerbatim"
        }, 
        {
            "location": "/API/#rm_getclientid", 
            "text": "unsigned long long RM_GetClientId(RedisModuleCtx *ctx);  Return the ID of the current client calling the currently active module\ncommand. The returned ID has a few guarantees:   The ID is different for each different client, so if the same client\n   executes a module command multiple times, it can be recognized as\n   having the same ID, otherwise the ID will be different.  The ID increases monotonically. Clients connecting to the server later\n   are guaranteed to get IDs greater than any past ID previously seen.   Valid IDs are from 1 to 2^64-1. If 0 is returned it means there is no way\nto fetch the ID in the context the function was currently called.", 
            "title": "RM_GetClientId"
        }, 
        {
            "location": "/API/#rm_getselecteddb", 
            "text": "int RM_GetSelectedDb(RedisModuleCtx *ctx);  Return the currently selected DB.", 
            "title": "RM_GetSelectedDb"
        }, 
        {
            "location": "/API/#rm_selectdb", 
            "text": "int RM_SelectDb(RedisModuleCtx *ctx, int newid);  Change the currently selected DB. Returns an error if the id\nis out of range.  Note that the client will retain the currently selected DB even after\nthe Redis command implemented by the module calling this function\nreturns.  If the module command wishes to change something in a different DB and\nreturns back to the original one, it should call  RedisModule_GetSelectedDb() \nbefore in order to restore the old DB number before returning.", 
            "title": "RM_SelectDb"
        }, 
        {
            "location": "/API/#rm_openkey", 
            "text": "void *RM_OpenKey(RedisModuleCtx *ctx, robj *keyname, int mode);  Return an handle representing a Redis key, so that it is possible\nto call other APIs with the key handle as argument to perform\noperations on the key.  The return value is the handle repesenting the key, that must be\nclosed with  RM_CloseKey() .  If the key does not exist and WRITE mode is requested, the handle\nis still returned, since it is possible to perform operations on\na yet not existing key (that will be created, for example, after\na list push operation). If the mode is just READ instead, and the\nkey does not exist, NULL is returned. However it is still safe to\ncall  RedisModule_CloseKey()  and  RedisModule_KeyType()  on a NULL\nvalue.", 
            "title": "RM_OpenKey"
        }, 
        {
            "location": "/API/#rm_closekey", 
            "text": "void RM_CloseKey(RedisModuleKey *key);  Close a key handle.", 
            "title": "RM_CloseKey"
        }, 
        {
            "location": "/API/#rm_keytype", 
            "text": "int RM_KeyType(RedisModuleKey *key);  Return the type of the key. If the key pointer is NULL then REDISMODULE_KEYTYPE_EMPTY  is returned.", 
            "title": "RM_KeyType"
        }, 
        {
            "location": "/API/#rm_valuelength", 
            "text": "size_t RM_ValueLength(RedisModuleKey *key);  Return the length of the value associated with the key.\nFor strings this is the length of the string. For all the other types\nis the number of elements (just counting keys for hashes).  If the key pointer is NULL or the key is empty, zero is returned.", 
            "title": "RM_ValueLength"
        }, 
        {
            "location": "/API/#rm_deletekey", 
            "text": "int RM_DeleteKey(RedisModuleKey *key);  If the key is open for writing, remove it, and setup the key to\naccept new writes as an empty key (that will be created on demand).\nOn success  REDISMODULE_OK  is returned. If the key is not open for\nwriting  REDISMODULE_ERR  is returned.", 
            "title": "RM_DeleteKey"
        }, 
        {
            "location": "/API/#rm_getexpire", 
            "text": "mstime_t RM_GetExpire(RedisModuleKey *key);  Return the key expire value, as milliseconds of remaining TTL.\nIf no TTL is associated with the key or if the key is empty, REDISMODULE_NO_EXPIRE  is returned.", 
            "title": "RM_GetExpire"
        }, 
        {
            "location": "/API/#rm_setexpire", 
            "text": "int RM_SetExpire(RedisModuleKey *key, mstime_t expire);  Set a new expire for the key. If the special expire REDISMODULE_NO_EXPIRE  is set, the expire is cancelled if there was\none (the same as the PERSIST command).  Note that the expire must be provided as a positive integer representing\nthe number of milliseconds of TTL the key should have.  The function returns  REDISMODULE_OK  on success or  REDISMODULE_ERR  if\nthe key was not open for writing or is an empty key.", 
            "title": "RM_SetExpire"
        }, 
        {
            "location": "/API/#rm_stringset", 
            "text": "int RM_StringSet(RedisModuleKey *key, RedisModuleString *str);  If the key is open for writing, set the specified string 'str' as the\nvalue of the key, deleting the old value if any.\nOn success  REDISMODULE_OK  is returned. If the key is not open for\nwriting or there is an active iterator,  REDISMODULE_ERR  is returned.", 
            "title": "RM_StringSet"
        }, 
        {
            "location": "/API/#rm_stringdma", 
            "text": "char *RM_StringDMA(RedisModuleKey *key, size_t *len, int mode);  Prepare the key associated string value for DMA access, and returns\na pointer and size (by reference), that the user can use to read or\nmodify the string in-place accessing it directly via pointer.  The 'mode' is composed by bitwise OR-ing the following flags:  REDISMODULE_READ  -- Read access REDISMODULE_WRITE  -- Write access  If the DMA is not requested for writing, the pointer returned should\nonly be accessed in a read-only fashion.  On error (wrong type) NULL is returned.  DMA access rules:    No other key writing function should be called since the moment\nthe pointer is obtained, for all the time we want to use DMA access\nto read or modify the string.    Each time  RM_StringTruncate()  is called, to continue with the DMA\naccess,  RM_StringDMA()  should be called again to re-obtain\na new pointer and length.    If the returned pointer is not NULL, but the length is zero, no\nbyte can be touched (the string is empty, or the key itself is empty)\nso a  RM_StringTruncate()  call should be used if there is to enlarge\nthe string, and later call StringDMA() again to get the pointer.", 
            "title": "RM_StringDMA"
        }, 
        {
            "location": "/API/#rm_stringtruncate", 
            "text": "int RM_StringTruncate(RedisModuleKey *key, size_t newlen);  If the string is open for writing and is of string type, resize it, padding\nwith zero bytes if the new length is greater than the old one.  After this call,  RM_StringDMA()  must be called again to continue\nDMA access with the new pointer.  The function returns  REDISMODULE_OK  on success, and  REDISMODULE_ERR  on\nerror, that is, the key is not open for writing, is not a string\nor resizing for more than 512 MB is requested.  If the key is empty, a string key is created with the new string value\nunless the new length value requested is zero.", 
            "title": "RM_StringTruncate"
        }, 
        {
            "location": "/API/#rm_listpush", 
            "text": "int RM_ListPush(RedisModuleKey *key, int where, RedisModuleString *ele);  Push an element into a list, on head or tail depending on 'where' argumnet.\nIf the key pointer is about an empty key opened for writing, the key\nis created. On error (key opened for read-only operations or of the wrong\ntype)  REDISMODULE_ERR  is returned, otherwise  REDISMODULE_OK  is returned.", 
            "title": "RM_ListPush"
        }, 
        {
            "location": "/API/#rm_listpop", 
            "text": "RedisModuleString *RM_ListPop(RedisModuleKey *key, int where);  Pop an element from the list, and returns it as a module string object\nthat the user should be free with  RM_FreeString()  or by enabling\nautomatic memory. 'where' specifies if the element should be popped from\nhead or tail. The command returns NULL if:\n1) The list is empty.\n2) The key was not open for writing.\n3) The key is not a list.", 
            "title": "RM_ListPop"
        }, 
        {
            "location": "/API/#rm_zsetaddflagstocoreflags", 
            "text": "int RM_ZsetAddFlagsToCoreFlags(int flags);  Conversion from/to public flags of the Modules API and our private flags,\nso that we have everything decoupled.", 
            "title": "RM_ZsetAddFlagsToCoreFlags"
        }, 
        {
            "location": "/API/#rm_zsetaddflagsfromcoreflags", 
            "text": "int RM_ZsetAddFlagsFromCoreFlags(int flags);  See previous function comment.", 
            "title": "RM_ZsetAddFlagsFromCoreFlags"
        }, 
        {
            "location": "/API/#rm_zsetadd", 
            "text": "int RM_ZsetAdd(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr);  Add a new element into a sorted set, with the specified 'score'.\nIf the element already exists, the score is updated.  A new sorted set is created at value if the key is an empty open key\nsetup for writing.  Additional flags can be passed to the function via a pointer, the flags\nare both used to receive input and to communicate state when the function\nreturns. 'flagsptr' can be NULL if no special flags are used.  The input flags are:  REDISMODULE_ZADD_XX : Element must already exist. Do nothing otherwise. REDISMODULE_ZADD_NX : Element must not exist. Do nothing otherwise.  The output flags are:  REDISMODULE_ZADD_ADDED : The new element was added to the sorted set. REDISMODULE_ZADD_UPDATED : The score of the element was updated. REDISMODULE_ZADD_NOP : No operation was performed because XX or NX flags.  On success the function returns  REDISMODULE_OK . On the following errors REDISMODULE_ERR  is returned:   The key was not opened for writing.  The key is of the wrong type.  'score' double value is not a number (NaN).", 
            "title": "RM_ZsetAdd"
        }, 
        {
            "location": "/API/#rm_zsetincrby", 
            "text": "int RM_ZsetIncrby(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr, double *newscore);  This function works exactly like  RM_ZsetAdd() , but instead of setting\na new score, the score of the existing element is incremented, or if the\nelement does not already exist, it is added assuming the old score was\nzero.  The input and output flags, and the return value, have the same exact\nmeaning, with the only difference that this function will return REDISMODULE_ERR  even when 'score' is a valid double number, but adding it\nto the existing score resuts into a NaN (not a number) condition.  This function has an additional field 'newscore', if not NULL is filled\nwith the new score of the element after the increment, if no error\nis returned.", 
            "title": "RM_ZsetIncrby"
        }, 
        {
            "location": "/API/#rm_zsetrem", 
            "text": "int RM_ZsetRem(RedisModuleKey *key, RedisModuleString *ele, int *deleted);  Remove the specified element from the sorted set.\nThe function returns  REDISMODULE_OK  on success, and  REDISMODULE_ERR \non one of the following conditions:   The key was not opened for writing.  The key is of the wrong type.   The return value does NOT indicate the fact the element was really\nremoved (since it existed) or not, just if the function was executed\nwith success.  In order to know if the element was removed, the additional argument\n'deleted' must be passed, that populates the integer by reference\nsetting it to 1 or 0 depending on the outcome of the operation.\nThe 'deleted' argument can be NULL if the caller is not interested\nto know if the element was really removed.  Empty keys will be handled correctly by doing nothing.", 
            "title": "RM_ZsetRem"
        }, 
        {
            "location": "/API/#rm_zsetscore", 
            "text": "int RM_ZsetScore(RedisModuleKey *key, RedisModuleString *ele, double *score);  On success retrieve the double score associated at the sorted set element\n'ele' and returns  REDISMODULE_OK . Otherwise  REDISMODULE_ERR  is returned\nto signal one of the following conditions:   There is no such element 'ele' in the sorted set.  The key is not a sorted set.  The key is an open empty key.", 
            "title": "RM_ZsetScore"
        }, 
        {
            "location": "/API/#rm_zsetrangestop", 
            "text": "void RM_ZsetRangeStop(RedisModuleKey *key);  Stop a sorted set iteration.", 
            "title": "RM_ZsetRangeStop"
        }, 
        {
            "location": "/API/#rm_zsetrangeendreached", 
            "text": "int RM_ZsetRangeEndReached(RedisModuleKey *key);  Return the \"End of range\" flag value to signal the end of the iteration.", 
            "title": "RM_ZsetRangeEndReached"
        }, 
        {
            "location": "/API/#rm_zsetfirstinscorerange", 
            "text": "int RM_ZsetFirstInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex);  Setup a sorted set iterator seeking the first element in the specified\nrange. Returns  REDISMODULE_OK  if the iterator was correctly initialized\notherwise  REDISMODULE_ERR  is returned in the following conditions:   The value stored at key is not a sorted set or the key is empty.   The range is specified according to the two double values 'min' and 'max'.\nBoth can be infinite using the following two macros:  REDISMODULE_POSITIVE_INFINITE  for positive infinite value REDISMODULE_NEGATIVE_INFINITE  for negative infinite value  'minex' and 'maxex' parameters, if true, respectively setup a range\nwhere the min and max value are exclusive (not included) instead of\ninclusive.", 
            "title": "RM_ZsetFirstInScoreRange"
        }, 
        {
            "location": "/API/#rm_zsetlastinscorerange", 
            "text": "int RM_ZsetLastInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex);  Exactly like  RedisModule_ZsetFirstInScoreRange()  but the last element of\nthe range is selected for the start of the iteration instead.", 
            "title": "RM_ZsetLastInScoreRange"
        }, 
        {
            "location": "/API/#rm_zsetfirstinlexrange", 
            "text": "int RM_ZsetFirstInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max);  Setup a sorted set iterator seeking the first element in the specified\nlexicographical range. Returns  REDISMODULE_OK  if the iterator was correctly\ninitialized otherwise  REDISMODULE_ERR  is returned in the\nfollowing conditions:   The value stored at key is not a sorted set or the key is empty.  The lexicographical range 'min' and 'max' format is invalid.   'min' and 'max' should be provided as two RedisModuleString objects\nin the same format as the parameters passed to the ZRANGEBYLEX command.\nThe function does not take ownership of the objects, so they can be released\nASAP after the iterator is setup.", 
            "title": "RM_ZsetFirstInLexRange"
        }, 
        {
            "location": "/API/#rm_zsetlastinlexrange", 
            "text": "int RM_ZsetLastInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max);  Exactly like  RedisModule_ZsetFirstInLexRange()  but the last element of\nthe range is selected for the start of the iteration instead.", 
            "title": "RM_ZsetLastInLexRange"
        }, 
        {
            "location": "/API/#rm_zsetrangecurrentelement", 
            "text": "RedisModuleString *RM_ZsetRangeCurrentElement(RedisModuleKey *key, double *score);  Return the current sorted set element of an active sorted set iterator\nor NULL if the range specified in the iterator does not include any\nelement.", 
            "title": "RM_ZsetRangeCurrentElement"
        }, 
        {
            "location": "/API/#rm_zsetrangenext", 
            "text": "int RM_ZsetRangeNext(RedisModuleKey *key);  Go to the next element of the sorted set iterator. Returns 1 if there was\na next element, 0 if we are already at the latest element or the range\ndoes not include any item at all.", 
            "title": "RM_ZsetRangeNext"
        }, 
        {
            "location": "/API/#rm_zsetrangeprev", 
            "text": "int RM_ZsetRangePrev(RedisModuleKey *key);  Go to the previous element of the sorted set iterator. Returns 1 if there was\na previous element, 0 if we are already at the first element or the range\ndoes not include any item at all.", 
            "title": "RM_ZsetRangePrev"
        }, 
        {
            "location": "/API/#rm_hashset", 
            "text": "int RM_HashSet(RedisModuleKey *key, int flags, ...);  Set the field of the specified hash field to the specified value.\nIf the key is an empty key open for writing, it is created with an empty\nhash value, in order to set the specified field.  The function is variadic and the user must specify pairs of field\nnames and values, both as RedisModuleString pointers (unless the\nCFIELD option is set, see later).  Example to set the hash argv[1] to the value argv[2]:  RedisModule_HashSet(key , REDISMODULE_HASH_NONE ,argv[1],argv[2],NULL);  The function can also be used in order to delete fields (if they exist)\nby setting them to the specified value of  REDISMODULE_HASH_DELETE :  RedisModule_HashSet(key , REDISMODULE_HASH_NONE ,argv[1],\n                      REDISMODULE_HASH_DELETE ,NULL);  The behavior of the command changes with the specified flags, that can be\nset to  REDISMODULE_HASH_NONE  if no special behavior is needed.  REDISMODULE_HASH_NX : The operation is performed only if the field was not\n                    already existing in the hash. REDISMODULE_HASH_XX : The operation is performed only if the field was\n                    already existing, so that a new value could be\n                    associated to an existing filed, but no new fields\n                    are created. REDISMODULE_HASH_CFIELDS : The field names passed are null terminated C\n                         strings instead of RedisModuleString objects.  Unless NX is specified, the command overwrites the old field value with\nthe new one.  When using  REDISMODULE_HASH_CFIELDS , field names are reported using\nnormal C strings, so for example to delete the field \"foo\" the following\ncode can be used:  RedisModule_HashSet(key , REDISMODULE_HASH_CFIELDS ,\"foo\",\n                      REDISMODULE_HASH_DELETE ,NULL);  Return value:  The number of fields updated (that may be less than the number of fields\nspecified because of the XX or NX options).  In the following case the return value is always zero:   The key was not open for writing.  The key was associated with a non Hash value.", 
            "title": "RM_HashSet"
        }, 
        {
            "location": "/API/#rm_hashget", 
            "text": "int RM_HashGet(RedisModuleKey *key, int flags, ...);  Get fields from an hash value. This function is called using a variable\nnumber of arguments, alternating a field name (as a StringRedisModule\npointer) with a pointer to a StringRedisModule pointer, that is set to the\nvalue of the field if the field exist, or NULL if the field did not exist.\nAt the end of the field/value-ptr pairs, NULL must be specified as last\nargument to signal the end of the arguments in the variadic function.  This is an example usage:   RedisModuleString *first, *second;\n `RedisModule_HashGet(mykey`,`REDISMODULE_HASH_NONE`,argv[1], first,\n                 argv[2], second,NULL);  As with  RedisModule_HashSet()  the behavior of the command can be specified\npassing flags different than  REDISMODULE_HASH_NONE :  REDISMODULE_HASH_CFIELD : field names as null terminated C strings.  REDISMODULE_HASH_EXISTS : instead of setting the value of the field\nexpecting a RedisModuleString pointer to pointer, the function just\nreports if the field esists or not and expects an integer pointer\nas the second element of each pair.  Example of  REDISMODULE_HASH_CFIELD :   RedisModuleString *username, *hashedpass;\n `RedisModule_HashGet(mykey`,\"username\", username,\"hp\", hashedpass, NULL);  Example of  REDISMODULE_HASH_EXISTS :   int exists;\n `RedisModule_HashGet(mykey`,argv[1], exists,NULL);  The function returns  REDISMODULE_OK  on success and  REDISMODULE_ERR  if\nthe key is not an hash value.  Memory management:  The returned RedisModuleString objects should be released with RedisModule_FreeString() , or by enabling automatic memory management.", 
            "title": "RM_HashGet"
        }, 
        {
            "location": "/API/#rm_freecallreply_rec", 
            "text": "void RM_FreeCallReply_Rec(RedisModuleCallReply *reply, int freenested);  Free a Call reply and all the nested replies it contains if it's an\narray.", 
            "title": "RM_FreeCallReply_Rec"
        }, 
        {
            "location": "/API/#rm_freecallreply", 
            "text": "void RM_FreeCallReply(RedisModuleCallReply *reply);  Wrapper for the recursive free reply function. This is needed in order\nto have the first level function to return on nested replies, but only\nif called by the module API.", 
            "title": "RM_FreeCallReply"
        }, 
        {
            "location": "/API/#rm_callreplytype", 
            "text": "int RM_CallReplyType(RedisModuleCallReply *reply);  Return the reply type.", 
            "title": "RM_CallReplyType"
        }, 
        {
            "location": "/API/#rm_callreplylength", 
            "text": "size_t RM_CallReplyLength(RedisModuleCallReply *reply);  Return the reply type length, where applicable.", 
            "title": "RM_CallReplyLength"
        }, 
        {
            "location": "/API/#rm_callreplyarrayelement", 
            "text": "RedisModuleCallReply *RM_CallReplyArrayElement(RedisModuleCallReply *reply, size_t idx);  Return the 'idx'-th nested call reply element of an array reply, or NULL\nif the reply type is wrong or the index is out of range.", 
            "title": "RM_CallReplyArrayElement"
        }, 
        {
            "location": "/API/#rm_callreplyinteger", 
            "text": "long long RM_CallReplyInteger(RedisModuleCallReply *reply);  Return the long long of an integer reply.", 
            "title": "RM_CallReplyInteger"
        }, 
        {
            "location": "/API/#rm_callreplystringptr", 
            "text": "const char *RM_CallReplyStringPtr(RedisModuleCallReply *reply, size_t *len);  Return the pointer and length of a string or error reply.", 
            "title": "RM_CallReplyStringPtr"
        }, 
        {
            "location": "/API/#rm_createstringfromcallreply", 
            "text": "RedisModuleString *RM_CreateStringFromCallReply(RedisModuleCallReply *reply);  Return a new string object from a call reply of type string, error or\ninteger. Otherwise (wrong reply type) return NULL.", 
            "title": "RM_CreateStringFromCallReply"
        }, 
        {
            "location": "/API/#rm_call", 
            "text": "RedisModuleCallReply *RM_Call(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...);  Exported API to call any Redis command from modules.\nOn success a RedisModuleCallReply object is returned, otherwise\nNULL is returned and errno is set to the following values:  EINVAL: command non existing, wrong arity, wrong format specifier.\nEPERM:  operation in Cluster instance with key in non local slot.", 
            "title": "RM_Call"
        }, 
        {
            "location": "/API/#rm_callreplyproto", 
            "text": "const char *RM_CallReplyProto(RedisModuleCallReply *reply, size_t *len);  Return a pointer, and a length, to the protocol returned by the command\nthat returned the reply object.", 
            "title": "RM_CallReplyProto"
        }, 
        {
            "location": "/API/#rm_createdatatype", 
            "text": "moduleType *RM_CreateDataType(RedisModuleCtx *ctx, const char *name, int encver, moduleTypeLoadFunc rdb_load, moduleTypeSaveFunc rdb_save, moduleTypeRewriteFunc aof_rewrite, moduleTypeDigestFunc digest, moduleTypeFreeFunc free);  Register a new data type exported by the module. The parameters are the\nfollowing. Please for in depth documentation check the modules API\ndocumentation, especially the INTRO.md file.   name : A 9 characters data type name that MUST be unique in the Redis\n  Modules ecosystem. Be creative... and there will be no collisions. Use\n  the charset A-Z a-z 9-0, plus the two \"-_\" characters. A good\n  idea is to use, for example  typename - vendor . For example\n  \"tree-AntZ\" may mean \"Tree data structure by @antirez\". To use both\n  lower case and upper case letters helps in order to prevent collisions.  encver : Encoding version, which is, the version of the serialization\n  that a module used in order to persist data. As long as the \"name\"\n  matches, the RDB loading will be dispatched to the type callbacks\n  whatever 'encver' is used, however the module can understand if\n  the encoding it must load are of an older version of the module.\n  For example the module \"tree-AntZ\" initially used encver=0. Later\n  after an upgrade, it started to serialize data in a different format\n  and to register the type with encver=1. However this module may\n  still load old data produced by an older version if the rdb_load\n  callback is able to check the encver value and act accordingly.\n  The encver must be a positive value between 0 and 1023.  rdb_load : A callback function pointer that loads data from RDB files.  rdb_save : A callback function pointer that saves data to RDB files.  aof_rewrite : A callback function pointer that rewrites data as commands.  digest : A callback function pointer that is used for  DEBUG DIGEST .  free : A callback function pointer that can free a type value.   Note: the module name \"AAAAAAAAA\" is reserved and produces an error, it\nhappens to be pretty lame as well.  If there is already a module registering a type with the same name,\nand if the module name or encver is invalid, NULL is returned.\nOtherwise the new type is registered into Redis, and a reference of\ntype RedisModuleType is returned: the caller of the function should store\nthis reference into a gobal variable to make future use of it in the\nmodules type API, since a single module may register multiple types.\nExample code fragment:   static RedisModuleType *BalancedTreeType;\n\n int `RedisModule_OnLoad(RedisModuleCtx` *ctx) {\n     // some code here ...\n     BalancedTreeType = `RM_CreateDataType(`...);\n }", 
            "title": "RM_CreateDataType"
        }, 
        {
            "location": "/API/#rm_moduletypesetvalue", 
            "text": "int RM_ModuleTypeSetValue(RedisModuleKey *key, moduleType *mt, void *value);  If the key is open for writing, set the specified module type object\nas the value of the key, deleting the old value if any.\nOn success  REDISMODULE_OK  is returned. If the key is not open for\nwriting or there is an active iterator,  REDISMODULE_ERR  is returned.", 
            "title": "RM_ModuleTypeSetValue"
        }, 
        {
            "location": "/API/#rm_moduletypegettype", 
            "text": "moduleType *RM_ModuleTypeGetType(RedisModuleKey *key);  Assuming  RedisModule_KeyType()  returned  REDISMODULE_KEYTYPE_MODULE  on\nthe key, returns the moduel type pointer of the value stored at key.  If the key is NULL, is not associated with a module type, or is empty,\nthen NULL is returned instead.", 
            "title": "RM_ModuleTypeGetType"
        }, 
        {
            "location": "/API/#rm_moduletypegetvalue", 
            "text": "void *RM_ModuleTypeGetValue(RedisModuleKey *key);  Assuming  RedisModule_KeyType()  returned  REDISMODULE_KEYTYPE_MODULE  on\nthe key, returns the module type low-level value stored at key, as\nit was set by the user via  RedisModule_ModuleTypeSet() .  If the key is NULL, is not associated with a module type, or is empty,\nthen NULL is returned instead.", 
            "title": "RM_ModuleTypeGetValue"
        }, 
        {
            "location": "/API/#rm_saveunsigned", 
            "text": "void RM_SaveUnsigned(RedisModuleIO *io, uint64_t value);  Save an unsigned 64 bit value into the RDB file. This function should only\nbe called in the context of the rdb_save method of modules implementing new\ndata types.", 
            "title": "RM_SaveUnsigned"
        }, 
        {
            "location": "/API/#rm_loadunsigned", 
            "text": "uint64_t RM_LoadUnsigned(RedisModuleIO *io);  Load an unsigned 64 bit value from the RDB file. This function should only\nbe called in the context of the rdb_load method of modules implementing\nnew data types.", 
            "title": "RM_LoadUnsigned"
        }, 
        {
            "location": "/API/#rm_savesigned", 
            "text": "void RM_SaveSigned(RedisModuleIO *io, int64_t value);  Like  RedisModule_SaveUnsigned()  but for signed 64 bit values.", 
            "title": "RM_SaveSigned"
        }, 
        {
            "location": "/API/#rm_loadsigned", 
            "text": "int64_t RM_LoadSigned(RedisModuleIO *io);  Like  RedisModule_LoadUnsigned()  but for signed 64 bit values.", 
            "title": "RM_LoadSigned"
        }, 
        {
            "location": "/API/#rm_savestring", 
            "text": "void RM_SaveString(RedisModuleIO *io, RedisModuleString *s);  In the context of the rdb_save method of a module type, saves a\nstring into the RDB file taking as input a RedisModuleString.  The string can be later loaded with  RedisModule_LoadString()  or\nother Load family functions expecting a serialized string inside\nthe RDB file.", 
            "title": "RM_SaveString"
        }, 
        {
            "location": "/API/#rm_savestringbuffer", 
            "text": "void RM_SaveStringBuffer(RedisModuleIO *io, const char *str, size_t len);  Like  RedisModule_SaveString()  but takes a raw C pointer and length\nas input.", 
            "title": "RM_SaveStringBuffer"
        }, 
        {
            "location": "/API/#rm_loadstring", 
            "text": "RedisModuleString *RM_LoadString(RedisModuleIO *io);  In the context of the rdb_load method of a module data type, loads a string\nfrom the RDB file, that was previously saved with  RedisModule_SaveString() \nfunctions family.  The returned string is a newly allocated RedisModuleString object, and\nthe user should at some point free it with a call to  RedisModule_FreeString() .  If the data structure does not store strings as RedisModuleString objects,\nthe similar function  RedisModule_LoadStringBuffer()  could be used instead.", 
            "title": "RM_LoadString"
        }, 
        {
            "location": "/API/#rm_loadstringbuffer", 
            "text": "char *RM_LoadStringBuffer(RedisModuleIO *io, size_t *lenptr);  Like  RedisModule_LoadString()  but returns an heap allocated string that\nwas allocated with  RedisModule_Alloc() , and can be resized or freed with RedisModule_Realloc()  or  RedisModule_Free() .  The size of the string is stored at '*lenptr' if not NULL.\nThe returned string is not automatically NULL termianted, it is loaded\nexactly as it was stored inisde the RDB file.", 
            "title": "RM_LoadStringBuffer"
        }, 
        {
            "location": "/API/#rm_savedouble", 
            "text": "void RM_SaveDouble(RedisModuleIO *io, double value);  In the context of the rdb_save method of a module data type, saves a double\nvalue to the RDB file. The double can be a valid number, a NaN or infinity.\nIt is possible to load back the value with  RedisModule_LoadDouble() .", 
            "title": "RM_SaveDouble"
        }, 
        {
            "location": "/API/#rm_loaddouble", 
            "text": "double RM_LoadDouble(RedisModuleIO *io);  In the context of the rdb_save method of a module data type, loads back the\ndouble value saved by  RedisModule_SaveDouble() .", 
            "title": "RM_LoadDouble"
        }, 
        {
            "location": "/API/#rm_emitaof", 
            "text": "void RM_EmitAOF(RedisModuleIO *io, const char *cmdname, const char *fmt, ...);  Emits a command into the AOF during the AOF rewriting process. This function\nis only called in the context of the aof_rewrite method of data types exported\nby a module. The command works exactly like  RedisModule_Call()  in the way\nthe parameters are passed, but it does not return anything as the error\nhandling is performed by Redis itself.", 
            "title": "RM_EmitAOF"
        }, 
        {
            "location": "/API/#rm_log", 
            "text": "void RM_Log(RedisModuleCtx *ctx, const char *levelstr, const char *fmt, ...);  Produces a log message to the standard Redis log, the format accepts\nprintf-alike specifiers, while level is a string describing the log\nlevel to use when emitting the log, and must be one of the following:   \"debug\"  \"verbose\"  \"notice\"  \"warning\"   If the specified log level is invalid, verbose is used by default.\nThere is a fixed limit to the length of the log line this function is able\nto emit, this limti is not specified but is guaranteed to be more than\na few lines of text.", 
            "title": "RM_Log"
        }, 
        {
            "location": "/TYPES/", 
            "text": "Native types in Redis modules\n\n\nRedis modules can access Redis built-in data structures both at high level,\nby calling Redis commands, and at low level, by manipulating the data structures\ndirectly.\n\n\nBy using these capabilities in order to build new abstractions on top of existing\nRedis data structures, or by using strings DMA in order to encode modules\ndata structures into Redis strings, it is possible to create modules that\n\nfeel like\n they are exporting new data types. However, for more complex\nproblems, this is not enough, and the implementation of new data structures\ninside the module is needed.\n\n\nWe call the ability of Redis modules to implement new data structures that\nfeel like native Redis ones \nnative types support\n. This document describes\nthe API exported by the Redis modules system in order to create new data\nstructures and handle the serialization in RDB files, the rewriting process\nin AOF, the type reporting via the \nTYPE\n command, and so forth.\n\n\nOverview of native types\n\n\nA module exporting a native type is composed of the following main parts:\n\n\n\n\nThe implementation of some kind of new data structure and of commands operating on the new data structure.\n\n\nA set of callbacks that handle: RDB saving, RDB loading, AOF rewriting, releasing of a value associated with a key, calculation of a value digest (hash) to be used with the \nDEBUG DIGEST\n command.\n\n\nA 9 characters name that is unique to each module native data type.\n\n\nAn encoding version, used to persist into RDB files a module-specific data version, so that a module will be able to load older representations from RDB files.\n\n\n\n\nWhile to handle RDB loading, saving and AOF rewriting may look complex as a first glance, the modules API provide very high level function for handling all this, without requiring the user to handle read/write errors, so in practical terms, writing a new data structure for Redis is a simple task.\n\n\nA \nvery easy\n to understand but complete example of native type implementation\nis available inside the Redis distribution in the \n/modules/hellotype.c\n file.\nThe reader is encouraged to read the documentation by looking at this example\nimplementation to see how things are applied in the practice.\n\n\nRegistering a new data type\n\n\nIn order to register a new native type into the Redis core, the module needs\nto declare a global variable that will hold a reference to the data type.\nThe API to register the data type will return a data type reference that will\nbe stored in the global variable.\n\n\nstatic RedisModuleType *MyType;\n#define MYTYPE_ENCODING_VERSION 0\n\nint RedisModule_OnLoad(RedisModuleCtx *ctx) {\n    MyType = RedisModule_CreateDataType(\"MyType-AZ\", MYTYPE_ENCODING_VERSION,\n        MyTypeRDBLoad, MyTypeRDBSave, MyTypeAOFRewrite, MyTypeDigest,\n        MyTypeFree);\n    if (MyType == NULL) return REDISMODULE_ERR;\n}\n\n\n\nAs you can see from the example above, a single API call is needed in order to\nregister the new type. However a number of function pointers are passed as\narguments. The prototype of \nRedisModule_CreateDataType\n is the following:\n\n\nmoduleType *RedisModule_CreateDataType(RedisModuleCtx *ctx,\n           const char *name, int encver,\n           moduleTypeLoadFunc rdb_load,\n           moduleTypeSaveFunc rdb_save,\n           moduleTypeRewriteFunc aof_rewrite,\n           moduleTypeDigestFunc digest,\n           moduleTypeFreeFunc free);\n\n\n\nThe \nctx\n argument is the context that we receive in the \nOnLoad\n function.\nThe type \nname\n is a 9 character name in the character set that includes\nfrom \nA-Z\n, \na-z\n, \n0-9\n, plus the underscore \n_\n and minus \n-\n characters.\n\n\nNote that \nthis name must be unique\n for each data type in the Redis\necosystem, so be creative, use both lower-case and upper case if it makes\nsense, and try to use the convention of mixing the type name with the name\nof the author of the module, to create a 9 character unique name.\n\n\nFor example if I'm building a \nb-tree\n data structure and my name is \nantirez\n\nI'll call my type \nbtree1-az\n. The name, converted to a 64 bit integer,\nis stored inside the RDB file when saving the type, and will be used when the\nRDB data is loaded in order to resolve what module can load the data. If Redis\nfinds no matching module, the integer is converted back to a name in order to\nprovide some clue to the user about what module is missing in order to load\nthe data.\n\n\nThe type name is also used as a reply for the \nTYPE\n command when called\nwith a key holding the registered type.\n\n\nThe \nencver\n argument is the encoding version used by the module to store data\ninside the RDB file. For example I can start with an encoding version of 0,\nbut later when I release version 2.0 of my module, I can switch encoding to\nsomething better. The new module will register with an encoding version of 1,\nso when it saves new RDB files, the new version will be stored on disk. However\nwhen loading RDB files, the module \nrdb_load\n method will be called even if\nthere is data found for a different encoding version (and the encoding version\nis passed as argument to \nrdb_load\n), so that the module can still load old\nRDB files.\n\n\nThe remaining arguments \nrdb_load\n, \nrdb_save\n, \naof_rewrite\n, \ndigest\n and\n\nfree\n are all callbacks with the following prototypes and uses:\n\n\ntypedef void *(*RedisModuleTypeLoadFunc)(RedisModuleIO *rdb, int encver);\ntypedef void (*RedisModuleTypeSaveFunc)(RedisModuleIO *rdb, void *value);\ntypedef void (*RedisModuleTypeRewriteFunc)(RedisModuleIO *aof, RedisModuleString *key, void *value);\ntypedef void (*RedisModuleTypeDigestFunc)(RedisModuleDigest *digest, void *value);\ntypedef void (*RedisModuleTypeFreeFunc)(void *value);\n\n\n\n\n\nrdb_load\n is called when loading data from the RDB file. It loads data in the same format as \nrdb_save\n produces.\n\n\nrdb_save\n is called when saving data to the RDB file.\n\n\naof_rewrite\n is called when the AOF is being rewritten, and the module needs to tell Redis what is the sequence of commands to recreate the content of a given key.\n\n\ndigest\n is called when \nDEBUG DIGEST\n is executed and a key holding this module type is found. Currently this is not yet implemented so the function ca be left empty.\n\n\nfree\n is called when a key with the module native type is deleted via \nDEL\n or in any other mean, in order to let the module reclaim the memory associated with such a value.\n\n\n\n\nOk, but \nwhy\n modules types require a 9 characters name?\n\n\nOh, I understand you need to understand this, so here is a very specific\nexplanation.\n\n\nWhen Redis persists to RDB files, modules specific data types require to\nbe persisted as well. Now RDB files are sequences of key-value pairs\nlike the following:\n\n\n[1 byte type] [key] [a type specific value]\n\n\n\nThe 1 byte type identifies strings, lists, sets, and so forth. In the case\nof modules data, it is set to a special value of \nmodule data\n, but of\ncourse this is not enough, we need the information needed to link a specific\nvalue with a specific module type that is able to load and handle it.\n\n\nSo when we save a \ntype specific value\n about a module, we prefix it with\na 64 bit integer. 64 bits is large enough to store the informations needed\nin order to lookup the module that can handle that specific type, but is\nshort enough that we can prefix each module value we store inside the RDB\nwithout making the final RDB file too big. At the same time, this solution\nof prefixing the value with a 64 bit \nsignature\n does not require to do\nstrange things like defining in the RDB header a list of modules specific\ntypes. Everything is pretty simple.\n\n\nSo, what you can store in 64 bits in order to identify a given module in\na reliable way? Well if you build a character set of 64 symbols, you can\neasily store 9 characters of 6 bits, and you are left with 10 bits, that\nare used in order to store the \nencoding version\n of the type, so that\nthe same type can evolve in the future and provide a different and more\nefficient or updated serialization format for RDB files.\n\n\nSo the 64 bit prefix stored before each module value is like the following:\n\n\n6|6|6|6|6|6|6|6|6|10\n\n\n\nThe first 9 elements are 6-bits characters, the final 10 bits is the\nencoding version.\n\n\nWhen the RDB file is loaded back, it reads the 64 bit value, masks the final\n10 bits, and searches for a matching module in the modules types cache.\nWhen a matching one is found, the method to load the RDB file value is called\nwith the 10 bits encoding version as argument, so that the module knows\nwhat version of the data layout to load, if it can support multiple versions.\n\n\nNow the interesting thing about all this is that, if instead the module type\ncannot be resolved, since there is no loaded module having this signature,\nwe can convert back the 64 bit value into a 9 characters name, and print\nan error to the user that includes the module type name! So that she or he\nimmediately realizes what's wrong.\n\n\nSetting and getting keys\n\n\nAfter registering our new data type in the \nRedisModule_OnLoad()\n function,\nwe also need to be able to set Redis keys having as value our native type.\n\n\nThis normally happens in the context of commands that write data to a key.\nThe native types API allow to set and get keys to module native data types,\nand to test if a given key is already associated to a value of a specific data\ntype.\n\n\nThe API uses the normal modules \nRedisModule_OpenKey()\n low level key access\ninterface in order to deal with this. This is an eaxmple of setting a\nnative type private data structure to a Redis key:\n\n\nRedisModuleKey *key = RedisModule_OpenKey(ctx,keyname,REDISMODULE_WRITE);\nstruct some_private_struct *data = createMyDataStructure();\nRedisModule_ModuleTypeSetValue(key,MyType,data);\n\n\n\nThe function \nRedisModule_ModuleTypeSetValue()\n is used with a key handle open\nfor writing, and gets three arguments: the key handle, the reference to the\nnative type, as obtained during the type registration, and finally a \nvoid*\n\npointer that contains the private data implementing the module native type.\n\n\nNote that Redis has no clues at all about what your data contains. It will\njust call the callbacks you provided during the method registration in order\nto perform operations on the type.\n\n\nSimilarly we can retrieve the private data from a key using this function:\n\n\nstruct some_private_struct *data;\ndata = RedisModule_ModuleTypeGetValue(key);\n\n\n\nWe can also test for a key to have our native type as value:\n\n\nif (RedisModule_ModuleTypeGetType(key) == MyType) {\n    /* ... do something ... */\n}\n\n\n\nHowever for the calls to do the right thing, we need to check if the key\nis empty, if it contains a value of the right kind, and so forth. So\nthe idiomatic code to implement a command writing to our native type\nis along these lines:\n\n\nRedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],\n    REDISMODULE_READ|REDISMODULE_WRITE);\nint type = RedisModule_KeyType(key);\nif (type != REDISMODULE_KEYTYPE_EMPTY \n\n    RedisModule_ModuleTypeGetType(key) != MyType)\n{\n    return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);\n}\n\n\n\nThen if we successfully verified the key is not of the wrong type, and\nwe are going to write to it, we usually want to create a new data structure if\nthe key is empty, or retrieve the reference to the value associated to the\nkey if there is already one:\n\n\n/* Create an empty value object if the key is currently empty. */\nstruct some_private_struct *data;\nif (type == REDISMODULE_KEYTYPE_EMPTY) {\n    data = createMyDataStructure();\n    RedisModule_ModuleTypeSetValue(key,MyTyke,data);\n} else {\n    data = RedisModule_ModuleTypeGetValue(key);\n}\n/* Do something with 'data'... */\n\n\n\nFree method\n\n\nAs already mentioned, when Redis needs to free a key holding a native type\nvalue, it needs help from the module in order to release the memory. This\nis the reason why we pass a \nfree\n callback during the type registration:\n\n\ntypedef void (*RedisModuleTypeFreeFunc)(void *value);\n\n\n\nA trivial implementation of the free method can be something like this,\nassuming our data structure is composed of a single allocation:\n\n\nvoid MyTypeFreeCallback(void *value) {\n    RedisModule_Free(value);\n}\n\n\n\nHowever a more real world one will call some function that performs a more\ncomplex memory reclaiming, by casting the void pointer to some structure\nand freeing all the resources composing the value.\n\n\nRDB load and save methods\n\n\nThe RDB saving and loading callbacks need to create (and load back) a\nrepresentation of the data type on disk. Redis offers an high level API\nthat can automatically store inside the RDB file the following types:\n\n\n\n\nUnsigned 64 bit integers.\n\n\nSigned 64 bit integers.\n\n\nDoubles.\n\n\nStrings.\n\n\n\n\nIt is up to the module to find a viable representation using the above base\ntypes. However note that while the integer and double values are stored\nand loaded in an architecture and \nendianess\n agnostic way, if you use\nthe raw string saving API to, for example, save a structure on disk, you\nhave to care those details yourself.\n\n\nThis is the list of functions performing RDB saving and loading:\n\n\nvoid RedisModule_SaveUnsigned(RedisModuleIO *io, uint64_t value);\nuint64_t RedisModule_LoadUnsigned(RedisModuleIO *io);\nvoid RedisModule_SaveSigned(RedisModuleIO *io, int64_t value);\nint64_t RedisModule_LoadSigned(RedisModuleIO *io);\nvoid RedisModule_SaveString(RedisModuleIO *io, RedisModuleString *s);\nvoid RedisModule_SaveStringBuffer(RedisModuleIO *io, const char *str, size_t len);\nRedisModuleString *RedisModule_LoadString(RedisModuleIO *io);\nchar *RedisModule_LoadStringBuffer(RedisModuleIO *io, size_t *lenptr);\nvoid RedisModule_SaveDouble(RedisModuleIO *io, double value);\ndouble RedisModule_LoadDouble(RedisModuleIO *io);\n\n\n\nThe functions don't require any error checking from the module, that can\nalways assume calls succeed.\n\n\nAs an example, imagine I've a native type that implements an array of\ndouble values, with the following structure:\n\n\nstruct double_array {\n    size_t count;\n    double *values;\n};\n\n\n\nMy \nrdb_save\n method may look like the following:\n\n\nvoid DoubleArrayRDBSave(RedisModuleIO *io, void *ptr) {\n    struct dobule_array *da = ptr;\n    RedisModule_SaveUnsigned(io,da-\ncount);\n    for (size_t j = 0; j \n da-\ncount; j++)\n        RedisModule_SaveDouble(io,da-\nvalues[j]);\n}\n\n\n\nWhat we did was to store the number of elements followed by each double\nvalue. So when later we'll have to load the structure in the \nrdb_load\n\nmethod we'll do something like this:\n\n\nvoid *DoubleArrayRDBLoad(RedisModuleIO *io, int encver) {\n    if (encver != DOUBLE_ARRAY_ENC_VER) {\n        /* We should actually log an error here, or try to implement\n           the ability to load older versions of our data structure. */\n        return NULL;\n    }\n\n    struct double_array *da;\n    da = RedisModule_Alloc(sizeof(*da));\n    da-\ncount = RedisModule_LoadUnsigned(io);\n    da-\nvalues = RedisModule_Alloc(da-\ncount * sizeof(double));\n    for (size_t j = 0; j \n da-\ncount; j++)\n        da-\nvalues = RedisModule_LoadDouble(io);\n    return da;\n}\n\n\n\nThe load callback just reconstruct back the data structure from the data\nwe stored in the RDB file.\n\n\nNote that while there is no error handling on the API that writes and reads\nfrom disk, still the load callback can return NULL on errors in case what\nit reads does not look correct. Redis will just panic in that case.\n\n\nAOF rewriting\n\n\nvoid RedisModule_EmitAOF(RedisModuleIO *io, const char *cmdname, const char *fmt, ...);\n\n\n\nHandling multiple encodings\n\n\nWORK IN PROGRESS\n\n\n\nAllocating memory\n\n\nModules data types should try to use \nRedisModule_Alloc()\n functions family\nin order to allocate, reallocate and release heap memory used to implement the native data structures (see the other Redis Modules documentation for detailed information).\n\n\nThis is not just useful in order for Redis to be able to account for the memory used by the module, but there are also more advantages:\n\n\n\n\nRedis uses the \njemalloc\n allcator, that often prevents fragmentation problems that could be caused by using the libc allocator.\n\n\nWhen loading strings from the RDB file, the native types API is able to return strings allocated directly with \nRedisModule_Alloc()\n, so that the module can directly link this memory into the data structure representation, avoiding an useless copy of the data.\n\n\n\n\nEven if you are using external libraries implementing your data structures, the\nallocation functions provided by the module API is exactly compatible with\n\nmalloc()\n, \nrealloc()\n, \nfree()\n and \nstrdup()\n, so converting the libraries\nin order to use these functions should be trivial.\n\n\nIn case you have an external library that uses libc \nmalloc()\n, and you want\nto avoid replacing manually all the calls with the Redis Modules API calls,\nan approach could be to use simple macros in order to replace the libc calls\nwith the Redis API calls. Something like this could work:\n\n\n#define malloc RedisModule_Alloc\n#define realloc RedisModule_Realloc\n#define free RedisModule_Free\n#define strdup RedisModule_Strdup\n\n\n\nHowever take in mind that mixing libc calls with Redis API calls will result\ninto troubles and crashes, so if you replace calls using macros, you need to\nmake sure that all the calls are correctly replaced, and that the code with\nthe substituted calls will never, for example, attempt to call\n\nRedisModule_Free()\n with a pointer allocated using libc \nmalloc()\n.", 
            "title": "Types"
        }, 
        {
            "location": "/TYPES/#native-types-in-redis-modules", 
            "text": "Redis modules can access Redis built-in data structures both at high level,\nby calling Redis commands, and at low level, by manipulating the data structures\ndirectly.  By using these capabilities in order to build new abstractions on top of existing\nRedis data structures, or by using strings DMA in order to encode modules\ndata structures into Redis strings, it is possible to create modules that feel like  they are exporting new data types. However, for more complex\nproblems, this is not enough, and the implementation of new data structures\ninside the module is needed.  We call the ability of Redis modules to implement new data structures that\nfeel like native Redis ones  native types support . This document describes\nthe API exported by the Redis modules system in order to create new data\nstructures and handle the serialization in RDB files, the rewriting process\nin AOF, the type reporting via the  TYPE  command, and so forth.", 
            "title": "Native types in Redis modules"
        }, 
        {
            "location": "/TYPES/#overview-of-native-types", 
            "text": "A module exporting a native type is composed of the following main parts:   The implementation of some kind of new data structure and of commands operating on the new data structure.  A set of callbacks that handle: RDB saving, RDB loading, AOF rewriting, releasing of a value associated with a key, calculation of a value digest (hash) to be used with the  DEBUG DIGEST  command.  A 9 characters name that is unique to each module native data type.  An encoding version, used to persist into RDB files a module-specific data version, so that a module will be able to load older representations from RDB files.   While to handle RDB loading, saving and AOF rewriting may look complex as a first glance, the modules API provide very high level function for handling all this, without requiring the user to handle read/write errors, so in practical terms, writing a new data structure for Redis is a simple task.  A  very easy  to understand but complete example of native type implementation\nis available inside the Redis distribution in the  /modules/hellotype.c  file.\nThe reader is encouraged to read the documentation by looking at this example\nimplementation to see how things are applied in the practice.", 
            "title": "Overview of native types"
        }, 
        {
            "location": "/TYPES/#registering-a-new-data-type", 
            "text": "In order to register a new native type into the Redis core, the module needs\nto declare a global variable that will hold a reference to the data type.\nThe API to register the data type will return a data type reference that will\nbe stored in the global variable.  static RedisModuleType *MyType;\n#define MYTYPE_ENCODING_VERSION 0\n\nint RedisModule_OnLoad(RedisModuleCtx *ctx) {\n    MyType = RedisModule_CreateDataType(\"MyType-AZ\", MYTYPE_ENCODING_VERSION,\n        MyTypeRDBLoad, MyTypeRDBSave, MyTypeAOFRewrite, MyTypeDigest,\n        MyTypeFree);\n    if (MyType == NULL) return REDISMODULE_ERR;\n}  As you can see from the example above, a single API call is needed in order to\nregister the new type. However a number of function pointers are passed as\narguments. The prototype of  RedisModule_CreateDataType  is the following:  moduleType *RedisModule_CreateDataType(RedisModuleCtx *ctx,\n           const char *name, int encver,\n           moduleTypeLoadFunc rdb_load,\n           moduleTypeSaveFunc rdb_save,\n           moduleTypeRewriteFunc aof_rewrite,\n           moduleTypeDigestFunc digest,\n           moduleTypeFreeFunc free);  The  ctx  argument is the context that we receive in the  OnLoad  function.\nThe type  name  is a 9 character name in the character set that includes\nfrom  A-Z ,  a-z ,  0-9 , plus the underscore  _  and minus  -  characters.  Note that  this name must be unique  for each data type in the Redis\necosystem, so be creative, use both lower-case and upper case if it makes\nsense, and try to use the convention of mixing the type name with the name\nof the author of the module, to create a 9 character unique name.  For example if I'm building a  b-tree  data structure and my name is  antirez \nI'll call my type  btree1-az . The name, converted to a 64 bit integer,\nis stored inside the RDB file when saving the type, and will be used when the\nRDB data is loaded in order to resolve what module can load the data. If Redis\nfinds no matching module, the integer is converted back to a name in order to\nprovide some clue to the user about what module is missing in order to load\nthe data.  The type name is also used as a reply for the  TYPE  command when called\nwith a key holding the registered type.  The  encver  argument is the encoding version used by the module to store data\ninside the RDB file. For example I can start with an encoding version of 0,\nbut later when I release version 2.0 of my module, I can switch encoding to\nsomething better. The new module will register with an encoding version of 1,\nso when it saves new RDB files, the new version will be stored on disk. However\nwhen loading RDB files, the module  rdb_load  method will be called even if\nthere is data found for a different encoding version (and the encoding version\nis passed as argument to  rdb_load ), so that the module can still load old\nRDB files.  The remaining arguments  rdb_load ,  rdb_save ,  aof_rewrite ,  digest  and free  are all callbacks with the following prototypes and uses:  typedef void *(*RedisModuleTypeLoadFunc)(RedisModuleIO *rdb, int encver);\ntypedef void (*RedisModuleTypeSaveFunc)(RedisModuleIO *rdb, void *value);\ntypedef void (*RedisModuleTypeRewriteFunc)(RedisModuleIO *aof, RedisModuleString *key, void *value);\ntypedef void (*RedisModuleTypeDigestFunc)(RedisModuleDigest *digest, void *value);\ntypedef void (*RedisModuleTypeFreeFunc)(void *value);   rdb_load  is called when loading data from the RDB file. It loads data in the same format as  rdb_save  produces.  rdb_save  is called when saving data to the RDB file.  aof_rewrite  is called when the AOF is being rewritten, and the module needs to tell Redis what is the sequence of commands to recreate the content of a given key.  digest  is called when  DEBUG DIGEST  is executed and a key holding this module type is found. Currently this is not yet implemented so the function ca be left empty.  free  is called when a key with the module native type is deleted via  DEL  or in any other mean, in order to let the module reclaim the memory associated with such a value.", 
            "title": "Registering a new data type"
        }, 
        {
            "location": "/TYPES/#ok-but-why-modules-types-require-a-9-characters-name", 
            "text": "Oh, I understand you need to understand this, so here is a very specific\nexplanation.  When Redis persists to RDB files, modules specific data types require to\nbe persisted as well. Now RDB files are sequences of key-value pairs\nlike the following:  [1 byte type] [key] [a type specific value]  The 1 byte type identifies strings, lists, sets, and so forth. In the case\nof modules data, it is set to a special value of  module data , but of\ncourse this is not enough, we need the information needed to link a specific\nvalue with a specific module type that is able to load and handle it.  So when we save a  type specific value  about a module, we prefix it with\na 64 bit integer. 64 bits is large enough to store the informations needed\nin order to lookup the module that can handle that specific type, but is\nshort enough that we can prefix each module value we store inside the RDB\nwithout making the final RDB file too big. At the same time, this solution\nof prefixing the value with a 64 bit  signature  does not require to do\nstrange things like defining in the RDB header a list of modules specific\ntypes. Everything is pretty simple.  So, what you can store in 64 bits in order to identify a given module in\na reliable way? Well if you build a character set of 64 symbols, you can\neasily store 9 characters of 6 bits, and you are left with 10 bits, that\nare used in order to store the  encoding version  of the type, so that\nthe same type can evolve in the future and provide a different and more\nefficient or updated serialization format for RDB files.  So the 64 bit prefix stored before each module value is like the following:  6|6|6|6|6|6|6|6|6|10  The first 9 elements are 6-bits characters, the final 10 bits is the\nencoding version.  When the RDB file is loaded back, it reads the 64 bit value, masks the final\n10 bits, and searches for a matching module in the modules types cache.\nWhen a matching one is found, the method to load the RDB file value is called\nwith the 10 bits encoding version as argument, so that the module knows\nwhat version of the data layout to load, if it can support multiple versions.  Now the interesting thing about all this is that, if instead the module type\ncannot be resolved, since there is no loaded module having this signature,\nwe can convert back the 64 bit value into a 9 characters name, and print\nan error to the user that includes the module type name! So that she or he\nimmediately realizes what's wrong.", 
            "title": "Ok, but why modules types require a 9 characters name?"
        }, 
        {
            "location": "/TYPES/#setting-and-getting-keys", 
            "text": "After registering our new data type in the  RedisModule_OnLoad()  function,\nwe also need to be able to set Redis keys having as value our native type.  This normally happens in the context of commands that write data to a key.\nThe native types API allow to set and get keys to module native data types,\nand to test if a given key is already associated to a value of a specific data\ntype.  The API uses the normal modules  RedisModule_OpenKey()  low level key access\ninterface in order to deal with this. This is an eaxmple of setting a\nnative type private data structure to a Redis key:  RedisModuleKey *key = RedisModule_OpenKey(ctx,keyname,REDISMODULE_WRITE);\nstruct some_private_struct *data = createMyDataStructure();\nRedisModule_ModuleTypeSetValue(key,MyType,data);  The function  RedisModule_ModuleTypeSetValue()  is used with a key handle open\nfor writing, and gets three arguments: the key handle, the reference to the\nnative type, as obtained during the type registration, and finally a  void* \npointer that contains the private data implementing the module native type.  Note that Redis has no clues at all about what your data contains. It will\njust call the callbacks you provided during the method registration in order\nto perform operations on the type.  Similarly we can retrieve the private data from a key using this function:  struct some_private_struct *data;\ndata = RedisModule_ModuleTypeGetValue(key);  We can also test for a key to have our native type as value:  if (RedisModule_ModuleTypeGetType(key) == MyType) {\n    /* ... do something ... */\n}  However for the calls to do the right thing, we need to check if the key\nis empty, if it contains a value of the right kind, and so forth. So\nthe idiomatic code to implement a command writing to our native type\nis along these lines:  RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],\n    REDISMODULE_READ|REDISMODULE_WRITE);\nint type = RedisModule_KeyType(key);\nif (type != REDISMODULE_KEYTYPE_EMPTY  \n    RedisModule_ModuleTypeGetType(key) != MyType)\n{\n    return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);\n}  Then if we successfully verified the key is not of the wrong type, and\nwe are going to write to it, we usually want to create a new data structure if\nthe key is empty, or retrieve the reference to the value associated to the\nkey if there is already one:  /* Create an empty value object if the key is currently empty. */\nstruct some_private_struct *data;\nif (type == REDISMODULE_KEYTYPE_EMPTY) {\n    data = createMyDataStructure();\n    RedisModule_ModuleTypeSetValue(key,MyTyke,data);\n} else {\n    data = RedisModule_ModuleTypeGetValue(key);\n}\n/* Do something with 'data'... */", 
            "title": "Setting and getting keys"
        }, 
        {
            "location": "/TYPES/#free-method", 
            "text": "As already mentioned, when Redis needs to free a key holding a native type\nvalue, it needs help from the module in order to release the memory. This\nis the reason why we pass a  free  callback during the type registration:  typedef void (*RedisModuleTypeFreeFunc)(void *value);  A trivial implementation of the free method can be something like this,\nassuming our data structure is composed of a single allocation:  void MyTypeFreeCallback(void *value) {\n    RedisModule_Free(value);\n}  However a more real world one will call some function that performs a more\ncomplex memory reclaiming, by casting the void pointer to some structure\nand freeing all the resources composing the value.", 
            "title": "Free method"
        }, 
        {
            "location": "/TYPES/#rdb-load-and-save-methods", 
            "text": "The RDB saving and loading callbacks need to create (and load back) a\nrepresentation of the data type on disk. Redis offers an high level API\nthat can automatically store inside the RDB file the following types:   Unsigned 64 bit integers.  Signed 64 bit integers.  Doubles.  Strings.   It is up to the module to find a viable representation using the above base\ntypes. However note that while the integer and double values are stored\nand loaded in an architecture and  endianess  agnostic way, if you use\nthe raw string saving API to, for example, save a structure on disk, you\nhave to care those details yourself.  This is the list of functions performing RDB saving and loading:  void RedisModule_SaveUnsigned(RedisModuleIO *io, uint64_t value);\nuint64_t RedisModule_LoadUnsigned(RedisModuleIO *io);\nvoid RedisModule_SaveSigned(RedisModuleIO *io, int64_t value);\nint64_t RedisModule_LoadSigned(RedisModuleIO *io);\nvoid RedisModule_SaveString(RedisModuleIO *io, RedisModuleString *s);\nvoid RedisModule_SaveStringBuffer(RedisModuleIO *io, const char *str, size_t len);\nRedisModuleString *RedisModule_LoadString(RedisModuleIO *io);\nchar *RedisModule_LoadStringBuffer(RedisModuleIO *io, size_t *lenptr);\nvoid RedisModule_SaveDouble(RedisModuleIO *io, double value);\ndouble RedisModule_LoadDouble(RedisModuleIO *io);  The functions don't require any error checking from the module, that can\nalways assume calls succeed.  As an example, imagine I've a native type that implements an array of\ndouble values, with the following structure:  struct double_array {\n    size_t count;\n    double *values;\n};  My  rdb_save  method may look like the following:  void DoubleArrayRDBSave(RedisModuleIO *io, void *ptr) {\n    struct dobule_array *da = ptr;\n    RedisModule_SaveUnsigned(io,da- count);\n    for (size_t j = 0; j   da- count; j++)\n        RedisModule_SaveDouble(io,da- values[j]);\n}  What we did was to store the number of elements followed by each double\nvalue. So when later we'll have to load the structure in the  rdb_load \nmethod we'll do something like this:  void *DoubleArrayRDBLoad(RedisModuleIO *io, int encver) {\n    if (encver != DOUBLE_ARRAY_ENC_VER) {\n        /* We should actually log an error here, or try to implement\n           the ability to load older versions of our data structure. */\n        return NULL;\n    }\n\n    struct double_array *da;\n    da = RedisModule_Alloc(sizeof(*da));\n    da- count = RedisModule_LoadUnsigned(io);\n    da- values = RedisModule_Alloc(da- count * sizeof(double));\n    for (size_t j = 0; j   da- count; j++)\n        da- values = RedisModule_LoadDouble(io);\n    return da;\n}  The load callback just reconstruct back the data structure from the data\nwe stored in the RDB file.  Note that while there is no error handling on the API that writes and reads\nfrom disk, still the load callback can return NULL on errors in case what\nit reads does not look correct. Redis will just panic in that case.", 
            "title": "RDB load and save methods"
        }, 
        {
            "location": "/TYPES/#aof-rewriting", 
            "text": "void RedisModule_EmitAOF(RedisModuleIO *io, const char *cmdname, const char *fmt, ...);", 
            "title": "AOF rewriting"
        }, 
        {
            "location": "/TYPES/#handling-multiple-encodings", 
            "text": "WORK IN PROGRESS", 
            "title": "Handling multiple encodings"
        }, 
        {
            "location": "/TYPES/#allocating-memory", 
            "text": "Modules data types should try to use  RedisModule_Alloc()  functions family\nin order to allocate, reallocate and release heap memory used to implement the native data structures (see the other Redis Modules documentation for detailed information).  This is not just useful in order for Redis to be able to account for the memory used by the module, but there are also more advantages:   Redis uses the  jemalloc  allcator, that often prevents fragmentation problems that could be caused by using the libc allocator.  When loading strings from the RDB file, the native types API is able to return strings allocated directly with  RedisModule_Alloc() , so that the module can directly link this memory into the data structure representation, avoiding an useless copy of the data.   Even if you are using external libraries implementing your data structures, the\nallocation functions provided by the module API is exactly compatible with malloc() ,  realloc() ,  free()  and  strdup() , so converting the libraries\nin order to use these functions should be trivial.  In case you have an external library that uses libc  malloc() , and you want\nto avoid replacing manually all the calls with the Redis Modules API calls,\nan approach could be to use simple macros in order to replace the libc calls\nwith the Redis API calls. Something like this could work:  #define malloc RedisModule_Alloc\n#define realloc RedisModule_Realloc\n#define free RedisModule_Free\n#define strdup RedisModule_Strdup  However take in mind that mixing libc calls with Redis API calls will result\ninto troubles and crashes, so if you replace calls using macros, you need to\nmake sure that all the calls are correctly replaced, and that the code with\nthe substituted calls will never, for example, attempt to call RedisModule_Free()  with a pointer allocated using libc  malloc() .", 
            "title": "Allocating memory"
        }, 
        {
            "location": "/BLOCK/", 
            "text": "Blocking commands in Redis modules\n\n\nRedis has a few blocking commands among the built-in set of commands.\nOne of the most used is \nBLPOP\n (or the symmetric \nBRPOP\n) which blocks\nwaiting for elements arriving in a list.\n\n\nThe interesting fact about blocking commands is that they do not block\nthe whole server, but just the client calling them. Usually the reason to\nblock is that we expect some external event to happen: this can be\nsome change in the Redis data structures like in the \nBLPOP\n case, a\nlong computation happening in a thread, to receive some data from the\nnetwork, and so forth.\n\n\nRedis modules have the ability to implement blocking commands as well,\nthis documentation shows how the API works and describes a few patterns\nthat can be used in order to model blocking commands.\n\n\nHow blocking and resuming works.\n\n\nNote: You may want to check the \nhelloblock.c\n example in the Redis source tree\ninside the \nsrc/modules\n directory, for a simple to understand example\non how the blocking API is applied.\n\n\nIn Redis modules, commands are implemented by callback functions that\nare invoked by the Redis core when the specific command is called\nby the user. Normally the callback terminates its execution sending\nsome reply to the client. Using the following function instead, the\nfunction implementing the module command may request that the client\nis put into the blocked state:\n\n\nRedisModuleBlockedClient *RedisModule_BlockClient(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback, RedisModuleCmdFunc timeout_callback, void (*free_privdata)(void*), long long timeout_ms);\n\n\n\nThe function returns a \nRedisModuleBlockedClient\n object, which is later\nused in order to unblock the client. The arguments have the following\nmeaning:\n\n\n\n\nctx\n is the command execution context as usually in the rest of the API.\n\n\nreply_callback\n is the callback, having the same prototype of a normal command function, that is called when the client is unblocked in order to return a reply to the client.\n\n\ntimeout_callback\n is the callback, having the same prototype of a normal command function that is called when the client reached the \nms\n timeout.\n\n\nfree_privdata\n is the callback that is called in order to free the private data. Private data is a pointer to some data that is passed between the API used to unblock the client, to the callback that will send the reply to the client. We'll see how this mechanism works later in this document.\n\n\nms\n is the timeout in milliseconds. When the timeout is reached, the timeout callback is called and the client is automatically aborted.\n\n\n\n\nOnce a client is blocked, it can be unblocked with the following API:\n\n\nint RedisModule_UnblockClient(RedisModuleBlockedClient *bc, void *privdata);\n\n\n\nThe function takes as argument the blocked client object returned by\nthe previous call to \nRedisModule_BlockClient()\n, and unblock the client.\nImmediately before the client gets unblocked, the \nreply_callback\n function\nspecified when the client was blocked is called: this function will\nhave access to the \nprivdata\n pointer used here.\n\n\nIMPORTANT: The above function is thread safe, and can be called from within\na thread doing some work in order to implement the command that blocked\nthe client.\n\n\nThe \nprivdata\n data will be freed automatically using the \nfree_privdata\n\ncallback when the client is unblocked. This is useful \nsince the reply\ncallback may never be called\n in case the client timeouts or disconnects\nfrom the server, so it's important that it's up to an external function\nto have the responsibility to free the data passed if needed.\n\n\nTo better understand how the API works, we can imagine writing a command\nthat blocks a client for one second, and then send as reply \"Hello!\".\n\n\nNote: arity checks and other non important things are not implemented\nint his command, in order to take the example simple.\n\n\nint Example_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv,\n                         int argc)\n{\n    RedisModuleBlockedClient *bc =\n        RedisModule_BlockClient(ctx,reply_func,timeout_func,NULL,0);\n\n    pthread_t tid;\n    pthread_create(\ntid,NULL,threadmain,bc);\n\n    return REDISMODULE_OK;\n}\n\nvoid *threadmain(void *arg) {\n    RedisModuleBlockedClient *bc = arg;\n\n    sleep(1); /* Wait one second and unblock. */\n    RedisModule_UnblockClient(bc,NULL);\n}\n\n\n\nThe above command blocks the client ASAP, spawining a thread that will\nwait a second and will unblock the client. Let's check the reply and\ntimeout callbacks, which are in our case very similar, since they\njust reply the client with a different reply type.\n\n\nint reply_func(RedisModuleCtx *ctx, RedisModuleString **argv,\n               int argc)\n{\n    return RedisModule_ReplyWithSimpleString(ctx,\"Hello!\");\n}\n\nint timeout_func(RedisModuleCtx *ctx, RedisModuleString **argv,\n               int argc)\n{\n    return RedisModule_ReplyWithNull(ctx);\n}\n\n\n\nThe reply callback just sends the \"Hello!\" string to the client.\nThe important bit here is that the reply callback is called when the\nclient is unblocked from the thread.\n\n\nThe timeout command returns \nNULL\n, as it often happens with actual\nRedis blocking commands timing out.\n\n\nPassing reply data when unblocking\n\n\nThe above example is simple to understand but lacks an important\nreal world aspect of an actual blocking command implementation: often\nthe reply function will need to know what to reply to the client,\nand this information is often provided as the client is unblocked.\n\n\nWe could modify the above example so that the thread generates a\nrandom number after waiting one second. You can think at it as an\nactually expansive operation of some kind. Then this random number\ncan be passed to the reply function so that we return it to the command\ncaller. In order to make this working, we modify the functions as follow:\n\n\nvoid *threadmain(void *arg) {\n    RedisModuleBlockedClient *bc = arg;\n\n    sleep(1); /* Wait one second and unblock. */\n\n    long *mynumber = RedisModule_Alloc(sizeof(long));\n    *mynumber = rand();\n    RedisModule_UnblockClient(bc,mynumber);\n}\n\n\n\nAs you can see, now the unblocking call is passing some private data,\nthat is the \nmynumber\n pointer, to the reply callback. In order to\nobtain this private data, the reply callback will use the following\nfnuction:\n\n\nvoid *RedisModule_GetBlockedClientPrivateData(RedisModuleCtx *ctx);\n\n\n\nSo our reply callback is modified like that:\n\n\nint reply_func(RedisModuleCtx *ctx, RedisModuleString **argv,\n               int argc)\n{\n    long *mynumber = RedisModule_GetBlockedClientPrivateData(ctx);\n    /* IMPORTANT: don't free mynumber here, but in the\n     * free privdata callback. */\n    return RedisModule_ReplyWithLongLong(ctx,mynumber);\n}\n\n\n\nNote that we also need to pass a \nfree_privdata\n function when blocking\nthe client with \nRedisModule_BlockClient()\n, since the allocated\nlong value must be freed. Our callback will look like the following:\n\n\nvoid free_privdata(void *privdata) {\n    RedisModule_Free(privdata);\n}\n\n\n\nNOTE: It is important to stress that the private data is best freed in the\n\nfree_privdata\n callback becaues the reply function may not be called\nif the client disconnects or timeout.\n\n\nAlso note that the private data is also accessible from the timeout\ncallback, always using the \nGetBlockedClientPrivateData()\n API.\n\n\nAborting the blocking of a client\n\n\nOne problem that sometimes arises is that we need to allocate resources\nin order to implement the non blocking command. So we block the client,\nthen, for example, try to create a thread, but the thread creation function\nreturns an error. What to do in such a condition in order to recover? We\ndon't want to take the client blocked, nor we want to call \nUnblockClient()\n\nbecause this will trigger the reply callback to be called.\n\n\nIn this case the best thing to do is to use the following function:\n\n\nint RedisModule_AbortBlock(RedisModuleBlockedClient *bc);\n\n\n\nPractically this is how to use it:\n\n\nint Example_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv,\n                         int argc)\n{\n    RedisModuleBlockedClient *bc =\n        RedisModule_BlockClient(ctx,reply_func,timeout_func,NULL,0);\n\n    pthread_t tid;\n    if (pthread_create(\ntid,NULL,threadmain,bc) != 0) {\n        RedisModule_AbortBlock(bc);\n        RedisModule_ReplyWithError(ctx,\"Sorry can't create a thread\");\n    }\n\n    return REDISMODULE_OK;\n}\n\n\n\nThe client will be unblocked but the reply callback will not be called.\n\n\nImplementing the command, reply and timeout callback using a single function\n\n\nThe following functions can be used in order to implement the reply and\ncallback with the same function that implements the primary command\nfunction:\n\n\nint RedisModule_IsBlockedReplyRequest(RedisModuleCtx *ctx);\nint RedisModule_IsBlockedTimeoutRequest(RedisModuleCtx *ctx);\n\n\n\nSo I could rewrite the example command without using a separated\nreply and timeout callback:\n\n\nint Example_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv,\n                         int argc)\n{\n    if (RedisModule_IsBlockedReplyRequest(ctx)) {\n        long *mynumber = RedisModule_GetBlockedClientPrivateData(ctx);\n        return RedisModule_ReplyWithLongLong(ctx,mynumber);\n    } else if (RedisModule_IsBlockedTimeoutRequest) {\n        return RedisModule_ReplyWithNull(ctx);\n    }\n\n    RedisModuleBlockedClient *bc =\n        RedisModule_BlockClient(ctx,reply_func,timeout_func,NULL,0);\n\n    pthread_t tid;\n    if (pthread_create(\ntid,NULL,threadmain,bc) != 0) {\n        RedisModule_AbortBlock(bc);\n        RedisModule_ReplyWithError(ctx,\"Sorry can't create a thread\");\n    }\n\n    return REDISMODULE_OK;\n}\n\n\n\nFunctionally is the same but there are people that will prefer the less\nverbose implementation that concentrates most of the command logic in a\nsingle function.\n\n\nWorking on copies of data inside a thread\n\n\nAn interesting pattern in order to work with threads implementing the\nslow part of a command, is to work with a copy of the data, so that\nwhile some operation is performed in a key, the user continues to see\nthe old version. However when the thread terminated its work, the\nrepresentations are swapped and the new, processed version, is used.\n\n\nAn example of this approach is the\n\nNeural Redis module\n\nwhere neural networks are trained in different threads while the\nuser can still execute and inspect their older versions.\n\n\nFuture work\n\n\nAn API is work in progress right now in order to allow Redis modules APIs\nto be called in a safe way from threads, so that the threaded command\ncan access the data space and do incremental operations.\n\n\nThere is no ETA for this feature but it may appear in the course of the\nRedis 4.0 release at some point.", 
            "title": "Blocking"
        }, 
        {
            "location": "/BLOCK/#blocking-commands-in-redis-modules", 
            "text": "Redis has a few blocking commands among the built-in set of commands.\nOne of the most used is  BLPOP  (or the symmetric  BRPOP ) which blocks\nwaiting for elements arriving in a list.  The interesting fact about blocking commands is that they do not block\nthe whole server, but just the client calling them. Usually the reason to\nblock is that we expect some external event to happen: this can be\nsome change in the Redis data structures like in the  BLPOP  case, a\nlong computation happening in a thread, to receive some data from the\nnetwork, and so forth.  Redis modules have the ability to implement blocking commands as well,\nthis documentation shows how the API works and describes a few patterns\nthat can be used in order to model blocking commands.", 
            "title": "Blocking commands in Redis modules"
        }, 
        {
            "location": "/BLOCK/#how-blocking-and-resuming-works", 
            "text": "Note: You may want to check the  helloblock.c  example in the Redis source tree\ninside the  src/modules  directory, for a simple to understand example\non how the blocking API is applied.  In Redis modules, commands are implemented by callback functions that\nare invoked by the Redis core when the specific command is called\nby the user. Normally the callback terminates its execution sending\nsome reply to the client. Using the following function instead, the\nfunction implementing the module command may request that the client\nis put into the blocked state:  RedisModuleBlockedClient *RedisModule_BlockClient(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback, RedisModuleCmdFunc timeout_callback, void (*free_privdata)(void*), long long timeout_ms);  The function returns a  RedisModuleBlockedClient  object, which is later\nused in order to unblock the client. The arguments have the following\nmeaning:   ctx  is the command execution context as usually in the rest of the API.  reply_callback  is the callback, having the same prototype of a normal command function, that is called when the client is unblocked in order to return a reply to the client.  timeout_callback  is the callback, having the same prototype of a normal command function that is called when the client reached the  ms  timeout.  free_privdata  is the callback that is called in order to free the private data. Private data is a pointer to some data that is passed between the API used to unblock the client, to the callback that will send the reply to the client. We'll see how this mechanism works later in this document.  ms  is the timeout in milliseconds. When the timeout is reached, the timeout callback is called and the client is automatically aborted.   Once a client is blocked, it can be unblocked with the following API:  int RedisModule_UnblockClient(RedisModuleBlockedClient *bc, void *privdata);  The function takes as argument the blocked client object returned by\nthe previous call to  RedisModule_BlockClient() , and unblock the client.\nImmediately before the client gets unblocked, the  reply_callback  function\nspecified when the client was blocked is called: this function will\nhave access to the  privdata  pointer used here.  IMPORTANT: The above function is thread safe, and can be called from within\na thread doing some work in order to implement the command that blocked\nthe client.  The  privdata  data will be freed automatically using the  free_privdata \ncallback when the client is unblocked. This is useful  since the reply\ncallback may never be called  in case the client timeouts or disconnects\nfrom the server, so it's important that it's up to an external function\nto have the responsibility to free the data passed if needed.  To better understand how the API works, we can imagine writing a command\nthat blocks a client for one second, and then send as reply \"Hello!\".  Note: arity checks and other non important things are not implemented\nint his command, in order to take the example simple.  int Example_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv,\n                         int argc)\n{\n    RedisModuleBlockedClient *bc =\n        RedisModule_BlockClient(ctx,reply_func,timeout_func,NULL,0);\n\n    pthread_t tid;\n    pthread_create( tid,NULL,threadmain,bc);\n\n    return REDISMODULE_OK;\n}\n\nvoid *threadmain(void *arg) {\n    RedisModuleBlockedClient *bc = arg;\n\n    sleep(1); /* Wait one second and unblock. */\n    RedisModule_UnblockClient(bc,NULL);\n}  The above command blocks the client ASAP, spawining a thread that will\nwait a second and will unblock the client. Let's check the reply and\ntimeout callbacks, which are in our case very similar, since they\njust reply the client with a different reply type.  int reply_func(RedisModuleCtx *ctx, RedisModuleString **argv,\n               int argc)\n{\n    return RedisModule_ReplyWithSimpleString(ctx,\"Hello!\");\n}\n\nint timeout_func(RedisModuleCtx *ctx, RedisModuleString **argv,\n               int argc)\n{\n    return RedisModule_ReplyWithNull(ctx);\n}  The reply callback just sends the \"Hello!\" string to the client.\nThe important bit here is that the reply callback is called when the\nclient is unblocked from the thread.  The timeout command returns  NULL , as it often happens with actual\nRedis blocking commands timing out.", 
            "title": "How blocking and resuming works."
        }, 
        {
            "location": "/BLOCK/#passing-reply-data-when-unblocking", 
            "text": "The above example is simple to understand but lacks an important\nreal world aspect of an actual blocking command implementation: often\nthe reply function will need to know what to reply to the client,\nand this information is often provided as the client is unblocked.  We could modify the above example so that the thread generates a\nrandom number after waiting one second. You can think at it as an\nactually expansive operation of some kind. Then this random number\ncan be passed to the reply function so that we return it to the command\ncaller. In order to make this working, we modify the functions as follow:  void *threadmain(void *arg) {\n    RedisModuleBlockedClient *bc = arg;\n\n    sleep(1); /* Wait one second and unblock. */\n\n    long *mynumber = RedisModule_Alloc(sizeof(long));\n    *mynumber = rand();\n    RedisModule_UnblockClient(bc,mynumber);\n}  As you can see, now the unblocking call is passing some private data,\nthat is the  mynumber  pointer, to the reply callback. In order to\nobtain this private data, the reply callback will use the following\nfnuction:  void *RedisModule_GetBlockedClientPrivateData(RedisModuleCtx *ctx);  So our reply callback is modified like that:  int reply_func(RedisModuleCtx *ctx, RedisModuleString **argv,\n               int argc)\n{\n    long *mynumber = RedisModule_GetBlockedClientPrivateData(ctx);\n    /* IMPORTANT: don't free mynumber here, but in the\n     * free privdata callback. */\n    return RedisModule_ReplyWithLongLong(ctx,mynumber);\n}  Note that we also need to pass a  free_privdata  function when blocking\nthe client with  RedisModule_BlockClient() , since the allocated\nlong value must be freed. Our callback will look like the following:  void free_privdata(void *privdata) {\n    RedisModule_Free(privdata);\n}  NOTE: It is important to stress that the private data is best freed in the free_privdata  callback becaues the reply function may not be called\nif the client disconnects or timeout.  Also note that the private data is also accessible from the timeout\ncallback, always using the  GetBlockedClientPrivateData()  API.", 
            "title": "Passing reply data when unblocking"
        }, 
        {
            "location": "/BLOCK/#aborting-the-blocking-of-a-client", 
            "text": "One problem that sometimes arises is that we need to allocate resources\nin order to implement the non blocking command. So we block the client,\nthen, for example, try to create a thread, but the thread creation function\nreturns an error. What to do in such a condition in order to recover? We\ndon't want to take the client blocked, nor we want to call  UnblockClient() \nbecause this will trigger the reply callback to be called.  In this case the best thing to do is to use the following function:  int RedisModule_AbortBlock(RedisModuleBlockedClient *bc);  Practically this is how to use it:  int Example_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv,\n                         int argc)\n{\n    RedisModuleBlockedClient *bc =\n        RedisModule_BlockClient(ctx,reply_func,timeout_func,NULL,0);\n\n    pthread_t tid;\n    if (pthread_create( tid,NULL,threadmain,bc) != 0) {\n        RedisModule_AbortBlock(bc);\n        RedisModule_ReplyWithError(ctx,\"Sorry can't create a thread\");\n    }\n\n    return REDISMODULE_OK;\n}  The client will be unblocked but the reply callback will not be called.", 
            "title": "Aborting the blocking of a client"
        }, 
        {
            "location": "/BLOCK/#implementing-the-command-reply-and-timeout-callback-using-a-single-function", 
            "text": "The following functions can be used in order to implement the reply and\ncallback with the same function that implements the primary command\nfunction:  int RedisModule_IsBlockedReplyRequest(RedisModuleCtx *ctx);\nint RedisModule_IsBlockedTimeoutRequest(RedisModuleCtx *ctx);  So I could rewrite the example command without using a separated\nreply and timeout callback:  int Example_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv,\n                         int argc)\n{\n    if (RedisModule_IsBlockedReplyRequest(ctx)) {\n        long *mynumber = RedisModule_GetBlockedClientPrivateData(ctx);\n        return RedisModule_ReplyWithLongLong(ctx,mynumber);\n    } else if (RedisModule_IsBlockedTimeoutRequest) {\n        return RedisModule_ReplyWithNull(ctx);\n    }\n\n    RedisModuleBlockedClient *bc =\n        RedisModule_BlockClient(ctx,reply_func,timeout_func,NULL,0);\n\n    pthread_t tid;\n    if (pthread_create( tid,NULL,threadmain,bc) != 0) {\n        RedisModule_AbortBlock(bc);\n        RedisModule_ReplyWithError(ctx,\"Sorry can't create a thread\");\n    }\n\n    return REDISMODULE_OK;\n}  Functionally is the same but there are people that will prefer the less\nverbose implementation that concentrates most of the command logic in a\nsingle function.", 
            "title": "Implementing the command, reply and timeout callback using a single function"
        }, 
        {
            "location": "/BLOCK/#working-on-copies-of-data-inside-a-thread", 
            "text": "An interesting pattern in order to work with threads implementing the\nslow part of a command, is to work with a copy of the data, so that\nwhile some operation is performed in a key, the user continues to see\nthe old version. However when the thread terminated its work, the\nrepresentations are swapped and the new, processed version, is used.  An example of this approach is the Neural Redis module \nwhere neural networks are trained in different threads while the\nuser can still execute and inspect their older versions.", 
            "title": "Working on copies of data inside a thread"
        }, 
        {
            "location": "/BLOCK/#future-work", 
            "text": "An API is work in progress right now in order to allow Redis modules APIs\nto be called in a safe way from threads, so that the threaded command\ncan access the data space and do incremental operations.  There is no ETA for this feature but it may appear in the course of the\nRedis 4.0 release at some point.", 
            "title": "Future work"
        }, 
        {
            "location": "/DEFINES/", 
            "text": "Redis Module Common Defines\n\n\n/* Error status return values. */\nREDISMODULE_OK\nREDISMODULE_ERR\n\n/* API versions. */\nREDISMODULE_APIVER_1\n\n/* API flags and constants */\nREDISMODULE_READ\nREDISMODULE_WRITE\n\nREDISMODULE_LIST_HEAD\nREDISMODULE_LIST_TAIL\n\n/* Key types. */\nREDISMODULE_KEYTYPE_EMPTY\nREDISMODULE_KEYTYPE_STRING\nREDISMODULE_KEYTYPE_LIST\nREDISMODULE_KEYTYPE_HASH\nREDISMODULE_KEYTYPE_SET\nREDISMODULE_KEYTYPE_ZSET\nREDISMODULE_KEYTYPE_MODULE\n\n/* Reply types. */\nREDISMODULE_REPLY_UNKNOWN\nREDISMODULE_REPLY_STRING\nREDISMODULE_REPLY_ERROR\nREDISMODULE_REPLY_INTEGER\nREDISMODULE_REPLY_ARRAY\nREDISMODULE_REPLY_NULL\n\n/* Postponed array length. */\nREDISMODULE_POSTPONED_ARRAY_LEN\n\n/* Expire */\nREDISMODULE_NO_EXPIRE -1\n\n/* Sorted set API flags. */\nREDISMODULE_ZADD_XX\nREDISMODULE_ZADD_NX\nREDISMODULE_ZADD_ADDED\nREDISMODULE_ZADD_UPDATED\nREDISMODULE_ZADD_NOP\n\n/* Hash API flags. */\nREDISMODULE_HASH_NONE\nREDISMODULE_HASH_NX\nREDISMODULE_HASH_XX\nREDISMODULE_HASH_CFIELDS\nREDISMODULE_HASH_EXISTS\n\n/* A special pointer that we can use between the core and the module to signal\n * field deletion, and that is impossible to be a valid pointer. */\nREDISMODULE_HASH_DELETE ((RedisModuleString*)(long)1)\n\n/* Error messages. */\nREDISMODULE_ERRORMSG_WRONGTYPE\n\nREDISMODULE_POSITIVE_INFINITE\nREDISMODULE_NEGATIVE_INFINITE\n\nREDISMODULE_NOT_USED(V) ((void) V)", 
            "title": "Defines"
        }, 
        {
            "location": "/DEFINES/#redis-module-common-defines", 
            "text": "/* Error status return values. */\nREDISMODULE_OK\nREDISMODULE_ERR\n\n/* API versions. */\nREDISMODULE_APIVER_1\n\n/* API flags and constants */\nREDISMODULE_READ\nREDISMODULE_WRITE\n\nREDISMODULE_LIST_HEAD\nREDISMODULE_LIST_TAIL\n\n/* Key types. */\nREDISMODULE_KEYTYPE_EMPTY\nREDISMODULE_KEYTYPE_STRING\nREDISMODULE_KEYTYPE_LIST\nREDISMODULE_KEYTYPE_HASH\nREDISMODULE_KEYTYPE_SET\nREDISMODULE_KEYTYPE_ZSET\nREDISMODULE_KEYTYPE_MODULE\n\n/* Reply types. */\nREDISMODULE_REPLY_UNKNOWN\nREDISMODULE_REPLY_STRING\nREDISMODULE_REPLY_ERROR\nREDISMODULE_REPLY_INTEGER\nREDISMODULE_REPLY_ARRAY\nREDISMODULE_REPLY_NULL\n\n/* Postponed array length. */\nREDISMODULE_POSTPONED_ARRAY_LEN\n\n/* Expire */\nREDISMODULE_NO_EXPIRE -1\n\n/* Sorted set API flags. */\nREDISMODULE_ZADD_XX\nREDISMODULE_ZADD_NX\nREDISMODULE_ZADD_ADDED\nREDISMODULE_ZADD_UPDATED\nREDISMODULE_ZADD_NOP\n\n/* Hash API flags. */\nREDISMODULE_HASH_NONE\nREDISMODULE_HASH_NX\nREDISMODULE_HASH_XX\nREDISMODULE_HASH_CFIELDS\nREDISMODULE_HASH_EXISTS\n\n/* A special pointer that we can use between the core and the module to signal\n * field deletion, and that is impossible to be a valid pointer. */\nREDISMODULE_HASH_DELETE ((RedisModuleString*)(long)1)\n\n/* Error messages. */\nREDISMODULE_ERRORMSG_WRONGTYPE\n\nREDISMODULE_POSITIVE_INFINITE\nREDISMODULE_NEGATIVE_INFINITE\n\nREDISMODULE_NOT_USED(V) ((void) V)", 
            "title": "Redis Module Common Defines"
        }, 
        {
            "location": "/RMUtil/RMUtil/", 
            "text": "LibRMUtil\n\n\n\n\nPreflight:\n Download the \nRedisModulesSDK\n.\n\n\n\n\nA small library of utility functions and macros for module developers, including:\n\n\n\n\nEasier argument parsing for your commands.\n\n\nTesting utilities that allow you to wrap your module's tests as a redis command.\n\n\nRedisModuleString\n utility functions (formatting, comparison, etc)\n\n\nThe entire \nsds\n string library, lifted from Redis itself.\n\n\nA generic scalable Vector library. Not redis specific but we found it useful.\n\n\nA few other helpful macros and functions.\n\n\nalloc.h\n, an include file that allows modules implementing data types to implicitly replace the \nmalloc()\n function family with the Redis special allocation wrappers.\n\n\n\n\nIt can be found under the \nrmutil\n folder, and compiles into a static library you link your module against.\n\n\nAn example Module\n\n\nA minimal module implementing a few commands and demonstrating both the Redis Module API, and use of rmutils.\n\n\nYou can treat it as a template for your module, and extend its code and makefile.\n\n\nIt includes 3 commands:\n\n\n\n\nEXAMPLE.PARSE\n - demonstrating rmutil's argument helpers.\n\n\nEXAMPLE.HGETSET\n - an atomic HGET/HSET command, demonstrating the higher level Redis module API.\n\n\nEXAMPLE.TEST\n - a unit test of the above commands, demonstrating use of the testing utilities of rmutils.\n\n\n\n\nDocumentation\n\n\nRead the LibRMUtil API Reference Documentation\n.\n\n\nQuick Start Guide\n\n\nHere's what you need to do to build your first module:\n\n\n\n\nBuild Redis in a build supporting modules.\n\n\nBuild librmutil: \ncd rmutil \n make\n\n\nBuild the example module: \ncd example \n make\n\n\nRun redis loading the module: \n/path/to/redis-server --loadmodule ./example/module.so\n\n\n\n\nNow run \nredis-cli\n and try the commands:\n\n\n127.0.0.1:9979\n EXAMPLE.HGETSET foo bar baz\n(nil)\n127.0.0.1:9979\n EXAMPLE.HGETSET foo bar vaz\n\nbaz\n\n127.0.0.1:9979\n EXAMPLE.PARSE SUM 5 2\n(integer) 7\n127.0.0.1:9979\n EXAMPLE.PARSE PROD 5 2\n(integer) 10\n127.0.0.1:9979\n EXAMPLE.TEST\nPASS", 
            "title": "Intro"
        }, 
        {
            "location": "/RMUtil/RMUtil/#librmutil", 
            "text": "Preflight:  Download the  RedisModulesSDK .   A small library of utility functions and macros for module developers, including:   Easier argument parsing for your commands.  Testing utilities that allow you to wrap your module's tests as a redis command.  RedisModuleString  utility functions (formatting, comparison, etc)  The entire  sds  string library, lifted from Redis itself.  A generic scalable Vector library. Not redis specific but we found it useful.  A few other helpful macros and functions.  alloc.h , an include file that allows modules implementing data types to implicitly replace the  malloc()  function family with the Redis special allocation wrappers.   It can be found under the  rmutil  folder, and compiles into a static library you link your module against.", 
            "title": "LibRMUtil"
        }, 
        {
            "location": "/RMUtil/RMUtil/#an-example-module", 
            "text": "A minimal module implementing a few commands and demonstrating both the Redis Module API, and use of rmutils.  You can treat it as a template for your module, and extend its code and makefile.  It includes 3 commands:   EXAMPLE.PARSE  - demonstrating rmutil's argument helpers.  EXAMPLE.HGETSET  - an atomic HGET/HSET command, demonstrating the higher level Redis module API.  EXAMPLE.TEST  - a unit test of the above commands, demonstrating use of the testing utilities of rmutils.", 
            "title": "An example Module"
        }, 
        {
            "location": "/RMUtil/RMUtil/#documentation", 
            "text": "Read the LibRMUtil API Reference Documentation .", 
            "title": "Documentation"
        }, 
        {
            "location": "/RMUtil/RMUtil/#quick-start-guide", 
            "text": "Here's what you need to do to build your first module:   Build Redis in a build supporting modules.  Build librmutil:  cd rmutil   make  Build the example module:  cd example   make  Run redis loading the module:  /path/to/redis-server --loadmodule ./example/module.so   Now run  redis-cli  and try the commands:  127.0.0.1:9979  EXAMPLE.HGETSET foo bar baz\n(nil)\n127.0.0.1:9979  EXAMPLE.HGETSET foo bar vaz baz \n127.0.0.1:9979  EXAMPLE.PARSE SUM 5 2\n(integer) 7\n127.0.0.1:9979  EXAMPLE.PARSE PROD 5 2\n(integer) 10\n127.0.0.1:9979  EXAMPLE.TEST\nPASS", 
            "title": "Quick Start Guide"
        }, 
        {
            "location": "/RMUtil/RMUtil_API/", 
            "text": "RM_Utils API\n\n\n\n\nPreflight:\n Download the \nRedisModulesSDK\n.\n\n\n\n\nRMUtil_ArgExists\n\n\nint RMUtil_ArgExists(const char *arg, RedisModuleString **argv, int argc, int offset);\n\n\n\n\nReturn the offset of an arg if it exists in the arg list, or 0 if it's not there\n\n\nRMUtil_ParseArgs\n\n\nint RMUtil_ParseArgs(RedisModuleString **argv, int argc, int offset, const char *fmt, ...);\n\n\n\n\nAutomatically conver the arg list to corresponding variable pointers according to a given format.\nYou pass it the command arg list and count, the starting offset, a parsing format, and pointers to the variables.\nThe format is a string consisting of the following identifiers:\n\n\nc -- pointer to a Null terminated C string pointer.\ns -- pointer to a RedisModuleString\nl -- pointer to Long long integer.\nd -- pointer to a Double\n* -- do not parse this argument at all\n\n\n\nExample: If I want to parse args[1], args[2] as a long long and double, I do:\n    double d;\n    long long l;\n    RMUtil_ParseArgs(argv, argc, 1, \"ld\", \nl, \nd);\n\n\nRMUtil_ParseArgsAfter\n\n\nint RMUtil_ParseArgsAfter(const char *token, RedisModuleString **argv, int argc, const char *fmt, ...);\n\n\n\n\nSame as RMUtil_ParseArgs, but only parses the arguments after \ntoken\n, if it was found.\nThis is useful for optional stuff like [LIMIT [offset] [limit]]\n\n\nRMUtil_GetRedisInfo\n\n\nRMUtilInfo *RMUtil_GetRedisInfo(RedisModuleCtx *ctx);\n\n\n\n\nGet redis INFO result and parse it as RMUtilInfo.\n Returns NULL if something goes wrong.\n The resulting object needs to be freed with RMUtilRedisInfo_Free\n\n\nRMUtil_CreateFormattedString\n\n\nRedisModuleString *RMUtil_CreateFormattedString(RedisModuleCtx *ctx, const char *fmt, ...);\n\n\n\n\nCreate a new RedisModuleString object from a printf-style format and arguments.\n Note that RedisModuleString objects CANNOT be used as formatting arguments.\n\n\nRMUtil_StringEquals\n\n\nint RMUtil_StringEquals(RedisModuleString *s1, RedisModuleString *s2);\n\n\n\n\nReturn 1 if the two strings are equal. Case \nsensitive\n\n\nRMUtil_StringEqualsC\n\n\nint RMUtil_StringEqualsC(RedisModuleString *s1, const char *s2);\n\n\n\n\nReturn 1 if the string is equal to a C NULL terminated string. Case \nsensitive\n\n\nRMUtil_StringToLower\n\n\nvoid RMUtil_StringToLower(RedisModuleString *s);\n\n\n\n\nConverts a redis string to lowercase in place without reallocating anything\n\n\nRMUtil_StringToUpper\n\n\nvoid RMUtil_StringToUpper(RedisModuleString *s);\n\n\n\n\nConverts a redis string to uppercase in place without reallocating anything\n\n\nVector_Get\n\n\nint Vector_Get(Vector *v, size_t pos, void *ptr);\n\n\n\n\nget the element at index pos. The value is copied in to ptr. If pos is outside\n the vector capacity, we return 0\n otherwise 1\n\n\nVector_Pop\n\n\nint Vector_Pop(Vector *v, void *ptr);\n\n\n\n\nGet the element at the end of the vector, decreasing the size by one\n\n\nVector_Resize\n\n\nint Vector_Resize(Vector *v, size_t newcap);\n\n\n\n\nresize capacity of v\n\n\nVector_Size\n\n\nint Vector_Size(Vector *v);\n\n\n\n\nreturn the used size of the vector, regardless of capacity\n\n\nVector_Cap\n\n\nint Vector_Cap(Vector *v);\n\n\n\n\nreturn the actual capacity\n\n\nVector_Free\n\n\nvoid Vector_Free(Vector *v);\n\n\n\n\nfree the vector and the underlying data. Does not release its elements if\n they are pointers", 
            "title": "API"
        }, 
        {
            "location": "/RMUtil/RMUtil_API/#rm_utils-api", 
            "text": "Preflight:  Download the  RedisModulesSDK .", 
            "title": "RM_Utils API"
        }, 
        {
            "location": "/RMUtil/RMUtil_API/#rmutil_argexists", 
            "text": "int RMUtil_ArgExists(const char *arg, RedisModuleString **argv, int argc, int offset);  Return the offset of an arg if it exists in the arg list, or 0 if it's not there", 
            "title": "RMUtil_ArgExists"
        }, 
        {
            "location": "/RMUtil/RMUtil_API/#rmutil_parseargs", 
            "text": "int RMUtil_ParseArgs(RedisModuleString **argv, int argc, int offset, const char *fmt, ...);  Automatically conver the arg list to corresponding variable pointers according to a given format.\nYou pass it the command arg list and count, the starting offset, a parsing format, and pointers to the variables.\nThe format is a string consisting of the following identifiers:  c -- pointer to a Null terminated C string pointer.\ns -- pointer to a RedisModuleString\nl -- pointer to Long long integer.\nd -- pointer to a Double\n* -- do not parse this argument at all  Example: If I want to parse args[1], args[2] as a long long and double, I do:\n    double d;\n    long long l;\n    RMUtil_ParseArgs(argv, argc, 1, \"ld\",  l,  d);", 
            "title": "RMUtil_ParseArgs"
        }, 
        {
            "location": "/RMUtil/RMUtil_API/#rmutil_parseargsafter", 
            "text": "int RMUtil_ParseArgsAfter(const char *token, RedisModuleString **argv, int argc, const char *fmt, ...);  Same as RMUtil_ParseArgs, but only parses the arguments after  token , if it was found.\nThis is useful for optional stuff like [LIMIT [offset] [limit]]", 
            "title": "RMUtil_ParseArgsAfter"
        }, 
        {
            "location": "/RMUtil/RMUtil_API/#rmutil_getredisinfo", 
            "text": "RMUtilInfo *RMUtil_GetRedisInfo(RedisModuleCtx *ctx);  Get redis INFO result and parse it as RMUtilInfo.\n Returns NULL if something goes wrong.\n The resulting object needs to be freed with RMUtilRedisInfo_Free", 
            "title": "RMUtil_GetRedisInfo"
        }, 
        {
            "location": "/RMUtil/RMUtil_API/#rmutil_createformattedstring", 
            "text": "RedisModuleString *RMUtil_CreateFormattedString(RedisModuleCtx *ctx, const char *fmt, ...);  Create a new RedisModuleString object from a printf-style format and arguments.\n Note that RedisModuleString objects CANNOT be used as formatting arguments.", 
            "title": "RMUtil_CreateFormattedString"
        }, 
        {
            "location": "/RMUtil/RMUtil_API/#rmutil_stringequals", 
            "text": "int RMUtil_StringEquals(RedisModuleString *s1, RedisModuleString *s2);  Return 1 if the two strings are equal. Case  sensitive", 
            "title": "RMUtil_StringEquals"
        }, 
        {
            "location": "/RMUtil/RMUtil_API/#rmutil_stringequalsc", 
            "text": "int RMUtil_StringEqualsC(RedisModuleString *s1, const char *s2);  Return 1 if the string is equal to a C NULL terminated string. Case  sensitive", 
            "title": "RMUtil_StringEqualsC"
        }, 
        {
            "location": "/RMUtil/RMUtil_API/#rmutil_stringtolower", 
            "text": "void RMUtil_StringToLower(RedisModuleString *s);  Converts a redis string to lowercase in place without reallocating anything", 
            "title": "RMUtil_StringToLower"
        }, 
        {
            "location": "/RMUtil/RMUtil_API/#rmutil_stringtoupper", 
            "text": "void RMUtil_StringToUpper(RedisModuleString *s);  Converts a redis string to uppercase in place without reallocating anything", 
            "title": "RMUtil_StringToUpper"
        }, 
        {
            "location": "/RMUtil/RMUtil_API/#vector_get", 
            "text": "int Vector_Get(Vector *v, size_t pos, void *ptr);  get the element at index pos. The value is copied in to ptr. If pos is outside\n the vector capacity, we return 0\n otherwise 1", 
            "title": "Vector_Get"
        }, 
        {
            "location": "/RMUtil/RMUtil_API/#vector_pop", 
            "text": "int Vector_Pop(Vector *v, void *ptr);  Get the element at the end of the vector, decreasing the size by one", 
            "title": "Vector_Pop"
        }, 
        {
            "location": "/RMUtil/RMUtil_API/#vector_resize", 
            "text": "int Vector_Resize(Vector *v, size_t newcap);  resize capacity of v", 
            "title": "Vector_Resize"
        }, 
        {
            "location": "/RMUtil/RMUtil_API/#vector_size", 
            "text": "int Vector_Size(Vector *v);  return the used size of the vector, regardless of capacity", 
            "title": "Vector_Size"
        }, 
        {
            "location": "/RMUtil/RMUtil_API/#vector_cap", 
            "text": "int Vector_Cap(Vector *v);  return the actual capacity", 
            "title": "Vector_Cap"
        }, 
        {
            "location": "/RMUtil/RMUtil_API/#vector_free", 
            "text": "void Vector_Free(Vector *v);  free the vector and the underlying data. Does not release its elements if\n they are pointers", 
            "title": "Vector_Free"
        }, 
        {
            "location": "/code/module/", 
            "text": "#include \n../redismodule.h\n\n#include \n../rmutil/util.h\n\n#include \n../rmutil/strings.h\n\n#include \n../rmutil/test_util.h\n\n\n/* EXAMPLE.PARSE [SUM \nx\n \ny\n] | [PROD \nx\n \ny\n]\n*  Demonstrates the automatic arg parsing utility.\n*  If the command receives \nSUM \nx\n \ny\n it returns their sum\n*  If it receives \nPROD \nx\n \ny\n it returns their product\n*/\nint ParseCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n\n  // we must have at least 4 args\n  if (argc \n 4) {\n    return RedisModule_WrongArity(ctx);\n  }\n\n  // init auto memory for created strings\n  RedisModule_AutoMemory(ctx);\n  long long x, y;\n\n  // If we got SUM - return the sum of 2 consecutive arguments\n  if (RMUtil_ParseArgsAfter(\nSUM\n, argv, argc, \nll\n, \nx, \ny) ==\n      REDISMODULE_OK) {\n    RedisModule_ReplyWithLongLong(ctx, x + y);\n    return REDISMODULE_OK;\n  }\n\n  // If we got PROD - return the product of 2 consecutive arguments\n  if (RMUtil_ParseArgsAfter(\nPROD\n, argv, argc, \nll\n, \nx, \ny) ==\n      REDISMODULE_OK) {\n    RedisModule_ReplyWithLongLong(ctx, x * y);\n    return REDISMODULE_OK;\n  }\n\n  // something is fishy...\n  RedisModule_ReplyWithError(ctx, \nInvalid arguments\n);\n\n  return REDISMODULE_ERR;\n}\n\n/*\n* example.HGETSET \nkey\n \nelement\n \nvalue\n\n* Atomically set a value in a HASH key to \nvalue\n and return its value before\n* the HSET.\n*\n* Basically atomic HGET + HSET\n*/\nint HGetSetCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n\n  // we need EXACTLY 4 arguments\n  if (argc != 4) {\n    return RedisModule_WrongArity(ctx);\n  }\n  RedisModule_AutoMemory(ctx);\n\n  // open the key and make sure it's indeed a HASH and not empty\n  RedisModuleKey *key =\n      RedisModule_OpenKey(ctx, argv[1], REDISMODULE_READ | REDISMODULE_WRITE);\n  if (RedisModule_KeyType(key) != REDISMODULE_KEYTYPE_HASH \n\n      RedisModule_KeyType(key) != REDISMODULE_KEYTYPE_EMPTY) {\n    return RedisModule_ReplyWithError(ctx, REDISMODULE_ERRORMSG_WRONGTYPE);\n  }\n\n  // get the current value of the hash element\n  RedisModuleCallReply *rep =\n      RedisModule_Call(ctx, \nHGET\n, \nss\n, argv[1], argv[2]);\n  RMUTIL_ASSERT_NOERROR(rep);\n\n  // set the new value of the element\n  RedisModuleCallReply *srep =\n      RedisModule_Call(ctx, \nHSET\n, \nsss\n, argv[1], argv[2], argv[3]);\n  RMUTIL_ASSERT_NOERROR(srep);\n\n  // if the value was null before - we just return null\n  if (RedisModule_CallReplyType(rep) == REDISMODULE_REPLY_NULL) {\n    RedisModule_ReplyWithNull(ctx);\n    return REDISMODULE_OK;\n  }\n\n  // forward the HGET reply to the client\n  RedisModule_ReplyWithCallReply(ctx, rep);\n  return REDISMODULE_OK;\n}\n\n// Test the the PARSE command\nint testParse(RedisModuleCtx *ctx) {\n\n  RedisModuleCallReply *r =\n      RedisModule_Call(ctx, \nexample.parse\n, \nccc\n, \nSUM\n, \n5\n, \n2\n);\n  RMUtil_Assert(RedisModule_CallReplyType(r) == REDISMODULE_REPLY_INTEGER);\n  RMUtil_AssertReplyEquals(r, \n7\n);\n\n  r = RedisModule_Call(ctx, \nexample.parse\n, \nccc\n, \nPROD\n, \n5\n, \n2\n);\n  RMUtil_Assert(RedisModule_CallReplyType(r) == REDISMODULE_REPLY_INTEGER);\n  RMUtil_AssertReplyEquals(r, \n10\n);\n  return 0;\n}\n\n// test the HGETSET command\nint testHgetSet(RedisModuleCtx *ctx) {\n  RedisModuleCallReply *r =\n      RedisModule_Call(ctx, \nexample.hgetset\n, \nccc\n, \nfoo\n, \nbar\n, \nbaz\n);\n  RMUtil_Assert(RedisModule_CallReplyType(r) != REDISMODULE_REPLY_ERROR);\n\n  r = RedisModule_Call(ctx, \nexample.hgetset\n, \nccc\n, \nfoo\n, \nbar\n, \nbag\n);\n  RMUtil_Assert(RedisModule_CallReplyType(r) == REDISMODULE_REPLY_STRING);\n  RMUtil_AssertReplyEquals(r, \nbaz\n);\n  r = RedisModule_Call(ctx, \nexample.hgetset\n, \nccc\n, \nfoo\n, \nbar\n, \nbang\n);\n  RMUtil_AssertReplyEquals(r, \nbag\n);\n  return 0;\n}\n\n// Unit test entry point for the module\nint TestModule(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n  RedisModule_AutoMemory(ctx);\n\n  RMUtil_Test(testParse);\n  RMUtil_Test(testHgetSet);\n\n  RedisModule_ReplyWithSimpleString(ctx, \nPASS\n);\n  return REDISMODULE_OK;\n}\n\nint RedisModule_OnLoad(RedisModuleCtx *ctx) {\n\n  // Register the module itself\n  if (RedisModule_Init(ctx, \nexample\n, 1, REDISMODULE_APIVER_1) ==\n      REDISMODULE_ERR) {\n    return REDISMODULE_ERR;\n  }\n\n  // register example.parse - the default registration syntax\n  if (RedisModule_CreateCommand(ctx, \nexample.parse\n, ParseCommand, \nreadonly\n,\n                                1, 1, 1) == REDISMODULE_ERR) {\n    return REDISMODULE_ERR;\n  }\n\n  // register example.hgetset - using the shortened utility registration macro\n  RMUtil_RegisterWriteCmd(ctx, \nexample.hgetset\n, HGetSetCommand, \nfast\n);\n\n  // register the unit test\n  RMUtil_RegisterWriteCmd(ctx, \nexample.test\n, TestModule);\n\n  return REDISMODULE_OK;\n}", 
            "title": "Code"
        }, 
        {
            "location": "/Resources/", 
            "text": "Helpful Module Resources\n\n\nPlaces\n\n\n\n\nredis.io\n\n\nredislabs\n\n\nRedis Modules Marketplace\n\n\n\n\nTools\n\n\n\n\nRedisModulesSDK\n\n\n\n\nLearn\n\n\n\n\nWriting Redis Modules\n\n\nRedis Loadable Modules System\n\n\nUses for Redis Data Types", 
            "title": "Resources"
        }, 
        {
            "location": "/Resources/#helpful-module-resources", 
            "text": "", 
            "title": "Helpful Module Resources"
        }, 
        {
            "location": "/Resources/#places", 
            "text": "redis.io  redislabs  Redis Modules Marketplace", 
            "title": "Places"
        }, 
        {
            "location": "/Resources/#tools", 
            "text": "RedisModulesSDK", 
            "title": "Tools"
        }, 
        {
            "location": "/Resources/#learn", 
            "text": "Writing Redis Modules  Redis Loadable Modules System  Uses for Redis Data Types", 
            "title": "Learn"
        }, 
        {
            "location": "/code/helloworld/", 
            "text": "/* Helloworld module -- A few examples of the Redis Modules API in the form\n * of commands showing how to accomplish common tasks.\n *\n * This module does not do anything useful, if not for a few commands. The\n * examples are designed in order to show the API.\n *\n * -----------------------------------------------------------------------------\n *\n * Copyright (c) 2016, Salvatore Sanfilippo \nantirez at gmail dot com\n\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \nAS IS\n\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \n../redismodule.h\n\n#include \nstdio.h\n\n#include \nstdlib.h\n\n#include \nctype.h\n\n#include \nstring.h\n\n\n/* HELLO.SIMPLE is among the simplest commands you can implement.\n * It just returns the currently selected DB id, a functionality which is\n * missing in Redis. The command uses two important API calls: one to\n * fetch the currently selected DB, the other in order to send the client\n * an integer reply as response. */\nint HelloSimple_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    REDISMODULE_NOT_USED(argv);\n    REDISMODULE_NOT_USED(argc);\n    RedisModule_ReplyWithLongLong(ctx,RedisModule_GetSelectedDb(ctx));\n    return REDISMODULE_OK;\n}\n\n/* HELLO.PUSH.NATIVE re-implements RPUSH, and shows the low level modules API\n * where you can \nopen\n keys, make low level operations, create new keys by\n * pushing elements into non-existing keys, and so forth.\n *\n * You'll find this command to be roughly as fast as the actual RPUSH\n * command. */\nint HelloPushNative_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)\n{\n    if (argc != 3) return RedisModule_WrongArity(ctx);\n\n    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],\n        REDISMODULE_READ|REDISMODULE_WRITE);\n\n    RedisModule_ListPush(key,REDISMODULE_LIST_TAIL,argv[2]);\n    size_t newlen = RedisModule_ValueLength(key);\n    RedisModule_CloseKey(key);\n    RedisModule_ReplyWithLongLong(ctx,newlen);\n    return REDISMODULE_OK;\n}\n\n/* HELLO.PUSH.CALL implements RPUSH using an higher level approach, calling\n * a Redis command instead of working with the key in a low level way. This\n * approach is useful when you need to call Redis commands that are not\n * available as low level APIs, or when you don't need the maximum speed\n * possible but instead prefer implementation simplicity. */\nint HelloPushCall_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)\n{\n    if (argc != 3) return RedisModule_WrongArity(ctx);\n\n    RedisModuleCallReply *reply;\n\n    reply = RedisModule_Call(ctx,\nRPUSH\n,\nss\n,argv[1],argv[2]);\n    long long len = RedisModule_CallReplyInteger(reply);\n    RedisModule_FreeCallReply(reply);\n    RedisModule_ReplyWithLongLong(ctx,len);\n    return REDISMODULE_OK;\n}\n\n/* HELLO.PUSH.CALL2\n * This is exaxctly as HELLO.PUSH.CALL, but shows how we can reply to the\n * client using directly a reply object that Call() returned. */\nint HelloPushCall2_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)\n{\n    if (argc != 3) return RedisModule_WrongArity(ctx);\n\n    RedisModuleCallReply *reply;\n\n    reply = RedisModule_Call(ctx,\nRPUSH\n,\nss\n,argv[1],argv[2]);\n    RedisModule_ReplyWithCallReply(ctx,reply);\n    RedisModule_FreeCallReply(reply);\n    return REDISMODULE_OK;\n}\n\n/* HELLO.LIST.SUM.LEN returns the total length of all the items inside\n * a Redis list, by using the high level Call() API.\n * This command is an example of the array reply access. */\nint HelloListSumLen_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)\n{\n    if (argc != 2) return RedisModule_WrongArity(ctx);\n\n    RedisModuleCallReply *reply;\n\n    reply = RedisModule_Call(ctx,\nLRANGE\n,\nsll\n,argv[1],(long long)0,(long long)-1);\n    size_t strlen = 0;\n    size_t items = RedisModule_CallReplyLength(reply);\n    size_t j;\n    for (j = 0; j \n items; j++) {\n        RedisModuleCallReply *ele = RedisModule_CallReplyArrayElement(reply,j);\n        strlen += RedisModule_CallReplyLength(ele);\n    }\n    RedisModule_FreeCallReply(reply);\n    RedisModule_ReplyWithLongLong(ctx,strlen);\n    return REDISMODULE_OK;\n}\n\n/* HELLO.LIST.SPLICE srclist dstlist count\n * Moves 'count' elements from the tail of 'srclist' to the head of\n * 'dstlist'. If less than count elements are available, it moves as much\n * elements as possible. */\nint HelloListSplice_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    if (argc != 4) return RedisModule_WrongArity(ctx);\n\n    RedisModuleKey *srckey = RedisModule_OpenKey(ctx,argv[1],\n        REDISMODULE_READ|REDISMODULE_WRITE);\n    RedisModuleKey *dstkey = RedisModule_OpenKey(ctx,argv[2],\n        REDISMODULE_READ|REDISMODULE_WRITE);\n\n    /* Src and dst key must be empty or lists. */\n    if ((RedisModule_KeyType(srckey) != REDISMODULE_KEYTYPE_LIST \n\n         RedisModule_KeyType(srckey) != REDISMODULE_KEYTYPE_EMPTY) ||\n        (RedisModule_KeyType(dstkey) != REDISMODULE_KEYTYPE_LIST \n\n         RedisModule_KeyType(dstkey) != REDISMODULE_KEYTYPE_EMPTY))\n    {\n        RedisModule_CloseKey(srckey);\n        RedisModule_CloseKey(dstkey);\n        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);\n    }\n\n    long long count;\n    if ((RedisModule_StringToLongLong(argv[3],\ncount) != REDISMODULE_OK) ||\n        (count \n 0)) {\n        RedisModule_CloseKey(srckey);\n        RedisModule_CloseKey(dstkey);\n        return RedisModule_ReplyWithError(ctx,\nERR invalid count\n);\n    }\n\n    while(count-- \n 0) {\n        RedisModuleString *ele;\n\n        ele = RedisModule_ListPop(srckey,REDISMODULE_LIST_TAIL);\n        if (ele == NULL) break;\n        RedisModule_ListPush(dstkey,REDISMODULE_LIST_HEAD,ele);\n        RedisModule_FreeString(ctx,ele);\n    }\n\n    size_t len = RedisModule_ValueLength(srckey);\n    RedisModule_CloseKey(srckey);\n    RedisModule_CloseKey(dstkey);\n    RedisModule_ReplyWithLongLong(ctx,len);\n    return REDISMODULE_OK;\n}\n\n/* Like the HELLO.LIST.SPLICE above, but uses automatic memory management\n * in order to avoid freeing stuff. */\nint HelloListSpliceAuto_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    if (argc != 4) return RedisModule_WrongArity(ctx);\n\n    RedisModule_AutoMemory(ctx);\n\n    RedisModuleKey *srckey = RedisModule_OpenKey(ctx,argv[1],\n        REDISMODULE_READ|REDISMODULE_WRITE);\n    RedisModuleKey *dstkey = RedisModule_OpenKey(ctx,argv[2],\n        REDISMODULE_READ|REDISMODULE_WRITE);\n\n    /* Src and dst key must be empty or lists. */\n    if ((RedisModule_KeyType(srckey) != REDISMODULE_KEYTYPE_LIST \n\n         RedisModule_KeyType(srckey) != REDISMODULE_KEYTYPE_EMPTY) ||\n        (RedisModule_KeyType(dstkey) != REDISMODULE_KEYTYPE_LIST \n\n         RedisModule_KeyType(dstkey) != REDISMODULE_KEYTYPE_EMPTY))\n    {\n        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);\n    }\n\n    long long count;\n    if ((RedisModule_StringToLongLong(argv[3],\ncount) != REDISMODULE_OK) ||\n        (count \n 0))\n    {\n        return RedisModule_ReplyWithError(ctx,\nERR invalid count\n);\n    }\n\n    while(count-- \n 0) {\n        RedisModuleString *ele;\n\n        ele = RedisModule_ListPop(srckey,REDISMODULE_LIST_TAIL);\n        if (ele == NULL) break;\n        RedisModule_ListPush(dstkey,REDISMODULE_LIST_HEAD,ele);\n    }\n\n    size_t len = RedisModule_ValueLength(srckey);\n    RedisModule_ReplyWithLongLong(ctx,len);\n    return REDISMODULE_OK;\n}\n\n/* HELLO.RAND.ARRAY \ncount\n\n * Shows how to generate arrays as commands replies.\n * It just outputs \ncount\n random numbers. */\nint HelloRandArray_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    if (argc != 2) return RedisModule_WrongArity(ctx);\n    long long count;\n    if (RedisModule_StringToLongLong(argv[1],\ncount) != REDISMODULE_OK ||\n        count \n 0)\n        return RedisModule_ReplyWithError(ctx,\nERR invalid count\n);\n\n    /* To reply with an array, we call RedisModule_ReplyWithArray() followed\n     * by other \ncount\n calls to other reply functions in order to generate\n     * the elements of the array. */\n    RedisModule_ReplyWithArray(ctx,count);\n    while(count--) RedisModule_ReplyWithLongLong(ctx,rand());\n    return REDISMODULE_OK;\n}\n\n/* This is a simple command to test replication. Because of the \n!\n modified\n * in the RedisModule_Call() call, the two INCRs get replicated.\n * Also note how the ECHO is replicated in an unexpected position (check\n * comments the function implementation). */\nint HelloRepl1_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)\n{\n    REDISMODULE_NOT_USED(argv);\n    REDISMODULE_NOT_USED(argc);\n    RedisModuleCallReply *reply;\n    RedisModule_AutoMemory(ctx);\n\n    /* This will be replicated *after* the two INCR statements, since\n     * the Call() replication has precedence, so the actual replication\n     * stream will be:\n     *\n     * MULTI\n     * INCR foo\n     * INCR bar\n     * ECHO c foo\n     * EXEC\n     */\n    RedisModule_Replicate(ctx,\nECHO\n,\nc\n,\nfoo\n);\n\n    /* Using the \n!\n modifier we replicate the command if it\n     * modified the dataset in some way. */\n    reply = RedisModule_Call(ctx,\nINCR\n,\nc!\n,\nfoo\n);\n    reply = RedisModule_Call(ctx,\nINCR\n,\nc!\n,\nbar\n);\n\n    RedisModule_ReplyWithLongLong(ctx,0);\n\n    return REDISMODULE_OK;\n}\n\n/* Another command to show replication. In this case, we call\n * RedisModule_ReplicateVerbatim() to mean we want just the command to be\n * propagated to slaves / AOF exactly as it was called by the user.\n *\n * This command also shows how to work with string objects.\n * It takes a list, and increments all the elements (that must have\n * a numerical value) by 1, returning the sum of all the elements\n * as reply.\n *\n * Usage: HELLO.REPL2 \nlist-key\n */\nint HelloRepl2_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    if (argc != 2) return RedisModule_WrongArity(ctx);\n\n    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */\n    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],\n        REDISMODULE_READ|REDISMODULE_WRITE);\n\n    if (RedisModule_KeyType(key) != REDISMODULE_KEYTYPE_LIST)\n        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);\n\n    size_t listlen = RedisModule_ValueLength(key);\n    long long sum = 0;\n\n    /* Rotate and increment. */\n    while(listlen--) {\n        RedisModuleString *ele = RedisModule_ListPop(key,REDISMODULE_LIST_TAIL);\n        long long val;\n        if (RedisModule_StringToLongLong(ele,\nval) != REDISMODULE_OK) val = 0;\n        val++;\n        sum += val;\n        RedisModuleString *newele = RedisModule_CreateStringFromLongLong(ctx,val);\n        RedisModule_ListPush(key,REDISMODULE_LIST_HEAD,newele);\n    }\n    RedisModule_ReplyWithLongLong(ctx,sum);\n    RedisModule_ReplicateVerbatim(ctx);\n    return REDISMODULE_OK;\n}\n\n/* This is an example of strings DMA access. Given a key containing a string\n * it toggles the case of each character from lower to upper case or the\n * other way around.\n *\n * No automatic memory management is used in this example (for the sake\n * of variety).\n *\n * HELLO.TOGGLE.CASE key */\nint HelloToggleCase_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    if (argc != 2) return RedisModule_WrongArity(ctx);\n\n    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],\n        REDISMODULE_READ|REDISMODULE_WRITE);\n\n    int keytype = RedisModule_KeyType(key);\n    if (keytype != REDISMODULE_KEYTYPE_STRING \n\n        keytype != REDISMODULE_KEYTYPE_EMPTY)\n    {\n        RedisModule_CloseKey(key);\n        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);\n    }\n\n    if (keytype == REDISMODULE_KEYTYPE_STRING) {\n        size_t len, j;\n        char *s = RedisModule_StringDMA(key,\nlen,REDISMODULE_WRITE);\n        for (j = 0; j \n len; j++) {\n            if (isupper(s[j])) {\n                s[j] = tolower(s[j]);\n            } else {\n                s[j] = toupper(s[j]);\n            }\n        }\n    }\n\n    RedisModule_CloseKey(key);\n    RedisModule_ReplyWithSimpleString(ctx,\nOK\n);\n    RedisModule_ReplicateVerbatim(ctx);\n    return REDISMODULE_OK;\n}\n\n/* HELLO.MORE.EXPIRE key milliseconds.\n *\n * If they key has already an associated TTL, extends it by \nmilliseconds\n\n * milliseconds. Otherwise no operation is performed. */\nint HelloMoreExpire_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */\n    if (argc != 3) return RedisModule_WrongArity(ctx);\n\n    mstime_t addms, expire;\n\n    if (RedisModule_StringToLongLong(argv[2],\naddms) != REDISMODULE_OK)\n        return RedisModule_ReplyWithError(ctx,\nERR invalid expire time\n);\n\n    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],\n        REDISMODULE_READ|REDISMODULE_WRITE);\n    expire = RedisModule_GetExpire(key);\n    if (expire != REDISMODULE_NO_EXPIRE) {\n        expire += addms;\n        RedisModule_SetExpire(key,expire);\n    }\n    return RedisModule_ReplyWithSimpleString(ctx,\nOK\n);\n}\n\n/* HELLO.ZSUMRANGE key startscore endscore\n * Return the sum of all the scores elements between startscore and endscore.\n *\n * The computation is performed two times, one time from start to end and\n * another time backward. The two scores, returned as a two element array,\n * should match.*/\nint HelloZsumRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    double score_start, score_end;\n    if (argc != 4) return RedisModule_WrongArity(ctx);\n\n    if (RedisModule_StringToDouble(argv[2],\nscore_start) != REDISMODULE_OK ||\n        RedisModule_StringToDouble(argv[3],\nscore_end) != REDISMODULE_OK)\n    {\n        return RedisModule_ReplyWithError(ctx,\nERR invalid range\n);\n    }\n\n    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],\n        REDISMODULE_READ|REDISMODULE_WRITE);\n    if (RedisModule_KeyType(key) != REDISMODULE_KEYTYPE_ZSET) {\n        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);\n    }\n\n    double scoresum_a = 0;\n    double scoresum_b = 0;\n\n    RedisModule_ZsetFirstInScoreRange(key,score_start,score_end,0,0);\n    while(!RedisModule_ZsetRangeEndReached(key)) {\n        double score;\n        RedisModuleString *ele = RedisModule_ZsetRangeCurrentElement(key,\nscore);\n        RedisModule_FreeString(ctx,ele);\n        scoresum_a += score;\n        RedisModule_ZsetRangeNext(key);\n    }\n    RedisModule_ZsetRangeStop(key);\n\n    RedisModule_ZsetLastInScoreRange(key,score_start,score_end,0,0);\n    while(!RedisModule_ZsetRangeEndReached(key)) {\n        double score;\n        RedisModuleString *ele = RedisModule_ZsetRangeCurrentElement(key,\nscore);\n        RedisModule_FreeString(ctx,ele);\n        scoresum_b += score;\n        RedisModule_ZsetRangePrev(key);\n    }\n\n    RedisModule_ZsetRangeStop(key);\n\n    RedisModule_CloseKey(key);\n\n    RedisModule_ReplyWithArray(ctx,2);\n    RedisModule_ReplyWithDouble(ctx,scoresum_a);\n    RedisModule_ReplyWithDouble(ctx,scoresum_b);\n    return REDISMODULE_OK;\n}\n\n/* HELLO.LEXRANGE key min_lex max_lex min_age max_age\n * This command expects a sorted set stored at key in the following form:\n * - All the elements have score 0.\n * - Elements are pairs of \nname\n:\nage\n, for example \nAnna:52\n.\n * The command will return all the sorted set items that are lexicographically\n * between the specified range (using the same format as ZRANGEBYLEX)\n * and having an age between min_age and max_age. */\nint HelloLexRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */\n\n    if (argc != 6) return RedisModule_WrongArity(ctx);\n\n    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],\n        REDISMODULE_READ|REDISMODULE_WRITE);\n    if (RedisModule_KeyType(key) != REDISMODULE_KEYTYPE_ZSET) {\n        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);\n    }\n\n    if (RedisModule_ZsetFirstInLexRange(key,argv[2],argv[3]) != REDISMODULE_OK) {\n        return RedisModule_ReplyWithError(ctx,\ninvalid range\n);\n    }\n\n    int arraylen = 0;\n    RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_ARRAY_LEN);\n    while(!RedisModule_ZsetRangeEndReached(key)) {\n        double score;\n        RedisModuleString *ele = RedisModule_ZsetRangeCurrentElement(key,\nscore);\n        RedisModule_ReplyWithString(ctx,ele);\n        RedisModule_FreeString(ctx,ele);\n        RedisModule_ZsetRangeNext(key);\n        arraylen++;\n    }\n    RedisModule_ZsetRangeStop(key);\n    RedisModule_ReplySetArrayLength(ctx,arraylen);\n    RedisModule_CloseKey(key);\n    return REDISMODULE_OK;\n}\n\n/* HELLO.HCOPY key srcfield dstfield\n * This is just an example command that sets the hash field dstfield to the\n * same value of srcfield. If srcfield does not exist no operation is\n * performed.\n *\n * The command returns 1 if the copy is performed (srcfield exists) otherwise\n * 0 is returned. */\nint HelloHCopy_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */\n\n    if (argc != 4) return RedisModule_WrongArity(ctx);\n    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],\n        REDISMODULE_READ|REDISMODULE_WRITE);\n    int type = RedisModule_KeyType(key);\n    if (type != REDISMODULE_KEYTYPE_HASH \n\n        type != REDISMODULE_KEYTYPE_EMPTY)\n    {\n        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);\n    }\n\n    /* Get the old field value. */\n    RedisModuleString *oldval;\n    RedisModule_HashGet(key,REDISMODULE_HASH_NONE,argv[2],\noldval,NULL);\n    if (oldval) {\n        RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[3],oldval,NULL);\n    }\n    RedisModule_ReplyWithLongLong(ctx,oldval != NULL);\n    return REDISMODULE_OK;\n}\n\n/* HELLO.LEFTPAD str len ch\n * This is an implementation of the infamous LEFTPAD function, that\n * was at the center of an issue with the npm modules system in March 2016.\n *\n * LEFTPAD is a good example of using a Redis Modules API called\n * \npool allocator\n, that was a famous way to allocate memory in yet another\n * open source project, the Apache web server.\n *\n * The concept is very simple: there is memory that is useful to allocate\n * only in the context of serving a request, and must be freed anyway when\n * the callback implementing the command returns. So in that case the module\n * does not need to retain a reference to these allocations, it is just\n * required to free the memory before returning. When this is the case the\n * module can call RedisModule_PoolAlloc() instead, that works like malloc()\n * but will automatically free the memory when the module callback returns.\n *\n * Note that PoolAlloc() does not necessarily require AutoMemory to be\n * active. */\nint HelloLeftPad_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */\n    long long padlen;\n\n    if (argc != 4) return RedisModule_WrongArity(ctx);\n\n    if ((RedisModule_StringToLongLong(argv[2],\npadlen) != REDISMODULE_OK) ||\n        (padlen\n 0)) {\n        return RedisModule_ReplyWithError(ctx,\nERR invalid padding length\n);\n    }\n    size_t strlen, chlen;\n    const char *str = RedisModule_StringPtrLen(argv[1], \nstrlen);\n    const char *ch = RedisModule_StringPtrLen(argv[3], \nchlen);\n\n    /* If the string is already larger than the target len, just return\n     * the string itself. */\n    if (strlen \n= (size_t)padlen)\n        return RedisModule_ReplyWithString(ctx,argv[1]);\n\n    /* Padding must be a single character in this simple implementation. */\n    if (chlen != 1)\n        return RedisModule_ReplyWithError(ctx,\n            \nERR padding must be a single char\n);\n\n    /* Here we use our pool allocator, for our throw-away allocation. */\n    padlen -= strlen;\n    char *buf = RedisModule_PoolAlloc(ctx,padlen+strlen);\n    for (long long j = 0; j \n padlen; j++) buf[j] = *ch;\n    memcpy(buf+padlen,str,strlen);\n\n    RedisModule_ReplyWithStringBuffer(ctx,buf,padlen+strlen);\n    return REDISMODULE_OK;\n}\n\n/* This function must be present on each Redis module. It is used in order to\n * register the commands into the Redis server. */\nint RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    if (RedisModule_Init(ctx,\nhelloworld\n,1,REDISMODULE_APIVER_1)\n        == REDISMODULE_ERR) return REDISMODULE_ERR;\n\n    /* Log the list of parameters passing loading the module. */\n    for (int j = 0; j \n argc; j++) {\n        const char *s = RedisModule_StringPtrLen(argv[j],NULL);\n        printf(\nModule loaded with ARGV[%d] = %s\\n\n, j, s);\n    }\n\n    if (RedisModule_CreateCommand(ctx,\nhello.simple\n,\n        HelloSimple_RedisCommand,\nreadonly\n,0,0,0) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\nhello.push.native\n,\n        HelloPushNative_RedisCommand,\nwrite deny-oom\n,1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\nhello.push.call\n,\n        HelloPushCall_RedisCommand,\nwrite deny-oom\n,1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\nhello.push.call2\n,\n        HelloPushCall2_RedisCommand,\nwrite deny-oom\n,1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\nhello.list.sum.len\n,\n        HelloListSumLen_RedisCommand,\nreadonly\n,1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\nhello.list.splice\n,\n        HelloListSplice_RedisCommand,\nwrite deny-oom\n,1,2,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\nhello.list.splice.auto\n,\n        HelloListSpliceAuto_RedisCommand,\n        \nwrite deny-oom\n,1,2,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\nhello.rand.array\n,\n        HelloRandArray_RedisCommand,\nreadonly\n,0,0,0) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\nhello.repl1\n,\n        HelloRepl1_RedisCommand,\nwrite\n,0,0,0) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\nhello.repl2\n,\n        HelloRepl2_RedisCommand,\nwrite\n,1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\nhello.toggle.case\n,\n        HelloToggleCase_RedisCommand,\nwrite\n,1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\nhello.more.expire\n,\n        HelloMoreExpire_RedisCommand,\nwrite\n,1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\nhello.zsumrange\n,\n        HelloZsumRange_RedisCommand,\nreadonly\n,1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\nhello.lexrange\n,\n        HelloLexRange_RedisCommand,\nreadonly\n,1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\nhello.hcopy\n,\n        HelloHCopy_RedisCommand,\nwrite deny-oom\n,1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\nhello.leftpad\n,\n        HelloLeftPad_RedisCommand,\n,1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    return REDISMODULE_OK;\n}", 
            "title": "helloworld.c"
        }, 
        {
            "location": "/code/hellotype/", 
            "text": "/* This file implements a new module native data type called \nHELLOTYPE\n.\n * The data structure implemented is a very simple ordered linked list of\n * 64 bit integers, in order to have something that is real world enough, but\n * at the same time, extremely simple to understand, to show how the API\n * works, how a new data type is created, and how to write basic methods\n * for RDB loading, saving and AOF rewriting.\n *\n * -----------------------------------------------------------------------------\n *\n * Copyright (c) 2016, Salvatore Sanfilippo \nantirez at gmail dot com\n\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \nAS IS\n\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \n../redismodule.h\n\n#include \nstdio.h\n\n#include \nstdlib.h\n\n#include \nctype.h\n\n#include \nstring.h\n\n#include \nstdint.h\n\n\nstatic RedisModuleType *HelloType;\n\n/* ========================== Internal data structure  =======================\n * This is just a linked list of 64 bit integers where elements are inserted\n * in-place, so it's ordered. There is no pop/push operation but just insert\n * because it is enough to show the implementation of new data types without\n * making things complex. */\n\nstruct HelloTypeNode {\n    int64_t value;\n    struct HelloTypeNode *next;\n};\n\nstruct HelloTypeObject {\n    struct HelloTypeNode *head;\n    size_t len; /* Number of elements added. */\n};\n\nstruct HelloTypeObject *createHelloTypeObject(void) {\n    struct HelloTypeObject *o;\n    o = RedisModule_Alloc(sizeof(*o));\n    o-\nhead = NULL;\n    o-\nlen = 0;\n    return o;\n}\n\nvoid HelloTypeInsert(struct HelloTypeObject *o, int64_t ele) {\n    struct HelloTypeNode *next = o-\nhead, *newnode, *prev = NULL;\n\n    while(next \n next-\nvalue \n ele) {\n        prev = next;\n        next = next-\nnext;\n    }\n    newnode = RedisModule_Alloc(sizeof(*newnode));\n    newnode-\nvalue = ele;\n    newnode-\nnext = next;\n    if (prev) {\n        prev-\nnext = newnode;\n    } else {\n        o-\nhead = newnode;\n    }\n    o-\nlen++;\n}\n\nvoid HelloTypeReleaseObject(struct HelloTypeObject *o) {\n    struct HelloTypeNode *cur, *next;\n    cur = o-\nhead;\n    while(cur) {\n        next = cur-\nnext;\n        RedisModule_Free(cur);\n        cur = next;\n    }\n    RedisModule_Free(o);\n}\n\n/* ========================= \nhellotype\n type commands ======================= */\n\n/* HELLOTYPE.INSERT key value */\nint HelloTypeInsert_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */\n\n    if (argc != 3) return RedisModule_WrongArity(ctx);\n    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],\n        REDISMODULE_READ|REDISMODULE_WRITE);\n    int type = RedisModule_KeyType(key);\n    if (type != REDISMODULE_KEYTYPE_EMPTY \n\n        RedisModule_ModuleTypeGetType(key) != HelloType)\n    {\n        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);\n    }\n\n    long long value;\n    if ((RedisModule_StringToLongLong(argv[2],\nvalue) != REDISMODULE_OK)) {\n        return RedisModule_ReplyWithError(ctx,\nERR invalid value: must be a signed 64 bit integer\n);\n    }\n\n    /* Create an empty value object if the key is currently empty. */\n    struct HelloTypeObject *hto;\n    if (type == REDISMODULE_KEYTYPE_EMPTY) {\n        hto = createHelloTypeObject();\n        RedisModule_ModuleTypeSetValue(key,HelloType,hto);\n    } else {\n        hto = RedisModule_ModuleTypeGetValue(key);\n    }\n\n    /* Insert the new element. */\n    HelloTypeInsert(hto,value);\n\n    RedisModule_ReplyWithLongLong(ctx,hto-\nlen);\n    RedisModule_ReplicateVerbatim(ctx);\n    return REDISMODULE_OK;\n}\n\n/* HELLOTYPE.RANGE key first count */\nint HelloTypeRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */\n\n    if (argc != 4) return RedisModule_WrongArity(ctx);\n    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],\n        REDISMODULE_READ|REDISMODULE_WRITE);\n    int type = RedisModule_KeyType(key);\n    if (type != REDISMODULE_KEYTYPE_EMPTY \n\n        RedisModule_ModuleTypeGetType(key) != HelloType)\n    {\n        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);\n    }\n\n    long long first, count;\n    if (RedisModule_StringToLongLong(argv[2],\nfirst) != REDISMODULE_OK ||\n        RedisModule_StringToLongLong(argv[3],\ncount) != REDISMODULE_OK ||\n        first \n 0 || count \n 0)\n    {\n        return RedisModule_ReplyWithError(ctx,\n            \nERR invalid first or count parameters\n);\n    }\n\n    struct HelloTypeObject *hto = RedisModule_ModuleTypeGetValue(key);\n    struct HelloTypeNode *node = hto ? hto-\nhead : NULL;\n    RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_ARRAY_LEN);\n    long long arraylen = 0;\n    while(node \n count--) {\n        RedisModule_ReplyWithLongLong(ctx,node-\nvalue);\n        arraylen++;\n        node = node-\nnext;\n    }\n    RedisModule_ReplySetArrayLength(ctx,arraylen);\n    return REDISMODULE_OK;\n}\n\n/* HELLOTYPE.LEN key */\nint HelloTypeLen_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */\n\n    if (argc != 2) return RedisModule_WrongArity(ctx);\n    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],\n        REDISMODULE_READ|REDISMODULE_WRITE);\n    int type = RedisModule_KeyType(key);\n    if (type != REDISMODULE_KEYTYPE_EMPTY \n\n        RedisModule_ModuleTypeGetType(key) != HelloType)\n    {\n        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);\n    }\n\n    struct HelloTypeObject *hto = RedisModule_ModuleTypeGetValue(key);\n    RedisModule_ReplyWithLongLong(ctx,hto ? hto-\nlen : 0);\n    return REDISMODULE_OK;\n}\n\n\n/* ========================== \nhellotype\n type methods ======================= */\n\nvoid *HelloTypeRdbLoad(RedisModuleIO *rdb, int encver) {\n    if (encver != 0) {\n        /* RedisModule_Log(\nwarning\n,\nCan't load data with version %d\n, encver);*/\n        return NULL;\n    }\n    uint64_t elements = RedisModule_LoadUnsigned(rdb);\n    struct HelloTypeObject *hto = createHelloTypeObject();\n    while(elements--) {\n        int64_t ele = RedisModule_LoadSigned(rdb);\n        HelloTypeInsert(hto,ele);\n    }\n    return hto;\n}\n\nvoid HelloTypeRdbSave(RedisModuleIO *rdb, void *value) {\n    struct HelloTypeObject *hto = value;\n    struct HelloTypeNode *node = hto-\nhead;\n    RedisModule_SaveUnsigned(rdb,hto-\nlen);\n    while(node) {\n        RedisModule_SaveSigned(rdb,node-\nvalue);\n        node = node-\nnext;\n    }\n}\n\nvoid HelloTypeAofRewrite(RedisModuleIO *aof, RedisModuleString *key, void *value) {\n    struct HelloTypeObject *hto = value;\n    struct HelloTypeNode *node = hto-\nhead;\n    while(node) {\n        RedisModule_EmitAOF(aof,\nHELLOTYPE.INSERT\n,\nsl\n,key,node-\nvalue);\n        node = node-\nnext;\n    }\n}\n\nvoid HelloTypeDigest(RedisModuleDigest *digest, void *value) {\n    REDISMODULE_NOT_USED(digest);\n    REDISMODULE_NOT_USED(value);\n    /* TODO: The DIGEST module interface is yet not implemented. */\n}\n\nvoid HelloTypeFree(void *value) {\n    HelloTypeReleaseObject(value);\n}\n\n/* This function must be present on each Redis module. It is used in order to\n * register the commands into the Redis server. */\nint RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    REDISMODULE_NOT_USED(argv);\n    REDISMODULE_NOT_USED(argc);\n\n    if (RedisModule_Init(ctx,\nhellotype\n,1,REDISMODULE_APIVER_1)\n        == REDISMODULE_ERR) return REDISMODULE_ERR;\n\n    HelloType = RedisModule_CreateDataType(ctx,\nhellotype\n,0,HelloTypeRdbLoad,HelloTypeRdbSave,HelloTypeAofRewrite,HelloTypeDigest,HelloTypeFree);\n    if (HelloType == NULL) return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\nhellotype.insert\n,\n        HelloTypeInsert_RedisCommand,\nwrite deny-oom\n,1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\nhellotype.range\n,\n        HelloTypeRange_RedisCommand,\nreadonly\n,1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\nhellotype.len\n,\n        HelloTypeLen_RedisCommand,\nreadonly\n,1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    return REDISMODULE_OK;\n}", 
            "title": "hellotype.c"
        }, 
        {
            "location": "/code/helloblock/", 
            "text": "/* Helloblock module -- An example of blocking command implementation\n * with threads.\n *\n * -----------------------------------------------------------------------------\n *\n * Copyright (c) 2016, Salvatore Sanfilippo \nantirez at gmail dot com\n\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \nAS IS\n\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \n../redismodule.h\n\n#include \nstdio.h\n\n#include \nstdlib.h\n\n#include \npthread.h\n\n#include \nunistd.h\n\n\n/* Reply callback for blocking command HELLO.BLOCK */\nint HelloBlock_Reply(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    REDISMODULE_NOT_USED(argv);\n    REDISMODULE_NOT_USED(argc);\n    int *myint = RedisModule_GetBlockedClientPrivateData(ctx);\n    return RedisModule_ReplyWithLongLong(ctx,*myint);\n}\n\n/* Timeout callback for blocking command HELLO.BLOCK */\nint HelloBlock_Timeout(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    REDISMODULE_NOT_USED(argv);\n    REDISMODULE_NOT_USED(argc);\n    return RedisModule_ReplyWithSimpleString(ctx,\nRequest timedout\n);\n}\n\n/* Private data freeing callback for HELLO.BLOCK command. */\nvoid HelloBlock_FreeData(void *privdata) {\n    RedisModule_Free(privdata);\n}\n\n/* The thread entry point that actually executes the blocking part\n * of the command HELLO.BLOCK. */\nvoid *HelloBlock_ThreadMain(void *arg) {\n    void **targ = arg;\n    RedisModuleBlockedClient *bc = targ[0];\n    long long delay = (unsigned long)targ[1];\n    RedisModule_Free(targ);\n\n    sleep(delay);\n    int *r = RedisModule_Alloc(sizeof(int));\n    *r = rand();\n    RedisModule_UnblockClient(bc,r);\n    return NULL;\n}\n\n/* HELLO.BLOCK \ndelay\n \ntimeout\n -- Block for \ncount\n seconds, then reply with\n * a random number. Timeout is the command timeout, so that you can test\n * what happens when the delay is greater than the timeout. */\nint HelloBlock_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    if (argc != 3) return RedisModule_WrongArity(ctx);\n    long long delay;\n    long long timeout;\n\n    if (RedisModule_StringToLongLong(argv[1],\ndelay) != REDISMODULE_OK) {\n        return RedisModule_ReplyWithError(ctx,\nERR invalid count\n);\n    }\n\n    if (RedisModule_StringToLongLong(argv[2],\ntimeout) != REDISMODULE_OK) {\n        return RedisModule_ReplyWithError(ctx,\nERR invalid count\n);\n    }\n\n    pthread_t tid;\n    RedisModuleBlockedClient *bc = RedisModule_BlockClient(ctx,HelloBlock_Reply,HelloBlock_Timeout,HelloBlock_FreeData,timeout);\n\n    /* Now that we setup a blocking client, we need to pass the control\n     * to the thread. However we need to pass arguments to the thread:\n     * the delay and a reference to the blocked client handle. */\n    void **targ = RedisModule_Alloc(sizeof(void*)*2);\n    targ[0] = bc;\n    targ[1] = (void*)(unsigned long) delay;\n\n    if (pthread_create(\ntid,NULL,HelloBlock_ThreadMain,targ) != 0) {\n        RedisModule_AbortBlock(bc);\n        return RedisModule_ReplyWithError(ctx,\n-ERR Can't start thread\n);\n    }\n    return REDISMODULE_OK;\n}\n\n/* This function must be present on each Redis module. It is used in order to\n * register the commands into the Redis server. */\nint RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    REDISMODULE_NOT_USED(argv);\n    REDISMODULE_NOT_USED(argc);\n\n    if (RedisModule_Init(ctx,\nhelloblock\n,1,REDISMODULE_APIVER_1)\n        == REDISMODULE_ERR) return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\nhello.block\n,\n        HelloBlock_RedisCommand,\n,0,0,0) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    return REDISMODULE_OK;\n}", 
            "title": "helloblock.c"
        }, 
        {
            "location": "/code/testmodule/", 
            "text": "/* Module designed to test the Redis modules subsystem.\n *\n * -----------------------------------------------------------------------------\n *\n * Copyright (c) 2016, Salvatore Sanfilippo \nantirez at gmail dot com\n\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \nAS IS\n\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \n../redismodule.h\n\n#include \nstring.h\n\n\n/* --------------------------------- Helpers -------------------------------- */\n\n/* Return true if the reply and the C null term string matches. */\nint TestMatchReply(RedisModuleCallReply *reply, char *str) {\n    RedisModuleString *mystr;\n    mystr = RedisModule_CreateStringFromCallReply(reply);\n    if (!mystr) return 0;\n    const char *ptr = RedisModule_StringPtrLen(mystr,NULL);\n    return strcmp(ptr,str) == 0;\n}\n\n/* ------------------------------- Test units ------------------------------- */\n\n/* TEST.CALL -- Test Call() API. */\nint TestCall(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    REDISMODULE_NOT_USED(argv);\n    REDISMODULE_NOT_USED(argc);\n\n    RedisModule_AutoMemory(ctx);\n    RedisModuleCallReply *reply;\n\n    RedisModule_Call(ctx,\nDEL\n,\nc\n,\nmylist\n);\n    RedisModuleString *mystr = RedisModule_CreateString(ctx,\nfoo\n,3);\n    RedisModule_Call(ctx,\nRPUSH\n,\ncsl\n,\nmylist\n,mystr,(long long)1234);\n    reply = RedisModule_Call(ctx,\nLRANGE\n,\nccc\n,\nmylist\n,\n0\n,\n-1\n);\n    long long items = RedisModule_CallReplyLength(reply);\n    if (items != 2) goto fail;\n\n    RedisModuleCallReply *item0, *item1;\n\n    item0 = RedisModule_CallReplyArrayElement(reply,0);\n    item1 = RedisModule_CallReplyArrayElement(reply,1);\n    if (!TestMatchReply(item0,\nfoo\n)) goto fail;\n    if (!TestMatchReply(item1,\n1234\n)) goto fail;\n\n    RedisModule_ReplyWithSimpleString(ctx,\nOK\n);\n    return REDISMODULE_OK;\n\nfail:\n    RedisModule_ReplyWithSimpleString(ctx,\nERR\n);\n    return REDISMODULE_OK;\n}\n\n/* TEST.STRING.APPEND -- Test appending to an existing string object. */\nint TestStringAppend(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    REDISMODULE_NOT_USED(argv);\n    REDISMODULE_NOT_USED(argc);\n\n    RedisModuleString *s = RedisModule_CreateString(ctx,\nfoo\n,3);\n    RedisModule_StringAppendBuffer(ctx,s,\nbar\n,3);\n    RedisModule_ReplyWithString(ctx,s);\n    RedisModule_FreeString(ctx,s);\n    return REDISMODULE_OK;\n}\n\n/* TEST.STRING.APPEND.AM -- Test append with retain when auto memory is on. */\nint TestStringAppendAM(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    REDISMODULE_NOT_USED(argv);\n    REDISMODULE_NOT_USED(argc);\n\n    RedisModule_AutoMemory(ctx);\n    RedisModuleString *s = RedisModule_CreateString(ctx,\nfoo\n,3);\n    RedisModule_RetainString(ctx,s);\n    RedisModule_StringAppendBuffer(ctx,s,\nbar\n,3);\n    RedisModule_ReplyWithString(ctx,s);\n    RedisModule_FreeString(ctx,s);\n    return REDISMODULE_OK;\n}\n\n/* TEST.STRING.PRINTF -- Test string formatting. */\nint TestStringPrintf(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    RedisModule_AutoMemory(ctx);\n    if (argc \n 3) {\n        return RedisModule_WrongArity(ctx);\n    }\n    RedisModuleString *s = RedisModule_CreateStringPrintf(ctx,\n        \nGot %d args. argv[1]: %s, argv[2]: %s\n,\n        argc,\n        RedisModule_StringPtrLen(argv[1], NULL),\n        RedisModule_StringPtrLen(argv[2], NULL)\n    );\n\n    RedisModule_ReplyWithString(ctx,s);\n\n    return REDISMODULE_OK;\n}\n\n\n/* ----------------------------- Test framework ----------------------------- */\n\n/* Return 1 if the reply matches the specified string, otherwise log errors\n * in the server log and return 0. */\nint TestAssertStringReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply, char *str, size_t len) {\n    RedisModuleString *mystr, *expected;\n\n    if (RedisModule_CallReplyType(reply) != REDISMODULE_REPLY_STRING) {\n        RedisModule_Log(ctx,\nwarning\n,\nUnexpected reply type %d\n,\n            RedisModule_CallReplyType(reply));\n        return 0;\n    }\n    mystr = RedisModule_CreateStringFromCallReply(reply);\n    expected = RedisModule_CreateString(ctx,str,len);\n    if (RedisModule_StringCompare(mystr,expected) != 0) {\n        const char *mystr_ptr = RedisModule_StringPtrLen(mystr,NULL);\n        const char *expected_ptr = RedisModule_StringPtrLen(expected,NULL);\n        RedisModule_Log(ctx,\nwarning\n,\n            \nUnexpected string reply '%s' (instead of '%s')\n,\n            mystr_ptr, expected_ptr);\n        return 0;\n    }\n    return 1;\n}\n\n/* Return 1 if the reply matches the specified integer, otherwise log errors\n * in the server log and return 0. */\nint TestAssertIntegerReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply, long long expected) {\n    if (RedisModule_CallReplyType(reply) != REDISMODULE_REPLY_INTEGER) {\n        RedisModule_Log(ctx,\nwarning\n,\nUnexpected reply type %d\n,\n            RedisModule_CallReplyType(reply));\n        return 0;\n    }\n    long long val = RedisModule_CallReplyInteger(reply);\n    if (val != expected) {\n        RedisModule_Log(ctx,\nwarning\n,\n            \nUnexpected integer reply '%lld' (instead of '%lld')\n,\n            val, expected);\n        return 0;\n    }\n    return 1;\n}\n\n#define T(name,...) \\\n    do { \\\n        RedisModule_Log(ctx,\nwarning\n,\nTesting %s\n, name); \\\n        reply = RedisModule_Call(ctx,name,__VA_ARGS__); \\\n    } while (0);\n\n/* TEST.IT -- Run all the tests. */\nint TestIt(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    REDISMODULE_NOT_USED(argv);\n    REDISMODULE_NOT_USED(argc);\n\n    RedisModule_AutoMemory(ctx);\n    RedisModuleCallReply *reply;\n\n    /* Make sure the DB is empty before to proceed. */\n    T(\ndbsize\n,\n);\n    if (!TestAssertIntegerReply(ctx,reply,0)) goto fail;\n\n    T(\nping\n,\n);\n    if (!TestAssertStringReply(ctx,reply,\nPONG\n,4)) goto fail;\n\n    T(\ntest.call\n,\n);\n    if (!TestAssertStringReply(ctx,reply,\nOK\n,2)) goto fail;\n\n    T(\ntest.string.append\n,\n);\n    if (!TestAssertStringReply(ctx,reply,\nfoobar\n,6)) goto fail;\n\n    T(\ntest.string.append.am\n,\n);\n    if (!TestAssertStringReply(ctx,reply,\nfoobar\n,6)) goto fail;\n\n    T(\ntest.string.printf\n, \ncc\n, \nfoo\n, \nbar\n);\n    if (!TestAssertStringReply(ctx,reply,\nGot 3 args. argv[1]: foo, argv[2]: bar\n,38)) goto fail;\n\n    RedisModule_ReplyWithSimpleString(ctx,\nALL TESTS PASSED\n);\n    return REDISMODULE_OK;\n\nfail:\n    RedisModule_ReplyWithSimpleString(ctx,\n        \nSOME TEST NOT PASSED! Check server logs\n);\n    return REDISMODULE_OK;\n}\n\nint RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    REDISMODULE_NOT_USED(argv);\n    REDISMODULE_NOT_USED(argc);\n\n    if (RedisModule_Init(ctx,\ntest\n,1,REDISMODULE_APIVER_1)\n        == REDISMODULE_ERR) return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\ntest.call\n,\n        TestCall,\nwrite deny-oom\n,1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\ntest.string.append\n,\n        TestStringAppend,\nwrite deny-oom\n,1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\ntest.string.append.am\n,\n        TestStringAppendAM,\nwrite deny-oom\n,1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\ntest.string.printf\n,\n        TestStringPrintf,\nwrite deny-oom\n,1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\ntest.it\n,\n        TestIt,\nreadonly\n,1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    return REDISMODULE_OK;\n}", 
            "title": "testmodule.c"
        }, 
        {
            "location": "/code/redismodule/", 
            "text": "#ifndef REDISMODULE_H\n#define REDISMODULE_H\n\n#include \nsys/types.h\n\n#include \nstdint.h\n\n#include \nstdio.h\n\n\n/* ---------------- Defines common between core and modules --------------- */\n\n/* Error status return values. */\n#define REDISMODULE_OK 0\n#define REDISMODULE_ERR 1\n\n/* API versions. */\n#define REDISMODULE_APIVER_1 1\n\n/* API flags and constants */\n#define REDISMODULE_READ (1\n0)\n#define REDISMODULE_WRITE (1\n1)\n\n#define REDISMODULE_LIST_HEAD 0\n#define REDISMODULE_LIST_TAIL 1\n\n/* Key types. */\n#define REDISMODULE_KEYTYPE_EMPTY 0\n#define REDISMODULE_KEYTYPE_STRING 1\n#define REDISMODULE_KEYTYPE_LIST 2\n#define REDISMODULE_KEYTYPE_HASH 3\n#define REDISMODULE_KEYTYPE_SET 4\n#define REDISMODULE_KEYTYPE_ZSET 5\n#define REDISMODULE_KEYTYPE_MODULE 6\n\n/* Reply types. */\n#define REDISMODULE_REPLY_UNKNOWN -1\n#define REDISMODULE_REPLY_STRING 0\n#define REDISMODULE_REPLY_ERROR 1\n#define REDISMODULE_REPLY_INTEGER 2\n#define REDISMODULE_REPLY_ARRAY 3\n#define REDISMODULE_REPLY_NULL 4\n\n/* Postponed array length. */\n#define REDISMODULE_POSTPONED_ARRAY_LEN -1\n\n/* Expire */\n#define REDISMODULE_NO_EXPIRE -1\n\n/* Sorted set API flags. */\n#define REDISMODULE_ZADD_XX      (1\n0)\n#define REDISMODULE_ZADD_NX      (1\n1)\n#define REDISMODULE_ZADD_ADDED   (1\n2)\n#define REDISMODULE_ZADD_UPDATED (1\n3)\n#define REDISMODULE_ZADD_NOP     (1\n4)\n\n/* Hash API flags. */\n#define REDISMODULE_HASH_NONE       0\n#define REDISMODULE_HASH_NX         (1\n0)\n#define REDISMODULE_HASH_XX         (1\n1)\n#define REDISMODULE_HASH_CFIELDS    (1\n2)\n#define REDISMODULE_HASH_EXISTS     (1\n3)\n\n/* A special pointer that we can use between the core and the module to signal\n * field deletion, and that is impossible to be a valid pointer. */\n#define REDISMODULE_HASH_DELETE ((RedisModuleString*)(long)1)\n\n/* Error messages. */\n#define REDISMODULE_ERRORMSG_WRONGTYPE \nWRONGTYPE Operation against a key holding the wrong kind of value\n\n\n#define REDISMODULE_POSITIVE_INFINITE (1.0/0.0)\n#define REDISMODULE_NEGATIVE_INFINITE (-1.0/0.0)\n\n#define REDISMODULE_NOT_USED(V) ((void) V)\n\n/* ------------------------- End of common defines ------------------------ */\n\n#ifndef REDISMODULE_CORE\n\ntypedef long long mstime_t;\n\n/* Incomplete structures for compiler checks but opaque access. */\ntypedef struct RedisModuleCtx RedisModuleCtx;\ntypedef struct RedisModuleKey RedisModuleKey;\ntypedef struct RedisModuleString RedisModuleString;\ntypedef struct RedisModuleCallReply RedisModuleCallReply;\ntypedef struct RedisModuleIO RedisModuleIO;\ntypedef struct RedisModuleType RedisModuleType;\ntypedef struct RedisModuleDigest RedisModuleDigest;\ntypedef struct RedisModuleBlockedClient RedisModuleBlockedClient;\n\ntypedef int (*RedisModuleCmdFunc) (RedisModuleCtx *ctx, RedisModuleString **argv, int argc);\n\ntypedef void *(*RedisModuleTypeLoadFunc)(RedisModuleIO *rdb, int encver);\ntypedef void (*RedisModuleTypeSaveFunc)(RedisModuleIO *rdb, void *value);\ntypedef void (*RedisModuleTypeRewriteFunc)(RedisModuleIO *aof, RedisModuleString *key, void *value);\ntypedef void (*RedisModuleTypeDigestFunc)(RedisModuleDigest *digest, void *value);\ntypedef void (*RedisModuleTypeFreeFunc)(void *value);\n\n#define REDISMODULE_GET_API(name) \\\n    RedisModule_GetApi(\nRedisModule_\n #name, ((void **)\nRedisModule_ ## name))\n\n#define REDISMODULE_API_FUNC(x) (*x)\n\n\nvoid *REDISMODULE_API_FUNC(RedisModule_Alloc)(size_t bytes);\nvoid *REDISMODULE_API_FUNC(RedisModule_Realloc)(void *ptr, size_t bytes);\nvoid REDISMODULE_API_FUNC(RedisModule_Free)(void *ptr);\nvoid *REDISMODULE_API_FUNC(RedisModule_Calloc)(size_t nmemb, size_t size);\nchar *REDISMODULE_API_FUNC(RedisModule_Strdup)(const char *str);\nint REDISMODULE_API_FUNC(RedisModule_GetApi)(const char *, void *);\nint REDISMODULE_API_FUNC(RedisModule_CreateCommand)(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep);\nint REDISMODULE_API_FUNC(RedisModule_SetModuleAttribs)(RedisModuleCtx *ctx, const char *name, int ver, int apiver);\nint REDISMODULE_API_FUNC(RedisModule_WrongArity)(RedisModuleCtx *ctx);\nint REDISMODULE_API_FUNC(RedisModule_ReplyWithLongLong)(RedisModuleCtx *ctx, long long ll);\nint REDISMODULE_API_FUNC(RedisModule_GetSelectedDb)(RedisModuleCtx *ctx);\nint REDISMODULE_API_FUNC(RedisModule_SelectDb)(RedisModuleCtx *ctx, int newid);\nvoid *REDISMODULE_API_FUNC(RedisModule_OpenKey)(RedisModuleCtx *ctx, RedisModuleString *keyname, int mode);\nvoid REDISMODULE_API_FUNC(RedisModule_CloseKey)(RedisModuleKey *kp);\nint REDISMODULE_API_FUNC(RedisModule_KeyType)(RedisModuleKey *kp);\nsize_t REDISMODULE_API_FUNC(RedisModule_ValueLength)(RedisModuleKey *kp);\nint REDISMODULE_API_FUNC(RedisModule_ListPush)(RedisModuleKey *kp, int where, RedisModuleString *ele);\nRedisModuleString *REDISMODULE_API_FUNC(RedisModule_ListPop)(RedisModuleKey *key, int where);\nRedisModuleCallReply *REDISMODULE_API_FUNC(RedisModule_Call)(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...);\nconst char *REDISMODULE_API_FUNC(RedisModule_CallReplyProto)(RedisModuleCallReply *reply, size_t *len);\nvoid REDISMODULE_API_FUNC(RedisModule_FreeCallReply)(RedisModuleCallReply *reply);\nint REDISMODULE_API_FUNC(RedisModule_CallReplyType)(RedisModuleCallReply *reply);\nlong long REDISMODULE_API_FUNC(RedisModule_CallReplyInteger)(RedisModuleCallReply *reply);\nsize_t REDISMODULE_API_FUNC(RedisModule_CallReplyLength)(RedisModuleCallReply *reply);\nRedisModuleCallReply *REDISMODULE_API_FUNC(RedisModule_CallReplyArrayElement)(RedisModuleCallReply *reply, size_t idx);\nRedisModuleString *REDISMODULE_API_FUNC(RedisModule_CreateString)(RedisModuleCtx *ctx, const char *ptr, size_t len);\nRedisModuleString *REDISMODULE_API_FUNC(RedisModule_CreateStringFromLongLong)(RedisModuleCtx *ctx, long long ll);\nRedisModuleString *REDISMODULE_API_FUNC(RedisModule_CreateStringFromString)(RedisModuleCtx *ctx, const RedisModuleString *str);\nRedisModuleString *REDISMODULE_API_FUNC(RedisModule_CreateStringPrintf)(RedisModuleCtx *ctx, const char *fmt, ...);\nvoid REDISMODULE_API_FUNC(RedisModule_FreeString)(RedisModuleCtx *ctx, RedisModuleString *str);\nconst char *REDISMODULE_API_FUNC(RedisModule_StringPtrLen)(const RedisModuleString *str, size_t *len);\nint REDISMODULE_API_FUNC(RedisModule_ReplyWithError)(RedisModuleCtx *ctx, const char *err);\nint REDISMODULE_API_FUNC(RedisModule_ReplyWithSimpleString)(RedisModuleCtx *ctx, const char *msg);\nint REDISMODULE_API_FUNC(RedisModule_ReplyWithArray)(RedisModuleCtx *ctx, long len);\nvoid REDISMODULE_API_FUNC(RedisModule_ReplySetArrayLength)(RedisModuleCtx *ctx, long len);\nint REDISMODULE_API_FUNC(RedisModule_ReplyWithStringBuffer)(RedisModuleCtx *ctx, const char *buf, size_t len);\nint REDISMODULE_API_FUNC(RedisModule_ReplyWithString)(RedisModuleCtx *ctx, RedisModuleString *str);\nint REDISMODULE_API_FUNC(RedisModule_ReplyWithNull)(RedisModuleCtx *ctx);\nint REDISMODULE_API_FUNC(RedisModule_ReplyWithDouble)(RedisModuleCtx *ctx, double d);\nint REDISMODULE_API_FUNC(RedisModule_ReplyWithCallReply)(RedisModuleCtx *ctx, RedisModuleCallReply *reply);\nint REDISMODULE_API_FUNC(RedisModule_StringToLongLong)(const RedisModuleString *str, long long *ll);\nint REDISMODULE_API_FUNC(RedisModule_StringToDouble)(const RedisModuleString *str, double *d);\nvoid REDISMODULE_API_FUNC(RedisModule_AutoMemory)(RedisModuleCtx *ctx);\nint REDISMODULE_API_FUNC(RedisModule_Replicate)(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...);\nint REDISMODULE_API_FUNC(RedisModule_ReplicateVerbatim)(RedisModuleCtx *ctx);\nconst char *REDISMODULE_API_FUNC(RedisModule_CallReplyStringPtr)(RedisModuleCallReply *reply, size_t *len);\nRedisModuleString *REDISMODULE_API_FUNC(RedisModule_CreateStringFromCallReply)(RedisModuleCallReply *reply);\nint REDISMODULE_API_FUNC(RedisModule_DeleteKey)(RedisModuleKey *key);\nint REDISMODULE_API_FUNC(RedisModule_StringSet)(RedisModuleKey *key, RedisModuleString *str);\nchar *REDISMODULE_API_FUNC(RedisModule_StringDMA)(RedisModuleKey *key, size_t *len, int mode);\nint REDISMODULE_API_FUNC(RedisModule_StringTruncate)(RedisModuleKey *key, size_t newlen);\nmstime_t REDISMODULE_API_FUNC(RedisModule_GetExpire)(RedisModuleKey *key);\nint REDISMODULE_API_FUNC(RedisModule_SetExpire)(RedisModuleKey *key, mstime_t expire);\nint REDISMODULE_API_FUNC(RedisModule_ZsetAdd)(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr);\nint REDISMODULE_API_FUNC(RedisModule_ZsetIncrby)(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr, double *newscore);\nint REDISMODULE_API_FUNC(RedisModule_ZsetScore)(RedisModuleKey *key, RedisModuleString *ele, double *score);\nint REDISMODULE_API_FUNC(RedisModule_ZsetRem)(RedisModuleKey *key, RedisModuleString *ele, int *deleted);\nvoid REDISMODULE_API_FUNC(RedisModule_ZsetRangeStop)(RedisModuleKey *key);\nint REDISMODULE_API_FUNC(RedisModule_ZsetFirstInScoreRange)(RedisModuleKey *key, double min, double max, int minex, int maxex);\nint REDISMODULE_API_FUNC(RedisModule_ZsetLastInScoreRange)(RedisModuleKey *key, double min, double max, int minex, int maxex);\nint REDISMODULE_API_FUNC(RedisModule_ZsetFirstInLexRange)(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max);\nint REDISMODULE_API_FUNC(RedisModule_ZsetLastInLexRange)(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max);\nRedisModuleString *REDISMODULE_API_FUNC(RedisModule_ZsetRangeCurrentElement)(RedisModuleKey *key, double *score);\nint REDISMODULE_API_FUNC(RedisModule_ZsetRangeNext)(RedisModuleKey *key);\nint REDISMODULE_API_FUNC(RedisModule_ZsetRangePrev)(RedisModuleKey *key);\nint REDISMODULE_API_FUNC(RedisModule_ZsetRangeEndReached)(RedisModuleKey *key);\nint REDISMODULE_API_FUNC(RedisModule_HashSet)(RedisModuleKey *key, int flags, ...);\nint REDISMODULE_API_FUNC(RedisModule_HashGet)(RedisModuleKey *key, int flags, ...);\nint REDISMODULE_API_FUNC(RedisModule_IsKeysPositionRequest)(RedisModuleCtx *ctx);\nvoid REDISMODULE_API_FUNC(RedisModule_KeyAtPos)(RedisModuleCtx *ctx, int pos);\nunsigned long long REDISMODULE_API_FUNC(RedisModule_GetClientId)(RedisModuleCtx *ctx);\nvoid *REDISMODULE_API_FUNC(RedisModule_PoolAlloc)(RedisModuleCtx *ctx, size_t bytes);\nRedisModuleType *REDISMODULE_API_FUNC(RedisModule_CreateDataType)(RedisModuleCtx *ctx, const char *name, int encver, RedisModuleTypeLoadFunc rdb_load, RedisModuleTypeSaveFunc rdb_save, RedisModuleTypeRewriteFunc aof_rewrite, RedisModuleTypeDigestFunc digest, RedisModuleTypeFreeFunc free);\nint REDISMODULE_API_FUNC(RedisModule_ModuleTypeSetValue)(RedisModuleKey *key, RedisModuleType *mt, void *value);\nRedisModuleType *REDISMODULE_API_FUNC(RedisModule_ModuleTypeGetType)(RedisModuleKey *key);\nvoid *REDISMODULE_API_FUNC(RedisModule_ModuleTypeGetValue)(RedisModuleKey *key);\nvoid REDISMODULE_API_FUNC(RedisModule_SaveUnsigned)(RedisModuleIO *io, uint64_t value);\nuint64_t REDISMODULE_API_FUNC(RedisModule_LoadUnsigned)(RedisModuleIO *io);\nvoid REDISMODULE_API_FUNC(RedisModule_SaveSigned)(RedisModuleIO *io, int64_t value);\nint64_t REDISMODULE_API_FUNC(RedisModule_LoadSigned)(RedisModuleIO *io);\nvoid REDISMODULE_API_FUNC(RedisModule_EmitAOF)(RedisModuleIO *io, const char *cmdname, const char *fmt, ...);\nvoid REDISMODULE_API_FUNC(RedisModule_SaveString)(RedisModuleIO *io, RedisModuleString *s);\nvoid REDISMODULE_API_FUNC(RedisModule_SaveStringBuffer)(RedisModuleIO *io, const char *str, size_t len);\nRedisModuleString *REDISMODULE_API_FUNC(RedisModule_LoadString)(RedisModuleIO *io);\nchar *REDISMODULE_API_FUNC(RedisModule_LoadStringBuffer)(RedisModuleIO *io, size_t *lenptr);\nvoid REDISMODULE_API_FUNC(RedisModule_SaveDouble)(RedisModuleIO *io, double value);\ndouble REDISMODULE_API_FUNC(RedisModule_LoadDouble)(RedisModuleIO *io);\nvoid REDISMODULE_API_FUNC(RedisModule_SaveFloat)(RedisModuleIO *io, float value);\nfloat REDISMODULE_API_FUNC(RedisModule_LoadFloat)(RedisModuleIO *io);\nvoid REDISMODULE_API_FUNC(RedisModule_Log)(RedisModuleCtx *ctx, const char *level, const char *fmt, ...);\nvoid REDISMODULE_API_FUNC(RedisModule_LogIOError)(RedisModuleIO *io, const char *levelstr, const char *fmt, ...);\nint REDISMODULE_API_FUNC(RedisModule_StringAppendBuffer)(RedisModuleCtx *ctx, RedisModuleString *str, const char *buf, size_t len);\nvoid REDISMODULE_API_FUNC(RedisModule_RetainString)(RedisModuleCtx *ctx, RedisModuleString *str);\nint REDISMODULE_API_FUNC(RedisModule_StringCompare)(RedisModuleString *a, RedisModuleString *b);\nRedisModuleCtx *REDISMODULE_API_FUNC(RedisModule_GetContextFromIO)(RedisModuleIO *io);\nRedisModuleBlockedClient *REDISMODULE_API_FUNC(RedisModule_BlockClient)(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback, RedisModuleCmdFunc timeout_callback, void (*free_privdata)(void*), long long timeout_ms);\nint REDISMODULE_API_FUNC(RedisModule_UnblockClient)(RedisModuleBlockedClient *bc, void *privdata);\nint REDISMODULE_API_FUNC(RedisModule_IsBlockedReplyRequest)(RedisModuleCtx *ctx);\nint REDISMODULE_API_FUNC(RedisModule_IsBlockedTimeoutRequest)(RedisModuleCtx *ctx);\nvoid *REDISMODULE_API_FUNC(RedisModule_GetBlockedClientPrivateData)(RedisModuleCtx *ctx);\nint REDISMODULE_API_FUNC(RedisModule_AbortBlock)(RedisModuleBlockedClient *bc);\nlong long REDISMODULE_API_FUNC(RedisModule_Milliseconds)(void);\n\n/* This is included inline inside each Redis module. */\nstatic int RedisModule_Init(RedisModuleCtx *ctx, const char *name, int ver, int apiver) __attribute__((unused));\nstatic int RedisModule_Init(RedisModuleCtx *ctx, const char *name, int ver, int apiver) {\n    void *getapifuncptr = ((void**)ctx)[0];\n    RedisModule_GetApi = (int (*)(const char *, void *)) (unsigned long)getapifuncptr;\n    REDISMODULE_GET_API(Alloc);\n    REDISMODULE_GET_API(Calloc);\n    REDISMODULE_GET_API(Free);\n    REDISMODULE_GET_API(Realloc);\n    REDISMODULE_GET_API(Strdup);\n    REDISMODULE_GET_API(CreateCommand);\n    REDISMODULE_GET_API(SetModuleAttribs);\n    REDISMODULE_GET_API(WrongArity);\n    REDISMODULE_GET_API(ReplyWithLongLong);\n    REDISMODULE_GET_API(ReplyWithError);\n    REDISMODULE_GET_API(ReplyWithSimpleString);\n    REDISMODULE_GET_API(ReplyWithArray);\n    REDISMODULE_GET_API(ReplySetArrayLength);\n    REDISMODULE_GET_API(ReplyWithStringBuffer);\n    REDISMODULE_GET_API(ReplyWithString);\n    REDISMODULE_GET_API(ReplyWithNull);\n    REDISMODULE_GET_API(ReplyWithCallReply);\n    REDISMODULE_GET_API(ReplyWithDouble);\n    REDISMODULE_GET_API(ReplySetArrayLength);\n    REDISMODULE_GET_API(GetSelectedDb);\n    REDISMODULE_GET_API(SelectDb);\n    REDISMODULE_GET_API(OpenKey);\n    REDISMODULE_GET_API(CloseKey);\n    REDISMODULE_GET_API(KeyType);\n    REDISMODULE_GET_API(ValueLength);\n    REDISMODULE_GET_API(ListPush);\n    REDISMODULE_GET_API(ListPop);\n    REDISMODULE_GET_API(StringToLongLong);\n    REDISMODULE_GET_API(StringToDouble);\n    REDISMODULE_GET_API(Call);\n    REDISMODULE_GET_API(CallReplyProto);\n    REDISMODULE_GET_API(FreeCallReply);\n    REDISMODULE_GET_API(CallReplyInteger);\n    REDISMODULE_GET_API(CallReplyType);\n    REDISMODULE_GET_API(CallReplyLength);\n    REDISMODULE_GET_API(CallReplyArrayElement);\n    REDISMODULE_GET_API(CallReplyStringPtr);\n    REDISMODULE_GET_API(CreateStringFromCallReply);\n    REDISMODULE_GET_API(CreateString);\n    REDISMODULE_GET_API(CreateStringFromLongLong);\n    REDISMODULE_GET_API(CreateStringFromString);\n    REDISMODULE_GET_API(CreateStringPrintf);\n    REDISMODULE_GET_API(FreeString);\n    REDISMODULE_GET_API(StringPtrLen);\n    REDISMODULE_GET_API(AutoMemory);\n    REDISMODULE_GET_API(Replicate);\n    REDISMODULE_GET_API(ReplicateVerbatim);\n    REDISMODULE_GET_API(DeleteKey);\n    REDISMODULE_GET_API(StringSet);\n    REDISMODULE_GET_API(StringDMA);\n    REDISMODULE_GET_API(StringTruncate);\n    REDISMODULE_GET_API(GetExpire);\n    REDISMODULE_GET_API(SetExpire);\n    REDISMODULE_GET_API(ZsetAdd);\n    REDISMODULE_GET_API(ZsetIncrby);\n    REDISMODULE_GET_API(ZsetScore);\n    REDISMODULE_GET_API(ZsetRem);\n    REDISMODULE_GET_API(ZsetRangeStop);\n    REDISMODULE_GET_API(ZsetFirstInScoreRange);\n    REDISMODULE_GET_API(ZsetLastInScoreRange);\n    REDISMODULE_GET_API(ZsetFirstInLexRange);\n    REDISMODULE_GET_API(ZsetLastInLexRange);\n    REDISMODULE_GET_API(ZsetRangeCurrentElement);\n    REDISMODULE_GET_API(ZsetRangeNext);\n    REDISMODULE_GET_API(ZsetRangePrev);\n    REDISMODULE_GET_API(ZsetRangeEndReached);\n    REDISMODULE_GET_API(HashSet);\n    REDISMODULE_GET_API(HashGet);\n    REDISMODULE_GET_API(IsKeysPositionRequest);\n    REDISMODULE_GET_API(KeyAtPos);\n    REDISMODULE_GET_API(GetClientId);\n    REDISMODULE_GET_API(PoolAlloc);\n    REDISMODULE_GET_API(CreateDataType);\n    REDISMODULE_GET_API(ModuleTypeSetValue);\n    REDISMODULE_GET_API(ModuleTypeGetType);\n    REDISMODULE_GET_API(ModuleTypeGetValue);\n    REDISMODULE_GET_API(SaveUnsigned);\n    REDISMODULE_GET_API(LoadUnsigned);\n    REDISMODULE_GET_API(SaveSigned);\n    REDISMODULE_GET_API(LoadSigned);\n    REDISMODULE_GET_API(SaveString);\n    REDISMODULE_GET_API(SaveStringBuffer);\n    REDISMODULE_GET_API(LoadString);\n    REDISMODULE_GET_API(LoadStringBuffer);\n    REDISMODULE_GET_API(SaveDouble);\n    REDISMODULE_GET_API(LoadDouble);\n    REDISMODULE_GET_API(SaveFloat);\n    REDISMODULE_GET_API(LoadFloat);\n    REDISMODULE_GET_API(EmitAOF);\n    REDISMODULE_GET_API(Log);\n    REDISMODULE_GET_API(LogIOError);\n    REDISMODULE_GET_API(StringAppendBuffer);\n    REDISMODULE_GET_API(RetainString);\n    REDISMODULE_GET_API(StringCompare);\n    REDISMODULE_GET_API(GetContextFromIO);\n    REDISMODULE_GET_API(BlockClient);\n    REDISMODULE_GET_API(UnblockClient);\n    REDISMODULE_GET_API(IsBlockedReplyRequest);\n    REDISMODULE_GET_API(IsBlockedTimeoutRequest);\n    REDISMODULE_GET_API(GetBlockedClientPrivateData);\n    REDISMODULE_GET_API(AbortBlock);\n    REDISMODULE_GET_API(Milliseconds);\n\n    RedisModule_SetModuleAttribs(ctx,name,ver,apiver);\n    return REDISMODULE_OK;\n}\n\n#else\n\n/* Things only defined for the modules core, not exported to modules\n * including this file. */\n#define RedisModuleString robj\n\n#endif /* REDISMODULE_CORE */\n#endif /* REDISMOUDLE_H */", 
            "title": "redismodule.h"
        }
    ]
}